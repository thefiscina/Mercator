/* =========================================================
 * bootstrap-slider.js v3.0.0
 * http://www.eyecon.ro/bootstrap-slider
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

// (function ($) {

//     var ErrorMsgs = {
//         formatInvalidInputErrorMsg: function (input) {
//             return "Invalid input value '" + input + "' passed in";
//         },
//         callingContextNotSliderInstance: "Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"
//     };

//     var Slider = function (element, options) {
//         var el = this.element = $(element).hide();
//         var origWidth = $(element)[0].style.width;

//         var updateSlider = false;
//         var parent = this.element.parent();


//         if (parent.hasClass('slider') === true) {
//             updateSlider = true;
//             this.picker = parent;
//         } else {
//             this.picker = $('<div class="slider">' +
//                 '<div class="slider-track">' +
//                 '<div class="slider-selection"></div>' +
//                 '<div class="slider-handle"></div>' +
//                 '<div class="slider-handle slider-handle-invisible"></div>' +
//                 '</div>' +
//                 '<div id="tooltip" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
//                 '<div id="tooltip_min" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
//                 '<div id="tooltip_max" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
//                 '</div>')
//                 .insertBefore(this.element)
//                 .append(this.element);
//         }

//         this.id = this.element.data('slider-id') || options.id;
//         if (this.id) {
//             this.picker[0].id = this.id;
//         }

//         if (typeof Modernizr !== 'undefined' && Modernizr.touch) {
//             this.touchCapable = true;
//         }

//         var tooltip = this.element.data('slider-tooltip') || options.tooltip;

//         this.tooltip = this.picker.find('#tooltip');
//         this.tooltipInner = this.tooltip.find('div.tooltip-inner');

//         this.tooltip_min = this.picker.find('#tooltip_min');
//         this.tooltipInner_min = this.tooltip_min.find('div.tooltip-inner');

//         this.tooltip_max = this.picker.find('#tooltip_max');
//         this.tooltipInner_max = this.tooltip_max.find('div.tooltip-inner');

//         if (updateSlider === true) {
//             // Reset classes
//             this.picker.removeClass('slider-horizontal');
//             this.picker.removeClass('slider-vertical');
//             this.tooltip.removeClass('hide');
//             this.tooltip_min.removeClass('hide');
//             this.tooltip_max.removeClass('hide');

//         }

//         this.orientation = this.element.data('slider-orientation') || options.orientation;
//         switch (this.orientation) {
//             case 'vertical':
//                 this.picker.addClass('slider-vertical');
//                 this.stylePos = 'top';
//                 this.mousePos = 'pageY';
//                 this.sizePos = 'offsetHeight';
//                 this.tooltip.addClass('right')[0].style.left = '100%';
//                 this.tooltip_min.addClass('right')[0].style.left = '100%';
//                 this.tooltip_max.addClass('right')[0].style.left = '100%';
//                 break;
//             default:
//                 this.picker
//                     .addClass('slider-horizontal')
//                     .css('width', origWidth);
//                 this.orientation = 'horizontal';
//                 this.stylePos = 'left';
//                 this.mousePos = 'pageX';
//                 this.sizePos = 'offsetWidth';
//                 this.tooltip.addClass('top')[0].style.top = -this.tooltip.outerHeight() - 14 + 'px';
//                 this.tooltip_min.addClass('top')[0].style.top = -this.tooltip_min.outerHeight() - 14 + 'px';
//                 this.tooltip_max.addClass('top')[0].style.top = -this.tooltip_max.outerHeight() - 14 + 'px';
//                 break;
//         }

//         var self = this;
//         $.each(['min', 'max', 'step', 'value'], function (i, attr) {
//             if (typeof el.data('slider-' + attr) !== 'undefined') {
//                 self[attr] = el.data('slider-' + attr);
//             } else if (typeof options[attr] !== 'undefined') {
//                 self[attr] = options[attr];
//             } else if (typeof el.prop(attr) !== 'undefined') {
//                 self[attr] = el.prop(attr);
//             } else {
//                 self[attr] = 0; // to prevent empty string issues in calculations in IE
//             }
//         });

//         if (this.value instanceof Array) {
//             if (updateSlider && !this.range) {
//                 this.value = this.value[0];
//             } else {
//                 this.range = true;
//             }
//         } else if (this.range) {
//             // User wants a range, but value is not an array
//             this.value = [this.value, this.max];
//         }

//         this.selection = this.element.data('slider-selection') || options.selection;
//         this.selectionEl = this.picker.find('.slider-selection');
//         if (this.selection === 'none') {
//             this.selectionEl.addClass('hide');
//         }

//         this.selectionElStyle = this.selectionEl[0].style;

//         this.handle1 = this.picker.find('.slider-handle:first');
//         this.handle1Stype = this.handle1[0].style;

//         this.handle2 = this.picker.find('.slider-handle:last');
//         this.handle2Stype = this.handle2[0].style;

//         if (updateSlider === true) {
//             // Reset classes
//             this.handle1.removeClass('round triangle');
//             this.handle2.removeClass('round triangle hide');
//         }

//         var handle = this.element.data('slider-handle') || options.handle;
//         switch (handle) {
//             case 'round':
//                 this.handle1.addClass('round');
//                 this.handle2.addClass('round');
//                 break;
//             case 'triangle':
//                 this.handle1.addClass('triangle');
//                 this.handle2.addClass('triangle');
//                 break;
//         }

//         if (this.range) {
//             this.value[0] = Math.max(this.min, Math.min(this.max, this.value[0]));
//             this.value[1] = Math.max(this.min, Math.min(this.max, this.value[1]));
//         } else {
//             this.value = [Math.max(this.min, Math.min(this.max, this.value))];
//             this.handle2.addClass('hide');
//             if (this.selection === 'after') {
//                 this.value[1] = this.max;
//             } else {
//                 this.value[1] = this.min;
//             }
//         }
//         this.diff = this.max - this.min;
//         this.percentage = [
//             (this.value[0] - this.min) * 100 / this.diff,
//             (this.value[1] - this.min) * 100 / this.diff,
//             this.step * 100 / this.diff
//         ];

//         this.offset = this.picker.offset();
//         this.size = this.picker[0][this.sizePos];

//         this.formater = options.formater;
//         this.tooltip_separator = options.tooltip_separator;
//         this.tooltip_split = options.tooltip_split;

//         this.reversed = this.element.data('slider-reversed') || options.reversed;

//         this.layout();
//         this.layout();

//         this.handle1.on({
//             keydown: $.proxy(this.keydown, this, 0)
//         });

//         this.handle2.on({
//             keydown: $.proxy(this.keydown, this, 1)
//         });

//         if (this.touchCapable) {
//             // Touch: Bind touch events:
//             this.picker.on({
//                 touchstart: $.proxy(this.mousedown, this)
//             });
//         } else {
//             this.picker.on({
//                 mousedown: $.proxy(this.mousedown, this)
//             });
//         }

//         if (tooltip === 'hide') {
//             this.tooltip.addClass('hide');
//             this.tooltip_min.addClass('hide');
//             this.tooltip_max.addClass('hide');
//         } else if (tooltip === 'always') {
//             this.showTooltip();
//             this.alwaysShowTooltip = true;
//         } else {
//             this.picker.on({
//                 mouseenter: $.proxy(this.showTooltip, this),
//                 mouseleave: $.proxy(this.hideTooltip, this)
//             });
//             this.handle1.on({
//                 focus: $.proxy(this.showTooltip, this),
//                 blur: $.proxy(this.hideTooltip, this)
//             });
//             this.handle2.on({
//                 focus: $.proxy(this.showTooltip, this),
//                 blur: $.proxy(this.hideTooltip, this)
//             });
//         }

//         this.enabled = options.enabled &&
//             (this.element.data('slider-enabled') === undefined || this.element.data('slider-enabled') === true);
//         if (this.enabled) {
//             this.enable();
//         } else {
//             this.disable();
//         }
//     };

//     Slider.prototype = {
//         constructor: Slider,

//         over: false,
//         inDrag: false,

//         showTooltip: function () {
//             if (this.tooltip_split === false) {
//                 this.tooltip.addClass('in');
//             } else {
//                 this.tooltip_min.addClass('in');
//                 this.tooltip_max.addClass('in');
//             }

//             this.over = true;
//         },

//         hideTooltip: function () {
//             if (this.inDrag === false && this.alwaysShowTooltip !== true) {
//                 this.tooltip.removeClass('in');
//                 this.tooltip_min.removeClass('in');
//                 this.tooltip_max.removeClass('in');
//             }
//             this.over = false;
//         },

//         layout: function () {
//             var positionPercentages;

//             if (this.reversed) {
//                 positionPercentages = [100 - this.percentage[0], this.percentage[1]];
//             } else {
//                 positionPercentages = [this.percentage[0], this.percentage[1]];
//             }

//             this.handle1Stype[this.stylePos] = positionPercentages[0] + '%';
//             this.handle2Stype[this.stylePos] = positionPercentages[1] + '%';

//             if (this.orientation === 'vertical') {
//                 this.selectionElStyle.top = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
//                 this.selectionElStyle.height = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';
//             } else {
//                 this.selectionElStyle.left = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
//                 this.selectionElStyle.width = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

//                 var offset_min = this.tooltip_min[0].getBoundingClientRect();
//                 var offset_max = this.tooltip_max[0].getBoundingClientRect();

//                 if (offset_min.right > offset_max.left) {
//                     this.tooltip_max.removeClass('top');
//                     this.tooltip_max.addClass('bottom')[0].style.top = 18 + 'px';
//                 } else {
//                     this.tooltip_max.removeClass('bottom');
//                     this.tooltip_max.addClass('top')[0].style.top = -30 + 'px';
//                 }
//             }

//             if (this.range) {
//                 this.tooltipInner.text(
//                     this.formater(this.value[0]) + this.tooltip_separator + this.formater(this.value[1])
//                 );
//                 this.tooltip[0].style[this.stylePos] = this.size * (positionPercentages[0] + (positionPercentages[1] - positionPercentages[0]) / 2) / 100 - (this.orientation === 'vertical' ? this.tooltip.outerHeight() / 2 : this.tooltip.outerWidth() / 2) + 'px';

//                 this.tooltipInner_min.text(
//                     this.formater(this.value[0])
//                 );
//                 this.tooltipInner_max.text(
//                     this.formater(this.value[1])
//                 );

//                 this.tooltip_min[0].style[this.stylePos] = this.size * ((positionPercentages[0]) / 100) - (this.orientation === 'vertical' ? this.tooltip_min.outerHeight() / 2 : this.tooltip_min.outerWidth() / 2) + 'px';
//                 this.tooltip_max[0].style[this.stylePos] = this.size * ((positionPercentages[1]) / 100) - (this.orientation === 'vertical' ? this.tooltip_max.outerHeight() / 2 : this.tooltip_max.outerWidth() / 2) + 'px';

//             } else {
//                 this.tooltipInner.text(
//                     this.formater(this.value[0])
//                 );
//                 this.tooltip[0].style[this.stylePos] = this.size * positionPercentages[0] / 100 - (this.orientation === 'vertical' ? this.tooltip.outerHeight() / 2 : this.tooltip.outerWidth() / 2) + 'px';
//             }
//         },

//         mousedown: function (ev) {
//             if (!this.isEnabled()) {
//                 return false;
//             }
//             // Touch: Get the original event:
//             if (this.touchCapable && ev.type === 'touchstart') {
//                 ev = ev.originalEvent;
//             }

//             this.triggerFocusOnHandle();

//             this.offset = this.picker.offset();
//             this.size = this.picker[0][this.sizePos];

//             var percentage = this.getPercentage(ev);

//             if (this.range) {
//                 var diff1 = Math.abs(this.percentage[0] - percentage);
//                 var diff2 = Math.abs(this.percentage[1] - percentage);
//                 this.dragged = (diff1 < diff2) ? 0 : 1;
//             } else {
//                 this.dragged = 0;
//             }

//             this.percentage[this.dragged] = this.reversed ? 100 - percentage : percentage;
//             this.layout();

//             if (this.touchCapable) {
//                 // Touch: Bind touch events:
//                 $(document).on({
//                     touchmove: $.proxy(this.mousemove, this),
//                     touchend: $.proxy(this.mouseup, this)
//                 });
//             } else {
//                 $(document).on({
//                     mousemove: $.proxy(this.mousemove, this),
//                     mouseup: $.proxy(this.mouseup, this)
//                 });
//             }

//             this.inDrag = true;
//             var val = this.calculateValue();
//             this.setValue(val);
//             this.element.trigger({
//                 type: 'slideStart',
//                 value: val
//             }).trigger({
//                 type: 'slide',
//                 value: val
//             });
//             return true;
//         },

//         triggerFocusOnHandle: function (handleIdx) {
//             if (handleIdx === 0) {
//                 this.handle1.focus();
//             }
//             if (handleIdx === 1) {
//                 this.handle2.focus();
//             }
//         },

//         keydown: function (handleIdx, ev) {
//             if (!this.isEnabled()) {
//                 return false;
//             }

//             var dir;
//             switch (ev.which) {
//                 case 37: // left
//                 case 40: // down
//                     dir = -1;
//                     break;
//                 case 39: // right
//                 case 38: // up
//                     dir = 1;
//                     break;
//             }
//             if (!dir) {
//                 return;
//             }

//             var oneStepValuePercentageChange = dir * this.percentage[2];
//             var percentage = this.percentage[handleIdx] + oneStepValuePercentageChange;

//             if (percentage > 100) {
//                 percentage = 100;
//             } else if (percentage < 0) {
//                 percentage = 0;
//             }

//             this.dragged = handleIdx;
//             this.adjustPercentageForRangeSliders(percentage);
//             this.percentage[this.dragged] = percentage;
//             this.layout();

//             var val = this.calculateValue();
//             this.setValue(val);
//             this.element
//                 .trigger({
//                     type: 'slide',
//                     value: val
//                 })
//                 .trigger({
//                     type: 'slideStop',
//                     value: val
//                 })
//                 .data('value', val)
//                 .prop('value', val);
//             return false;
//         },

//         mousemove: function (ev) {
//             if (!this.isEnabled()) {
//                 return false;
//             }
//             // Touch: Get the original event:
//             if (this.touchCapable && ev.type === 'touchmove') {
//                 ev = ev.originalEvent;
//             }

//             var percentage = this.getPercentage(ev);
//             this.adjustPercentageForRangeSliders(percentage);
//             this.percentage[this.dragged] = this.reversed ? 100 - percentage : percentage;
//             this.layout();

//             var val = this.calculateValue();
//             this.setValue(val);
//             this.element
//                 .trigger({
//                     type: 'slide',
//                     value: val
//                 })
//                 .data('value', val)
//                 .prop('value', val);
//             return false;
//         },

//         adjustPercentageForRangeSliders: function (percentage) {
//             if (this.range) {
//                 if (this.dragged === 0 && this.percentage[1] < percentage) {
//                     this.percentage[0] = this.percentage[1];
//                     this.dragged = 1;
//                 } else if (this.dragged === 1 && this.percentage[0] > percentage) {
//                     this.percentage[1] = this.percentage[0];
//                     this.dragged = 0;
//                 }
//             }
//         },

//         mouseup: function () {
//             if (!this.isEnabled()) {
//                 return false;
//             }
//             if (this.touchCapable) {
//                 // Touch: Bind touch events:
//                 $(document).off({
//                     touchmove: this.mousemove,
//                     touchend: this.mouseup
//                 });
//             } else {
//                 $(document).off({
//                     mousemove: this.mousemove,
//                     mouseup: this.mouseup
//                 });
//             }

//             this.inDrag = false;
//             if (this.over === false) {
//                 this.hideTooltip();
//             }
//             var val = this.calculateValue();
//             this.layout();
//             this.element
//                 .data('value', val)
//                 .prop('value', val)
//                 .trigger({
//                     type: 'slideStop',
//                     value: val
//                 });
//             return false;
//         },

//         calculateValue: function () {
//             var val;
//             if (this.range) {
//                 val = [this.min, this.max];
//                 if (this.percentage[0] !== 0) {
//                     val[0] = (Math.max(this.min, this.min + Math.round((this.diff * this.percentage[0] / 100) / this.step) * this.step));
//                 }
//                 if (this.percentage[1] !== 100) {
//                     val[1] = (Math.min(this.max, this.min + Math.round((this.diff * this.percentage[1] / 100) / this.step) * this.step));
//                 }
//                 this.value = val;
//             } else {
//                 val = (this.min + Math.round((this.diff * this.percentage[0] / 100) / this.step) * this.step);
//                 if (val < this.min) {
//                     val = this.min;
//                 }
//                 else if (val > this.max) {
//                     val = this.max;
//                 }
//                 val = parseFloat(val);
//                 this.value = [val, this.value[1]];
//             }
//             return val;
//         },

//         getPercentage: function (ev) {
//             if (this.touchCapable) {
//                 ev = ev.touches[0];
//             }
//             var percentage = (ev[this.mousePos] - this.offset[this.stylePos]) * 100 / this.size;
//             percentage = Math.round(percentage / this.percentage[2]) * this.percentage[2];
//             return Math.max(0, Math.min(100, percentage));
//         },

//         getValue: function () {
//             if (this.range) {
//                 return this.value;
//             }
//             return this.value[0];
//         },

//         setValue: function (val) {
//             this.value = this.validateInputValue(val);

//             if (this.range) {
//                 this.value[0] = Math.max(this.min, Math.min(this.max, this.value[0]));
//                 this.value[1] = Math.max(this.min, Math.min(this.max, this.value[1]));
//             } else {
//                 this.value = [Math.max(this.min, Math.min(this.max, this.value))];
//                 this.handle2.addClass('hide');
//                 if (this.selection === 'after') {
//                     this.value[1] = this.max;
//                 } else {
//                     this.value[1] = this.min;
//                 }
//             }
//             this.diff = this.max - this.min;
//             this.percentage = [
//                 (this.value[0] - this.min) * 100 / this.diff,
//                 (this.value[1] - this.min) * 100 / this.diff,
//                 this.step * 100 / this.diff
//             ];
//             this.layout();

//             this.element
//                 .trigger({
//                     'type': 'slide',
//                     'value': this.value
//                 })
//                 .data('value', this.value)
//                 .prop('value', this.value);
//         },

//         validateInputValue: function (val) {
//             if (typeof val === 'number') {
//                 return val;
//             } else if (val instanceof Array) {
//                 $.each(val, function (i, input) { if (typeof input !== 'number') { throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(input)); } });
//                 return val;
//             } else {
//                 throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(val));
//             }
//         },

//         destroy: function () {
//             this.handle1.off();
//             this.handle2.off();
//             this.element.off().show().insertBefore(this.picker);
//             this.picker.off().remove();
//             $(this.element).removeData('slider');
//         },

//         disable: function () {
//             this.enabled = false;
//             this.handle1.removeAttr("tabindex");
//             this.handle2.removeAttr("tabindex");
//             this.picker.addClass('slider-disabled');
//             this.element.trigger('slideDisabled');
//         },

//         enable: function () {
//             this.enabled = true;
//             this.handle1.attr("tabindex", 0);
//             this.handle2.attr("tabindex", 0);
//             this.picker.removeClass('slider-disabled');
//             this.element.trigger('slideEnabled');
//         },

//         toggle: function () {
//             if (this.enabled) {
//                 this.disable();
//             } else {
//                 this.enable();
//             }
//         },

//         isEnabled: function () {
//             return this.enabled;
//         },

//         setAttribute: function (attribute, value) {
//             this[attribute] = value;
//         }
//     };

//     var publicMethods = {
//         getValue: Slider.prototype.getValue,
//         setValue: Slider.prototype.setValue,
//         setAttribute: Slider.prototype.setAttribute,
//         destroy: Slider.prototype.destroy,
//         disable: Slider.prototype.disable,
//         enable: Slider.prototype.enable,
//         toggle: Slider.prototype.toggle,
//         isEnabled: Slider.prototype.isEnabled
//     };

//     $.fn.slider = function (option) {
//         if (typeof option === 'string' && option !== 'refresh') {
//             var args = Array.prototype.slice.call(arguments, 1);
//             return invokePublicMethod.call(this, option, args);
//         } else {
//             return createNewSliderInstance.call(this, option);
//         }
//     };

//     function invokePublicMethod(methodName, args) {
//         if (publicMethods[methodName]) {
//             var sliderObject = retrieveSliderObjectFromElement(this);
//             var result = publicMethods[methodName].apply(sliderObject, args);

//             if (typeof result === "undefined") {
//                 return $(this);
//             } else {
//                 return result;
//             }
//         } else {
//             throw new Error("method '" + methodName + "()' does not exist for slider.");
//         }
//     }

//     function retrieveSliderObjectFromElement(element) {
//         var sliderObject = $(element).data('slider');
//         if (sliderObject && sliderObject instanceof Slider) {
//             return sliderObject;
//         } else {
//             throw new Error(ErrorMsgs.callingContextNotSliderInstance);
//         }
//     }

//     function createNewSliderInstance(opts) {
//         var $this = $(this);
//         $this.each(function () {
//             var $this = $(this),
//                 slider = $this.data('slider'),
//                 options = typeof opts === 'object' && opts;

//             // If slider already exists, use its attributes
//             // as options so slider refreshes properly
//             if (slider && !options) {
//                 options = {};

//                 $.each($.fn.slider.defaults, function (key) {
//                     options[key] = slider[key];
//                 });
//             }

//             $this.data('slider', (new Slider(this, $.extend({}, $.fn.slider.defaults, options))));
//         });
//         return $this;
//     }

//     $.fn.slider.defaults = {
//         min: 0,
//         max: 10,
//         step: 1,
//         orientation: 'horizontal',
//         value: 5,
//         range: false,
//         selection: 'before',
//         tooltip: 'show',
//         tooltip_separator: ':',
//         tooltip_split: false,
//         handle: 'round',
//         reversed: false,
//         enabled: true,
//         formater: function (value) {
//             return value;
//         }
//     };

//     $.fn.slider.Constructor = Slider;

// })(window.jQuery);

// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.2 - JavaScript Vector Library                          │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    │ \\
// │ Copyright © 2008-2012 Sencha Labs (http://sencha.com)              │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

(function (glob) {
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () { },
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = { n: {} },
        /*\
         * eve
         [ method ]
    
         * Fires event with given `name`, given scope and other parameters.
    
         > Arguments
    
         - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
         - scope (object) context for the event handlers
         - varargs (...) the rest of arguments will be sent to event handlers
    
         = (object) array of returned values from the listeners
        \*/
        eve = function (name, scope) {
            name = String(name);
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };

    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
    eve.on = function (name, f) {
        name = String(name);
        if (typeof f != "function") {
            return function () { };
        }
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = { n: {} });
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
       | el.onclick = eve.f("click", 1, 2);
       | eve.on("click", function (a, b, c) {
       |     console.log(a, b, c); // 1, 2, [event object]
       | });
     > Arguments
     - event (string) event name
     - varargs (…) and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = { n: {} };
            return;
        }
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define != "undefined" ? (define("eve", [], function () { return eve; })) : (glob.eve = eve));
})(this);
// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ "Raphaël 2.1.2" - JavaScript Vector Library                         │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    // AMD support
    if (typeof define === "function" && define.amd) {
        // Define as an anonymous module
        define(["eve"], function (eve) {
            return factory(glob, eve);
        });
    } else {
        // Browser globals (glob is window)
        // Raphael adds itself to window
        factory(glob, glob.eve);
    }
}(this, function (window, eve) {
    /*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     > Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
     = (object) @Paper
     > Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewport’s 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
    \*/
    function R(first) {
        if (R.is(first, "function")) {
            return loaded ? first() : eve.on("raphael.DOMload", first);
        } else if (R.is(first, array)) {
            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        } else {
            var args = Array.prototype.slice.call(arguments, 0);
            if (R.is(args[args.length - 1], "function")) {
                var f = args.pop();
                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                    f.call(R._engine.create[apply](R, args));
                });
            } else {
                return R._engine.create[apply](R, arguments);
            }
        }
    }
    R.version = "2.1.2";
    R.eve = eve;
    var loaded,
        separator = /[, ]+/,
        elements = { circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1 },
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        Paper = function () {
            /*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
            \*/
            /*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             > Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute “hue” will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/
            this.ca = this.customAttributes = {};
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        lowerCase = Str.prototype.toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object.prototype.toString,
        paper = {},
        push = "push",
        ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = { "NaN": 1, "Infinity": 1, "-Infinity": 1 },
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        setAttribute = "setAttribute",
        toFloat = parseFloat,
        toInt = parseInt,
        upperCase = Str.prototype.toUpperCase,
        availableAttrs = R._availableAttrs = {
            "arrow-end": "none",
            "arrow-start": "none",
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "http://raphaeljs.com/",
            "letter-spacing": 0,
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: "",
            stroke: "#000",
            "stroke-dasharray": "",
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            target: "_blank",
            "text-anchor": "middle",
            title: "Raphael",
            transform: "",
            width: 0,
            x: 0,
            y: 0
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        hsrg = { hs: 1, rg: 1 },
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
        eldata = {},
        sortByKey = function (a, b) {
            return a.key - b.key;
        },
        sortByNumber = function (a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function () { },
        pipe = function (x) {
            return x;
        },
        rectPath = R._rectPath = function (x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },
        ellipsePath = function (x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },
        getPath = R._getPath = {
            path: function (el) {
                return el.attr("path");
            },
            circle: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function (el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            },
            set: function (el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },
        /*\
         * Raphael.mapPath
         [ method ]
         **
         * Transform the path string with given matrix.
         > Parameters
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/
        mapPath = R.mapPath = function (path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        };

    R._g = g;
    /*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be “SVG”, “VML” or empty, depending on browser support.
    \*/
    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
    if (R.type == "VML") {
        var d = g.doc.createElement("div"),
            b;
        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == "object")) {
            return (R.type = E);
        }
        d = null;
    }
    /*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
    \*/
    /*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
    \*/
    R.svg = !(R.vml = R.type == "VML");
    R._Paper = Paper;
    /*\
     * Raphael.fn
     [ property (object) ]
     **
     * You can add your own method to the canvas. For example if you want to draw a pie chart,
     * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
     * Raphaël instance is created, otherwise it will take no effect. Please note that the
     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
     * ensure any namespacing ensures proper context.
     > Usage
     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
     |     return this.path( ... );
     | };
     | // or create namespace
     | Raphael.fn.mystuff = {
     |     arrow: function () {…},
     |     star: function () {…},
     |     // etc…
     | };
     | var paper = Raphael(10, 10, 630, 480);
     | // then use it
     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
     | paper.mystuff.arrow();
     | paper.mystuff.star();
    \*/
    R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = 0;
    R._oid = 0;
    /*\
     * Raphael.is
     [ method ]
     **
     * Handfull replacement for `typeof` operator.
     > Parameters
     - o (…) any object or primitive
     - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
     = (boolean) is given value is of given type
    \*/
    R.is = function (o, type) {
        type = lowerCase.call(type);
        if (type == "finite") {
            return !isnan[has](+o);
        }
        if (type == "array") {
            return o instanceof Array;
        }
        return (type == "null" && o === null) ||
            (type == typeof o && o !== null) ||
            (type == "object" && o === Object(o)) ||
            (type == "array" && Array.isArray && Array.isArray(o)) ||
            objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };

    function clone(obj) {
        if (typeof obj == "function" || Object(obj) !== obj) {
            return obj;
        }
        var res = new obj.constructor;
        for (var key in obj) if (obj[has](key)) {
            res[key] = clone(obj[key]);
        }
        return res;
    }

    /*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     > Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
    \*/
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        } else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    /*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     > Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
    \*/
    R.rad = function (deg) {
        return deg % 360 * PI / 180;
    };
    /*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     > Parameters
     - deg (number) angle in radians
     = (number) angle in degrees.
    \*/
    R.deg = function (rad) {
        return rad * 180 / PI % 360;
    };
    /*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     > Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
    \*/
    R.snapTo = function (values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            var i = values.length;
            while (i--) if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };

    /*\
     * Raphael.createUUID
     [ method ]
     **
     * Returns RFC4122, version 4 ID
    \*/
    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
        return function () {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    })(/[xy]/g, function (c) {
        var r = math.random() * 16 | 0,
            v = c == "x" ? r : (r & 3 | 8);
        return v.toString(16);
    });

    /*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
     > Parameters
     - newwin (window) new window object
    \*/
    R.setWindow = function (newwin) {
        eve("raphael.setWindow", R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        if (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };
    var toHex = function (color) {
        if (R.vml) {
            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
            var trim = /^\s+|\s+$/g;
            var bod;
            try {
                var docum = new ActiveXObject("htmlfile");
                docum.write("<body>");
                docum.close();
                bod = docum.body;
            } catch (e) {
                bod = createPopup().document.body;
            }
            var range = bod.createTextRange();
            toHex = cacher(function (color) {
                try {
                    bod.style.color = Str(color).replace(trim, E);
                    var value = range.queryCommandValue("ForeColor");
                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                    return "#" + ("000000" + value.toString(16)).slice(-6);
                } catch (e) {
                    return "none";
                }
            });
        } else {
            var i = g.doc.createElement("i");
            i.title = "Rapha\xebl Colour Picker";
            i.style.display = "none";
            g.doc.body.appendChild(i);
            toHex = cacher(function (color) {
                i.style.color = color;
                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
            });
        }
        return toHex(color);
    },
        hsbtoString = function () {
            return "hsb(" + [this.h, this.s, this.b] + ")";
        },
        hsltoString = function () {
            return "hsl(" + [this.h, this.s, this.l] + ")";
        },
        rgbtoString = function () {
            return this.hex;
        },
        prepareRGB = function (r, g, b) {
            if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (g == null && R.is(r, string)) {
                var clr = R.getRGB(r);
                r = clr.r;
                g = clr.g;
                b = clr.b;
            }
            if (r > 1 || g > 1 || b > 1) {
                r /= 255;
                g /= 255;
                b /= 255;
            }

            return [r, g, b];
        },
        packageRGB = function (r, g, b, o) {
            r *= 255;
            g *= 255;
            b *= 255;
            var rgb = {
                r: r,
                g: g,
                b: b,
                hex: R.rgb(r, g, b),
                toString: rgbtoString
            };
            R.is(o, "finite") && (rgb.opacity = o);
            return rgb;
        };

    /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     > Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB & HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) `true` if string can’t be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
    \*/
    R.color = function (clr) {
        var rgb;
        if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = { hex: "none" };
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
    \*/
    R.hsb2rgb = function (h, s, v, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
    \*/
    R.hsl2rgb = function (h, s, l, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.rgb2hsb
     [ method ]
     **
     * Converts RGB values to HSB object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
    \*/
    R.rgb2hsb = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
            V == r ? (g - b) / C :
                V == g ? (b - r) / C + 2 :
                    (r - g) / C + 4
        );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return { h: H, s: S, b: V, toString: hsbtoString };
    };
    /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
    \*/
    R.rgb2hsl = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
            M == r ? (g - b) / C :
                M == g ? (b - r) / C + 2 :
                    (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
            L < .5 ? C / (2 * L) :
                C / (2 - 2 * L));
        return { h: H, s: S, l: L, toString: hsltoString };
    };
    R._path2string = function () {
        return this.join(",").replace(p2s, "$1");
    };
    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
            return array.push(array.splice(i, 1)[0]);
        }
    }
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array.prototype.slice.call(arguments, 0),
                args = arg.join("\u2400"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    var preload = R._preload = function (src, f) {
        var img = g.doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function () {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function () {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };

    function clrToString() {
        return this.hex;
    }

    /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     > Parameters
     - colour (string) colour string in one of formats:
     # <ul>
     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsl(•••, •••, •••) — same as hsb</li>
     #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>
     # </ul>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) true if string can’t be parsed
     o }
    \*/
    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString };
        }
        if (colour == "none") {
            return { r: -1, g: -1, b: -1, hex: "none", toString: clrToString };
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = { r: red, g: green, b: blue, toString: clrToString };
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString };
    }, R);
    /*\
     * Raphael.hsb
     [ method ]
     **
     * Converts HSB values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
    \*/
    R.hsb = cacher(function (h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });
    /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
    \*/
    R.hsl = cacher(function (h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });
    /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
    \*/
    R.rgb = cacher(function (r, g, b) {
        return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
    });
    /*\
     * Raphael.getColor
     [ method ]
     **
     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
     > Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
    \*/
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || { h: 0, s: 1, b: value || .75 },
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = { h: 0, s: 1, b: start.b });
        }
        return rgb.hex;
    };
    /*\
     * Raphael.getColor.reset
     [ method ]
     **
     * Resets spectrum position for @Raphael.getColor back to red.
    \*/
    R.getColor.reset = function () {
        delete this.start;
    };

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                { x: +crp[i - 2], y: +crp[i - 1] },
                { x: +crp[i], y: +crp[i + 1] },
                { x: +crp[i + 2], y: +crp[i + 3] },
                { x: +crp[i + 4], y: +crp[i + 5] }
            ];
            if (z) {
                if (!i) {
                    p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };
                } else if (iLen - 4 == i) {
                    p[3] = { x: +crp[0], y: +crp[1] };
                } else if (iLen - 2 == i) {
                    p[2] = { x: +crp[0], y: +crp[1] };
                    p[3] = { x: +crp[2], y: +crp[3] };
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = { x: +crp[i], y: +crp[i + 1] };
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6 * p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }

        return d;
    }
    /*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     > Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
    \*/
    R.parsePathString = function (pathString) {
        if (!pathString) {
            return null;
        }
        var pth = paths(pathString);
        if (pth.arr) {
            return pathClone(pth.arr);
        }

        var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 },
            data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function (a, b, c) {
                var params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "r") {
                    data.push([b][concat](params));
                } else while (params.length >= paramCounts[name]) {
                    data.push([b][concat](params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    /*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     > Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
    \*/
    R.parseTransformString = cacher(function (TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = { r: 3, s: 4, t: 2, m: 6 },
            data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
            data = pathClone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function (a, b, c) {
                var params = [],
                    name = lowerCase.call(b);
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function (ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        //        setTimeout(function () {
        //            for (var key in p) if (p[has](key) && key != ps) {
        //                p[key].sleep--;
        //                !p[key].sleep && delete p[key];
        //            }
        //        });
        return p[ps];
    };
    /*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: { x: mx, y: my },
            n: { x: nx, y: ny },
            start: { x: ax, y: ay },
            end: { x: cx, y: cy },
            alpha: alpha
        };
    };
    /*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
    \*/
    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    /*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     > Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
    \*/
    R.isPointInsideBBox = function (bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    /*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     > Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
    \*/
    R.isBBoxIntersect = function (bbox1, bbox2) {
        var i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y)
            || i(bbox2, bbox1.x2, bbox1.y)
            || i(bbox2, bbox1.x, bbox1.y2)
            || i(bbox2, bbox1.x2, bbox1.y2)
            || i(bbox1, bbox2.x, bbox2.y)
            || i(bbox1, bbox2.x2, bbox2.y)
            || i(bbox1, bbox2.x, bbox2.y2)
            || i(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
            Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return { x: px, y: py };
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);
        if (!R.isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = mmax(~~(l1 / 5), 1),
            n2 = mmax(~~(l2 / 5), 1),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({ x: p.x, y: p.y, t: i / n1 });
        }
        for (i = 0; i < n2 + 1; i++) {
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({ x: p.x, y: p.y, t: i / n2 });
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: mmin(t1, 1),
                                t2: mmin(t2, 1)
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.pathIntersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     > Parameters
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point
     o         y: (number) y coordinate of the point
     o         t1: (number) t value for segment of path1
     o         t2: (number) t value for segment of path2
     o         segment1: (number) order number for segment of path1
     o         segment2: (number) order number for segment of path2
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
    \*/
    R.pathIntersection = function (path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function (path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     > Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
    \*/
    R.isPointInsidePath = function (path, x, y) {
        var bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) &&
            interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    };
    R._removedFactory = function (methodname) {
        return function () {
            eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
        };
    };
    /*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     > Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
    \*/
    var pathDimensions = R.pathBBox = function (path) {
        var pth = paths(path);
        if (pth.bbox) {
            return clone(pth.bbox);
        }
        if (!path) {
            return { x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0 };
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin[apply](0, X),
            ymin = mmin[apply](0, Y),
            xmax = mmax[apply](0, X),
            ymax = mmax[apply](0, Y),
            width = xmax - xmin,
            height = ymax - ymin,
            bb = {
                x: xmin,
                y: ymin,
                x2: xmax,
                y2: ymax,
                width: width,
                height: height,
                cx: xmin + width / 2,
                cy: ymin + height / 2
            };
        pth.bbox = clone(bb);
        return bb;
    },
        pathClone = function (pathArray) {
            var res = clone(pathArray);
            res.toString = R._path2string;
            return res;
        },
        pathToRelative = R._pathToRelative = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = R._path2string;
            pth.rel = pathClone(res);
            return res;
        },
        pathToAbsolute = R._pathToAbsolute = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                return [["M", 0, 0]];
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y][concat](pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res[concat](catmullRom2bezier(dots, crz));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else if (pa[0] == "R") {
                    dots = [x, y][concat](pa.slice(1));
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    r = ["R"][concat](pa.slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
            res.toString = R._path2string;
            pth.abs = pathClone(res);
            return res;
        },
        l2c = function (x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function (x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
        },
        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    return { x: X, y: Y };
                });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res).join()[split](",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            return {
                min: { x: mmin[apply](0, x), y: mmin[apply](0, y) },
                max: { x: mmax[apply](0, x), y: mmax[apply](0, y) }
            };
        }),
        path2curve = R._path2curve = cacher(function (path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                processPath = function (path, d, pcom) {
                    var nx, ny;
                    if (!path) {
                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);
                    switch (path[0]) {
                        case "M":
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case "A":
                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                            break;
                        case "S":
                            if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                nx = d.x * 2 - d.bx;          // And reflect the previous
                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                            }
                            else {                            // or some else or nothing
                                nx = d.x;
                                ny = d.y;
                            }
                            path = ["C", nx, ny][concat](path.slice(1));
                            break;
                        case "T":
                            if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                d.qy = d.y * 2 - d.qy;        // to case "S".
                            }
                            else {                            // or something else or nothing
                                d.qx = d.x;
                                d.qy = d.y;
                            }
                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case "Q":
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case "L":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case "H":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                            break;
                        case "V":
                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case "Z":
                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }
                    return path;
                },
                fixArc = function (pp, i) {
                    if (pp[i].length > 7) {
                        pp[i].shift();
                        var pi = pp[i];
                        while (pi.length) {
                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                        }
                        pp.splice(i, 1);
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                fixM = function (path1, path2, a1, a2, i) {
                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                        path2.splice(i, 0, ["M", a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                };
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] = processPath(p[i], attrs);
                fixArc(p, i);
                p2 && (p2[i] = processPath(p2[i], attrs2));
                p2 && fixArc(p2, i);
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = R._parseDots = cacher(function (gradient) {
            var dots = [];
            for (var i = 0, ii = gradient.length; i < ii; i++) {
                var dot = {},
                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                dot.color = dot.color.hex;
                par[2] && (dot.offset = par[2] + "%");
                dots.push(dot);
            }
            for (i = 1, ii = dots.length - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                        end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        tear = R._tear = function (el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = R._tofront = function (el, paper) {
            if (paper.top === el) {
                return;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = R._toback = function (el, paper) {
            if (paper.bottom === el) {
                return;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = R._insertafter = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.top && (paper.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = R._insertbefore = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.bottom && (paper.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
        /*\
         * Raphael.toMatrix
         [ method ]
         **
         * Utility method
         **
         * Returns matrix of transformations applied to a given path
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (object) @Matrix
        \*/
        toMatrix = R.toMatrix = function (path, transform) {
            var bb = pathDimensions(path),
                el = {
                    _: {
                        transform: E
                    },
                    getBBox: function () {
                        return bb;
                    }
                };
            extractTransform(el, transform);
            return el.matrix;
        },
        /*\
         * Raphael.transformPath
         [ method ]
         **
         * Utility method
         **
         * Returns path transformed by a given transformation
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (string) path
        \*/
        transformPath = R.transformPath = function (path, transform) {
            return mapPath(path, toMatrix(path, transform));
        },
        extractTransform = R._extractTransform = function (el, tstr) {
            if (tstr == null) {
                return el._.transform;
            }
            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
            var tdata = R.parseTransformString(tstr),
                deg = 0,
                dx = 0,
                dy = 0,
                sx = 1,
                sy = 1,
                _ = el._,
                m = new Matrix;
            _.transform = tdata || [];
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                        tlen = t.length,
                        command = Str(t[0]).toLowerCase(),
                        absolute = t[0] != command,
                        inver = absolute ? m.invert() : 0,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || el.getBBox(1);
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            deg += t[1];
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                            deg += t[1];
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || el.getBBox(1);
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            sx *= t[1];
                            sy *= t[tlen - 1];
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                            sx *= t[1];
                            sy *= t[2];
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                    _.dirtyT = 1;
                    el.matrix = m;
                }
            }

            /*\
             * Element.matrix
             [ property (object) ]
             **
             * Keeps @Matrix object, which represents element transformation
            \*/
            el.matrix = m;

            _.sx = sx;
            _.sy = sy;
            _.deg = deg;
            _.dx = dx = m.e;
            _.dy = dy = m.f;

            if (sx == 1 && sy == 1 && !deg && _.bbox) {
                _.bbox.x += +dx;
                _.bbox.y += +dy;
            } else {
                _.dirtyT = 1;
            }
        },
        getEmpty = function (item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t": return [l, 0, 0];
                case "m": return [l, 1, 0, 0, 1, 0, 0];
                case "r": if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
                case "s": if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
            }
        },
        equaliseTransform = R._equaliseTransform = function (t1, t2) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = R.parseTransformString(t1) || [];
            t2 = R.parseTransformString(t2) || [];
            var maxlength = mmax(t1.length, t2.length),
                from = [],
                to = [],
                i = 0, j, jj,
                tt1, tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if ((tt1[0] != tt2[0]) ||
                    (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                    (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                ) {
                    return;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: from,
                to: to
            };
        };
    R._getContainer = function (x, y, w, h) {
        var container;
        container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
        if (container == null) {
            return;
        }
        if (container.tagName) {
            if (y == null) {
                return {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } else {
                return {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        return {
            container: 1,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };
    /*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.pathToRelative = pathToRelative;
    R._engine = {};
    /*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.path2curve = path2curve;
    /*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
    \*/
    R.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         > Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            var out = [[], [], []],
                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         > Parameters
         - x (number)
         - y (number)
        \*/
        matrixproto.translate = function (x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         > Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
        \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         > Parameters
         - a (number)
         - x (number)
         - y (number)
        \*/
        matrixproto.rotate = function (a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         > Parameters
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         > Parameters
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return R.svg ?
                "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
        };
        matrixproto.toFilter = function () {
            return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.c], [this.b, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            // rotation
            var sin = -row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                    (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                    (s.rotate ? "r" + [s.rotate, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);

    // WebKit rendering bug workaround method
    var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
    if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") ||
        (navigator.vendor == "Google Inc." && version && version[1] < 8)) {
        /*\
         * Paper.safari
         [ method ]
         **
         * There is an inconvenient rendering bug in Safari (WebKit):
         * sometimes the rendering should be forced.
         * This method should help with dealing with this bug.
        \*/
        paperproto.safari = function () {
            var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({ stroke: "none" });
            setTimeout(function () { rect.remove(); });
        };
    } else {
        paperproto.safari = fun;
    }

    var preventDefault = function () {
        this.returnValue = false;
    },
        preventTouch = function () {
            return this.originalEvent.preventDefault();
        },
        stopPropagation = function () {
            this.cancelBubble = true;
        },
        stopTouch = function () {
            return this.originalEvent.stopPropagation();
        },
        getEventPosition = function (e) {
            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

            return {
                x: e.clientX + scrollX,
                y: e.clientY + scrollY
            };
        },
        addEvent = (function () {
            if (g.doc.addEventListener) {
                return function (obj, type, fn, element) {
                    var f = function (e) {
                        var pos = getEventPosition(e);
                        return fn.call(element, e, pos.x, pos.y);
                    };
                    obj.addEventListener(type, f, false);

                    if (supportsTouch && touchMap[type]) {
                        var _f = function (e) {
                            var pos = getEventPosition(e),
                                olde = e;

                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                if (e.targetTouches[i].target == obj) {
                                    e = e.targetTouches[i];
                                    e.originalEvent = olde;
                                    e.preventDefault = preventTouch;
                                    e.stopPropagation = stopTouch;
                                    break;
                                }
                            }

                            return fn.call(element, e, pos.x, pos.y);
                        };
                        obj.addEventListener(touchMap[type], _f, false);
                    }

                    return function () {
                        obj.removeEventListener(type, f, false);

                        if (supportsTouch && touchMap[type])
                            obj.removeEventListener(touchMap[type], f, false);

                        return true;
                    };
                };
            } else if (g.doc.attachEvent) {
                return function (obj, type, fn, element) {
                    var f = function (e) {
                        e = e || g.win.event;
                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                            x = e.clientX + scrollX,
                            y = e.clientY + scrollY;
                        e.preventDefault = e.preventDefault || preventDefault;
                        e.stopPropagation = e.stopPropagation || stopPropagation;
                        return fn.call(element, e, x, y);
                    };
                    obj.attachEvent("on" + type, f);
                    var detacher = function () {
                        obj.detachEvent("on" + type, f);
                        return true;
                    };
                    return detacher;
                };
            }
        })(),
        drag = [],
        dragMove = function (e) {
            var x = e.clientX,
                y = e.clientY,
                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                dragi,
                j = drag.length;
            while (j--) {
                dragi = drag[j];
                if (supportsTouch && e.touches) {
                    var i = e.touches.length,
                        touch;
                    while (i--) {
                        touch = e.touches[i];
                        if (touch.identifier == dragi.el._drag.id) {
                            x = touch.clientX;
                            y = touch.clientY;
                            (e.originalEvent ? e.originalEvent : e).preventDefault();
                            break;
                        }
                    }
                } else {
                    e.preventDefault();
                }
                var node = dragi.el.node,
                    o,
                    next = node.nextSibling,
                    parent = node.parentNode,
                    display = node.style.display;
                g.win.opera && parent.removeChild(node);
                node.style.display = "none";
                o = dragi.el.paper.getElementByPoint(x, y);
                node.style.display = display;
                g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
                x += scrollX;
                y += scrollY;
                eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
            }
        },
        dragUp = function (e) {
            R.unmousemove(dragMove).unmouseup(dragUp);
            var i = drag.length,
                dragi;
            while (i--) {
                dragi = drag[i];
                dragi.el._drag = {};
                eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
            }
            drag = [];
        },
        /*\
         * Raphael.el
         [ property (object) ]
         **
         * You can add your own method to elements. This is usefull when you want to hack default functionality or
         * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
         * you can redefine element method at any time. Expending element methods wouldn’t affect set.
         > Usage
         | Raphael.el.red = function () {
         |     this.attr({fill: "#f00"});
         | };
         | // then use it
         | paper.circle(100, 100, 20).red();
        \*/
        elproto = R.el = {};
    /*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            R[eventName] = elproto[eventName] = function (fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({ name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this) });
                }
                return this;
            };
            R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--) {
                    if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                        events[l].unbind();
                        events.splice(l, 1);
                        !events.length && delete this.events;
                    }
                }
                return this;
            };
        })(events[i]);
    }

    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value asociated with given key.
     **
     * See also @Element.removeData
     > Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     * or, if key and value are not specified:
     = (object) Key/value pairs for all the data associated with the element.
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0) {
            return data;
        }
        if (arguments.length == 1) {
            if (R.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("raphael.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("raphael.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     > Parameters
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    /*\
    * Element.getData
    [ method ]
    **
    * Retrieves the element data
    = (object) data
   \*/
    elproto.getData = function () {
        return clone(eldata[this.id] || {});
    };
    /*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     > Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
     * `drag.over.<id>` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            if (e.button !== 0) return;
            (e.originalEvent || e).preventDefault();
            var x = e.clientX,
                y = e.clientY,
                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.id = e.identifier;
            if (supportsTouch && e.touches) {
                var i = e.touches.length, touch;
                while (i--) {
                    touch = e.touches[i];
                    this._drag.id = touch.identifier;
                    if (touch.identifier == this._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        break;
                    }
                }
            }
            this._drag.x = x + scrollX;
            this._drag.y = y + scrollY;
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({ el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope });
            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this._drag = {};
        draggable.push({ el: this, start: start });
        this.mousedown(start);
        return this;
    };
    /*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
     > Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    elproto.onDragOver = function (f) {
        f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
    };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
    \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            eve.unbind("raphael.drag.*." + this.id);
        }
        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        //drag = [];
    };

    paperproto.element = function (node) {
        let out = R._engine.element(node, this)
        this.__set__ && this.__set__.push(out);
        return out
    }

    paperproto.circleElement = function (node, cx, cy, r) {
        let out = R._engine.circleElement(node, cx, cy, r, this)
        this.__set__ && this.__set__.push(out);
        return out
    }

    paperproto.imageElement = function (node, src, x, y, w, h) {
        let out = R._engine.imageElement(node, src, x, y, w, h, this);
        this.__set__ && this.__set__.push(out);
        return out;
    }

    paperproto.textElement = function (node, x, y, text) {
        let out = R._engine.textElement(node, x, y, text, this);
        this.__set__ && this.__set__.push(out);
        return out;
    }

    paperproto.rectElement = function (node, x, y, width, height, cornerRadius) {
        let out = R._engine.rectElement(node, x, y, width, height, cornerRadius, this);
        this.__set__ && this.__set__.push(out);
        return out;
    }

    paperproto.pathElement = function (node, path) {
        let out = R._engine.pathElement(node, path, this);
        this.__set__ && this.__set__.push(out);
        return out;
    }

    paperproto.ellipseElement = function (node, x, y, radius1, radius2) {
        let out = R._engine.ellipseElement(node, x, y, radius1, radius2, this);
        this.__set__ && this.__set__.push(out);
        return out;
    }

    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Raphaël element object with type “circle”
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    paperproto.circle = function (x, y, r) {
        var out = R._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     > Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Raphaël element object with type “rect”
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    paperproto.rect = function (x, y, w, h, r) {
        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Raphaël element object with type “ellipse”
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    paperproto.ellipse = function (x, y, rx, ry) {
        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     > Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
    \*/
    paperproto.path = function (pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        var out = R._engine.path(R.format[apply](R, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     > Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Raphaël element object with type “image”
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    paperproto.image = function (src, x, y, w, h) {
        var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put “\n” in the string.
     **
     > Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Raphaël element object with type “text”
     **
     > Usage
     | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
    \*/
    paperproto.text = function (x, y, text) {
        var out = R._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements — all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     > Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.set = function (itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        var out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        out["paper"] = this;
        out["type"] = "set";
        return out;
    };
    /*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     > Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.setStart = function (set) {
        this.__set__ = set || this.set();
    };
    /*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
    \*/
    paperproto.setFinish = function (set) {
        var out = this.__set__;
        delete this.__set__;
        return out;
    };
    /*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     > Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
    \*/
    paperproto.setSize = function (width, height) {
        return R._engine.setSize.call(this, width, height);
    };
    /*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
     * specifying new boundaries.
     **
     > Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
    \*/
    paperproto.setViewBox = function (x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    /*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
    \*/
    /*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
    \*/
    paperproto.top = paperproto.bottom = null;
    /*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
    \*/
    paperproto.raphael = R;
    var getOffset = function (elem) {
        var box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Raphaël element object
     > Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
    \*/
    paperproto.getElementByPoint = function (x, y) {
        var paper = this,
            svg = paper.canvas,
            target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == "svg") {
            var so = getOffset(svg),
                sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            var hits = svg.getIntersectionList(sr, null);
            if (hits.length) {
                target = hits[hits.length - 1];
            }
        }
        if (!target) {
            return null;
        }
        while (target.parentNode && target != svg.parentNode && !target.raphael) {
            target = target.parentNode;
        }
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };

    /*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     > Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/
    paperproto.getElementsByBBox = function (bbox) {
        var set = this.set();
        this.forEach(function (el) {
            if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                set.push(el);
            }
        });
        return set;
    };

    /*\
     * Paper.getById
     [ method ]
     **
     * Returns you element by its internal ID.
     **
     > Parameters
     **
     - id (number) id
     = (object) Raphaël element object
    \*/
    paperproto.getById = function (id) {
        var bot = this.bottom;
        while (bot) {
            if (bot.id == id) {
                return bot;
            }
            bot = bot.next;
        }
        return null;
    };
    /*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     > Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
    \*/
    paperproto.forEach = function (callback, thisArg) {
        var bot = this.bottom;
        while (bot) {
            if (callback.call(thisArg, bot) === false) {
                return this;
            }
            bot = bot.next;
        }
        return this;
    };
    /*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
    \*/
    paperproto.getElementsByPoint = function (x, y) {
        var set = this.set();
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }
    /*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this element’s shape
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
    \*/
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
    /*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     > Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
    \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.removed) {
            return {};
        }
        var _ = this._;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    /*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
    \*/
    elproto.clone = function () {
        if (this.removed) {
            return null;
        }
        var out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
     **
     > Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
    \*/
    elproto.glow = function (glow) {
        if (this.type == "text") {
            return null;
        }
        glow = glow || {};
        var s = {
            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
            fill: glow.fill || false,
            opacity: glow.opacity || .5,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || "#000"
        },
            c = s.width / 2,
            r = this.paper,
            out = r.set(),
            path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for (var i = 1; i < c + 1; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : "none",
                "stroke-linejoin": "round",
                "stroke-linecap": "round",
                "stroke-width": +(s.width / c * i).toFixed(3),
                opacity: +(s.opacity / c).toFixed(3)
            }));
        }
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    var curveslengths = {},
        getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
            if (length == null) {
                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            } else {
                return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
            }
        },
        getLengthFactory = function (istotal, subpath) {
            return function (path, length, onlystart) {
                path = path2curve(path);
                var x, y, p, l, sp = "", subpaths = {}, point,
                    len = 0;
                for (var i = 0, ii = path.length; i < ii; i++) {
                    p = path[i];
                    if (p[0] == "M") {
                        x = +p[1];
                        y = +p[2];
                    } else {
                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                        if (len + l > length) {
                            if (subpath && !subpaths.start) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                                if (onlystart) { return sp; }
                                subpaths.start = sp;
                                sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                                len += l;
                                x = +p[5];
                                y = +p[6];
                                continue;
                            }
                            if (!istotal && !subpath) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                return { x: point.x, y: point.y, alpha: point.alpha };
                            }
                        }
                        len += l;
                        x = +p[5];
                        y = +p[6];
                    }
                    sp += p.shift() + p;
                }
                subpaths.end = sp;
                point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                point.alpha && (point = { x: point.x, y: point.y, alpha: point.alpha });
                return point;
            };
        };
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    /*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     > Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
    \*/
    R.getTotalLength = getTotalLength;
    /*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     > Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
    R.getPointAtLength = getPointAtLength;
    /*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     > Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
    R.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns length of the path in pixels. Only works for element of “path” type.
     = (number) length.
    \*/
    elproto.getTotalLength = function () {
        var path = this.getPath();
        if (!path) {
            return;
        }

        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }

        return getTotalLength(path);
    };
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.
     **
     > Parameters
     **
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function (length) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return getPointAtLength(path, length);
    };
    /*\
     * Element.getPath
     [ method ]
     **
     * Returns path of the element. Only works for elements of “path” type and simple elements like circle.
     = (object) path
     **
    \*/
    elproto.getPath = function () {
        var path,
            getPath = R._getPath[this.type];

        if (this.type == "text" || this.type == "set") {
            return;
        }

        if (getPath) {
            path = getPath(this);
        }

        return path;
    };
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Return subpath of a given element from given length to given length. Only works for element of “path” type.
     **
     > Parameters
     **
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
    elproto.getSubpath = function (from, to) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return R.getSubpath(path, from, to);
    };
    /*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # <ul>
     #     <li>“linear”</li>
     #     <li>“&lt;” or “easeIn” or “ease-in”</li>
     #     <li>“>” or “easeOut” or “ease-out”</li>
     #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>
     #     <li>“backIn” or “back-in”</li>
     #     <li>“backOut” or “back-out”</li>
     #     <li>“elastic”</li>
     #     <li>“bounce”</li>
     # </ul>
     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
    \*/
    var ef = R.easing_formulas = {
        linear: function (n) {
            return n;
        },
        "<": function (n) {
            return pow(n, 1.7);
        },
        ">": function (n) {
            return pow(n, .48);
        },
        "<>": function (n) {
            var q = .48 - n / 1.04,
                Q = math.sqrt(.1734 + q * q),
                x = Q - q,
                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn: function (n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function (n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function (n) {
            if (n == !!n) {
                return n;
            }
            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
        },
        bounce: function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;

    var animationElements = [],
        requestAnimFrame = window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (callback) {
                setTimeout(callback, 16);
            },
        animation = function () {
            var Now = +new Date,
                l = 0;
            for (; l < animationElements.length; l++) {
                var e = animationElements[l];
                if (e.el.removed || e.paused) {
                    continue;
                }
                var time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now,
                    init = {},
                    key;
                if (e.initstatus) {
                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                    e.status = e.initstatus;
                    delete e.initstatus;
                    e.stop && animationElements.splice(l--, 1);
                } else {
                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                }
                if (time < 0) {
                    continue;
                }
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from) if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ].join(",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                break;
                            case "transform":
                                if (diff[attr].real) {
                                    now = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } else {
                                    var get = function (i) {
                                        return +from[attr][i] + pos * ms * diff[attr][i];
                                    };
                                    // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                    now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                }
                                break;
                            case "csv":
                                if (attr == "clip-rect") {
                                    now = [];
                                    i = 4;
                                    while (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                break;
                            default:
                                var from2 = [][concat](from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    (function (id, that, anim) {
                        setTimeout(function () {
                            eve("raphael.anim.frame." + id, that, anim);
                        });
                    })(that.id, that, e.anim);
                } else {
                    (function (f, el, a) {
                        setTimeout(function () {
                            eve("raphael.anim.frame." + el.id, el, a);
                            eve("raphael.anim.finish." + el.id, el, a);
                            R.is(f, "function") && f.call(el);
                        });
                    })(e.callback, that, e.anim);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                    if (e.repeat > 1 && !e.next) {
                        for (key in to) if (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                        e.el.attr(init);
                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                    }
                    if (e.next && !e.stop) {
                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                    }
                }
            }
            R.svg && that && that.paper && that.paper.safari();
            animationElements.length && requestAnimFrame(animation);
        },
        upto255 = function (color) {
            return color > 255 ? 255 : color < 0 ? 0 : color;
        };
    /*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     > Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animateWith = function (el, anim, params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
            x, y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].anim == anim && animationElements[i].el == el) {
                animationElements[ii - 1].start = animationElements[i].start;
                break;
            }
        }
        return element;
        //
        //
        // var a = params ? R.animation(params, ms, easing, callback) : anim,
        //     status = element.status(anim);
        // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for (t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function (f) {
        f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
        return this;
    };
    function Animation(anim, ms) {
        var percents = [],
            newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for (var attr in anim) if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    /*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     > Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
    \*/
    Animation.prototype.delay = function (delay) {
        var a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    /*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     > Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
    \*/
    Animation.prototype.repeat = function (times) {
        var a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        var params,
            isInAnim,
            isInAnimSet,
            percents = [],
            next,
            prev,
            timestamp,
            ms = anim.ms,
            from = {},
            to = {},
            diff = {};
        if (status) {
            for (i = 0, ii = animationElements.length; i < ii; i++) {
                var e = animationElements[i];
                if (e.el.id == element.id && e.anim == anim) {
                    if (e.percent != percent) {
                        animationElements.splice(i, 1);
                        isInAnimSet = 1;
                    } else {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    break;
                }
            }
        } else {
            status = +to; // NaN
        }
        for (var i = 0, ii = anim.percents.length; i < ii; i++) {
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        if (!params) {
            return;
        }
        if (!isInAnim) {
            for (var attr in params) if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch (availableAnimAttrs[attr]) {
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case "colour":
                            from[attr] = R.getRGB(from[attr]);
                            var toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case "path":
                            var pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                diff[attr][i] = [0];
                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                }
                            }
                            break;
                        case "transform":
                            var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [from[attr][i][0]];
                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                            } else {
                                var m = (element.matrix || new Matrix),
                                    to2 = {
                                        _: { transform: _.transform },
                                        getBBox: function () {
                                            return element.getBBox(1);
                                        }
                                    };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                            }
                            break;
                        case "csv":
                            var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                            if (attr == "clip-rect") {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while (i--) {
                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            }
                            break;
                    }
                }
            }
            var easing = params.easing,
                easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    var curve = easyeasy;
                    easyeasy = function (t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +new Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date - ms * status;
                if (animationElements.length == 1) {
                    return animation();
                }
            }
            if (isInAnimSet) {
                e.start = new Date - e.ms * status;
            }
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date - isInAnim.ms * status;
        }
        eve("raphael.anim.start." + element.id, element, anim);
    }
    /*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
    \*/
    R.animation = function (params, ms, easing, callback) {
        if (params instanceof Animation) {
            return params;
        }
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        var p = {},
            json,
            attr;
        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            return new Animation(params, ms);
        } else {
            easing && (p.easing = easing);
            callback && (p.callback = callback);
            return new Animation({ 100: p }, ms);
        }
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animate = function (params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    /*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     > Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
    \*/
    elproto.setTime = function (anim, value) {
        if (anim && value != null) {
            this.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        return this;
    };
    /*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
    \*/
    elproto.status = function (anim, value) {
        var out = [],
            i = 0,
            len,
            e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        } else {
            len = animationElements.length;
            for (; i < len; i++) {
                e = animationElements[i];
                if (e.el.id == this.id && (!anim || e.anim == anim)) {
                    if (anim) {
                        return e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            if (anim) {
                return 0;
            }
            return out;
        }
    };
    /*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.pause = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                animationElements[i].paused = true;
            }
        }
        return this;
    };
    /*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.resume = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            var e = animationElements[i];
            if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.stop = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                animationElements.splice(i--, 1);
            }
        }
        return this;
    };
    function stopAnimation(paper) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
            animationElements.splice(i--, 1);
        }
    }
    eve.on("raphael.remove", stopAnimation);
    eve.on("raphael.clear", stopAnimation);
    elproto.toString = function () {
        return "Rapha\xebl\u2019s object";
    };

    // Set
    var Set = function (items) {
        throw "Please use SvgElementSet instead" // mercator
        this.items = [];
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
        setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set.
     = (object) original element
    \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it.
     = (object) element
    \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set.
     *
     * If function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    for (var method in elproto) if (elproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname][apply](el, arg);
                });
            };
        })(method);
    }
    setproto.attr = function (name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) {
            for (var j = 0, jj = name.length; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removeds all elements from the set
    \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - element (object) element to remove
     = (boolean) `true` if object was found & removed from the set
    \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function (params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items.length,
            i = len,
            item,
            set = this,
            collector;
        if (!len) {
            return this;
        }
        callback && (collector = function () {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        var anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            (this.items[i] && !this.items[i].removed) || len--;
        }
        return this;
    };
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function (s) {
        s = this.paper.set();
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Rapha\xebl\u2018s set";
    };

    setproto.glow = function (glowConfig) {
        var ret = this.paper.set();
        this.forEach(function (shape, index) {
            var g = shape.glow(glowConfig);
            if (g != null) {
                g.forEach(function (shape2, index2) {
                    ret.push(shape2);
                });
            }
        });
        return ret;
    };


    /*\
     * Set.isPointInside
     [ method ]
     **
     * Determine if given point is inside this set’s elements
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point is inside any of the set's elements
     \*/
    setproto.isPointInside = function (x, y) {
        var isPointInside = false;
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                console.log('runned');
                isPointInside = true;
                return false; // stop loop
            }
        });
        return isPointInside;
    };

    /*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
     * Returns original parameter, so it could be used with chaining.
     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
     **
     > Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     > Usage
     | Cufon.registerFont(Raphael.registerFont({…}));
    \*/
    R.registerFont = function (font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
            w: font.w,
            face: {},
            glyphs: {}
        },
            family = font.face["font-family"];
        for (var prop in font.face) if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        if (this.fonts[family]) {
            this.fonts[family].push(fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                        return { l: "L", c: "C", x: "z", t: "m", r: "l", v: "c" }[command] || "M";
                    }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) if (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        return font;
    };
    /*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
     **
     > Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     > Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
    \*/
    paperproto.getFont = function (family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || { normal: 400, bold: 700, lighter: 300, bolder: 800 }[weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font.length; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };
    /*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     > Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     - line_spacing (number) #optional number in range `1..3`, default is `1`
     = (object) resulting path element, which consist of all letters
     > Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
    \*/
    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
        var letters = Str(string)[split](E),
            shift = 0,
            notfirst = 0,
            path = E,
            scale;
        R.is(font, "string") && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox[split](separator),
                top = +bb[0],
                lineHeight = bb[3] - bb[1],
                shifty = 0,
                height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
            for (var i = 0, ii = letters.length; i < ii; i++) {
                if (letters[i] == "\n") {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight * line_spacing;
                } else {
                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                        curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) {
                    path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                }
            }
        }
        return this.path(path).attr({
            fill: "#000",
            stroke: "none"
        });
    };

    /*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, <attributes>}`
     **
     > Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     > Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
    \*/
    paperproto.add = function (json) {
        if (R.is(json, "array")) {
            var res = this.set(),
                i = 0,
                ii = json.length,
                j;
            for (; i < ii; i++) {
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };

    /*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - … (string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     > Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
    \*/
    R.format = function (token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };
    /*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     > Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
    \*/
    R.fullfill = (function () {
        var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function (all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
        return function (str, obj) {
            return String(str).replace(tokenRegex, function (all, key) {
                return replacer(all, key, obj);
            });
        };
    })();
    /*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existance.
     **
     = (object) Raphael object
     > Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     …
     | })(Raphael.ninja());
    \*/
    R.ninja = function () {
        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
        return R;
    };
    /*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
    \*/
    R.st = setproto;
    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
    (function (doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener) {
            doc.addEventListener(loaded, f = function () {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");

    eve.on("raphael.DOMload", function () {
        loaded = true;
    });

    // ┌─────────────────────────────────────────────────────────────────────┐ \\
    // │ Raphaël - JavaScript Vector Library                                 │ \\
    // ├─────────────────────────────────────────────────────────────────────┤ \\
    // │ SVG Module                                                          │ \\
    // ├─────────────────────────────────────────────────────────────────────┤ \\
    // │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
    // │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
    // │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
    // └─────────────────────────────────────────────────────────────────────┘ \\

    (function () {
        if (!R.svg) {
            return;
        }
        var has = "hasOwnProperty",
            Str = String,
            toFloat = parseFloat,
            toInt = parseInt,
            math = Math,
            mmax = math.max,
            abs = math.abs,
            pow = math.pow,
            separator = /[, ]+/,
            eve = R.eve,
            E = "",
            S = " ";
        var xlink = "http://www.w3.org/1999/xlink",
            markers = {
                block: "M5,0 0,2.5 5,5z",
                classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
                diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
                open: "M6,1 1,3.5 6,6",
                oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
            },
            markerCounter = {};
        R.toString = function () {
            return "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
        };
        var $ = function (el, attr) {
            if (attr) {
                if (typeof el == "string") {
                    el = $(el);
                }
                for (var key in attr) if (attr[has](key)) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                    } else {
                        el.setAttribute(key, Str(attr[key]));
                    }
                }
            } else {
                el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
                el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
            }
            return el;
        },
            addGradientFill = function (element, gradient) {
                var type = "linear",
                    id = element.id + gradient,
                    fx = .5, fy = .5,
                    o = element.node,
                    SVG = element.paper,
                    s = o.style,
                    el = R._g.doc.getElementById(id);
                if (!el) {
                    gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                        type = "radial";
                        if (_fx && _fy) {
                            fx = toFloat(_fx);
                            fy = toFloat(_fy);
                            var dir = ((fy > .5) * 2 - 1);
                            pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                                (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                                fy != .5 &&
                                (fy = fy.toFixed(5) - 1e-5 * dir);
                        }
                        return E;
                    });
                    gradient = gradient.split(/\s*\-\s*/);
                    if (type == "linear") {
                        var angle = gradient.shift();
                        angle = -toFloat(angle);
                        if (isNaN(angle)) {
                            return null;
                        }
                        var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                            max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                        vector[2] *= max;
                        vector[3] *= max;
                        if (vector[2] < 0) {
                            vector[0] = -vector[2];
                            vector[2] = 0;
                        }
                        if (vector[3] < 0) {
                            vector[1] = -vector[3];
                            vector[3] = 0;
                        }
                    }
                    var dots = R._parseDots(gradient);
                    if (!dots) {
                        return null;
                    }
                    id = id.replace(/[\(\)\s,\xb0#]/g, "_");

                    if (element.gradient && id != element.gradient.id) {
                        SVG.defs.removeChild(element.gradient);
                        delete element.gradient;
                    }

                    if (!element.gradient) {
                        el = $(type + "Gradient", { id: id });
                        element.gradient = el;
                        $(el, type == "radial" ? {
                            fx: fx,
                            fy: fy
                        } : {
                            x1: vector[0],
                            y1: vector[1],
                            x2: vector[2],
                            y2: vector[3],
                            gradientTransform: element.matrix.invert()
                        });
                        SVG.defs.appendChild(el);
                        for (var i = 0, ii = dots.length; i < ii; i++) {
                            el.appendChild($("stop", {
                                offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                                "stop-color": dots[i].color || "#fff"
                            }));
                        }
                    }
                }
                $(o, {
                    fill: "url(#" + id + ")",
                    opacity: 1,
                    "fill-opacity": 1
                });
                s.fill = E;
                s.opacity = 1;
                s.fillOpacity = 1;
                return 1;
            },
            updatePosition = function (o) {
                var bbox = o.getBBox(1);
                $(o.pattern, { patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")" });
            },
            addArrow = function (o, value, isEnd) {
                if (o.type == "path") {
                    var values = Str(value).toLowerCase().split("-"),
                        p = o.paper,
                        se = isEnd ? "end" : "start",
                        node = o.node,
                        attrs = o.attrs,
                        stroke = attrs["stroke-width"],
                        i = values.length,
                        type = "classic",
                        from,
                        to,
                        dx,
                        refX,
                        attr,
                        w = 3,
                        h = 3,
                        t = 5;
                    while (i--) {
                        switch (values[i]) {
                            case "block":
                            case "classic":
                            case "oval":
                            case "diamond":
                            case "open":
                            case "none":
                                type = values[i];
                                break;
                            case "wide": h = 5; break;
                            case "narrow": h = 2; break;
                            case "long": w = 5; break;
                            case "short": w = 2; break;
                        }
                    }
                    if (type == "open") {
                        w += 2;
                        h += 2;
                        t += 2;
                        dx = 1;
                        refX = isEnd ? 4 : 1;
                        attr = {
                            fill: "none",
                            stroke: attrs.stroke
                        };
                    } else {
                        refX = dx = w / 2;
                        attr = {
                            fill: attrs.stroke,
                            stroke: "none"
                        };
                    }
                    if (o._.arrows) {
                        if (isEnd) {
                            o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                            o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                        } else {
                            o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                            o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                        }
                    } else {
                        o._.arrows = {};
                    }
                    if (type != "none") {
                        var pathId = "raphael-marker-" + type,
                            markerId = "raphael-marker-" + se + type + w + h;
                        if (!R._g.doc.getElementById(pathId)) {
                            p.defs.appendChild($($("path"), {
                                "stroke-linecap": "round",
                                d: markers[type],
                                id: pathId
                            }));
                            markerCounter[pathId] = 1;
                        } else {
                            markerCounter[pathId]++;
                        }
                        var marker = R._g.doc.getElementById(markerId),
                            use;
                        if (!marker) {
                            marker = $($("marker"), {
                                id: markerId,
                                markerHeight: h,
                                markerWidth: w,
                                orient: "auto",
                                refX: refX,
                                refY: h / 2
                            });
                            use = $($("use"), {
                                "xlink:href": "#" + pathId,
                                transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                                "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                            });
                            marker.appendChild(use);
                            p.defs.appendChild(marker);
                            markerCounter[markerId] = 1;
                        } else {
                            markerCounter[markerId]++;
                            use = marker.getElementsByTagName("use")[0];
                        }
                        $(use, attr);
                        var delta = dx * (type != "diamond" && type != "oval");
                        if (isEnd) {
                            from = o._.arrows.startdx * stroke || 0;
                            to = R.getTotalLength(attrs.path) - delta * stroke;
                        } else {
                            from = delta * stroke;
                            to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                        }
                        attr = {};
                        attr["marker-" + se] = "url(#" + markerId + ")";
                        if (to || from) {
                            attr.d = R.getSubpath(attrs.path, from, to);
                        }
                        $(node, attr);
                        o._.arrows[se + "Path"] = pathId;
                        o._.arrows[se + "Marker"] = markerId;
                        o._.arrows[se + "dx"] = delta;
                        o._.arrows[se + "Type"] = type;
                        o._.arrows[se + "String"] = value;
                    } else {
                        if (isEnd) {
                            from = o._.arrows.startdx * stroke || 0;
                            to = R.getTotalLength(attrs.path) - from;
                        } else {
                            from = 0;
                            to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                        }
                        o._.arrows[se + "Path"] && $(node, { d: R.getSubpath(attrs.path, from, to) });
                        delete o._.arrows[se + "Path"];
                        delete o._.arrows[se + "Marker"];
                        delete o._.arrows[se + "dx"];
                        delete o._.arrows[se + "Type"];
                        delete o._.arrows[se + "String"];
                    }
                    for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                        var item = R._g.doc.getElementById(attr);
                        item && item.parentNode.removeChild(item);
                    }
                }
            },
            dasharray = {
                "": [0],
                "none": [0],
                "-": [3, 1],
                ".": [1, 1],
                "-.": [3, 1, 1, 1],
                "-..": [3, 1, 1, 1, 1, 1],
                ". ": [1, 3],
                "- ": [4, 3],
                "--": [8, 3],
                "- .": [4, 3, 1, 3],
                "--.": [8, 3, 1, 3],
                "--..": [8, 3, 1, 3, 1, 3]
            },
            addDashes = function (o, value, params) {
                value = dasharray[Str(value).toLowerCase()];
                if (value) {
                    var width = o.attrs["stroke-width"] || "1",
                        butt = { round: width, square: width, butt: 0 }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                        dashes = [],
                        i = value.length;
                    while (i--) {
                        dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                    }
                    $(o.node, { "stroke-dasharray": dashes.join(",") });
                }
            },
            setFillAndStroke = function (o, params) {
                var node = o.node,
                    attrs = o.attrs,
                    vis = node.style.visibility;
                node.style.visibility = "hidden";
                for (var att in params) {
                    if (params[has](att)) {
                        if (!R._availableAttrs[has](att)) {
                            continue;
                        }
                        var value = params[att];
                        attrs[att] = value;
                        switch (att) {
                            case "blur":
                                o.blur(value);
                                break;
                            case "href":
                            case "title":
                                var hl = $("title");
                                var val = R._g.doc.createTextNode(value);
                                hl.appendChild(val);
                                node.appendChild(hl);
                                break;
                            case "target":
                                var pn = node.parentNode;
                                if (pn.tagName.toLowerCase() != "a") {
                                    var hl = $("a");
                                    pn.insertBefore(hl, node);
                                    hl.appendChild(node);
                                    pn = hl;
                                }
                                if (att == "target") {
                                    pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                                } else {
                                    pn.setAttributeNS(xlink, att, value);
                                }
                                break;
                            case "cursor":
                                node.style.cursor = value;
                                break;
                            case "transform":
                                o.transform(value);
                                break;
                            case "arrow-start":
                                addArrow(o, value);
                                break;
                            case "arrow-end":
                                addArrow(o, value, 1);
                                break;
                            case "clip-rect":
                                var rect = Str(value).split(separator);
                                if (rect.length == 4) {
                                    o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                    var el = $("clipPath"),
                                        rc = $("rect");
                                    el.id = R.createUUID();
                                    $(rc, {
                                        x: rect[0],
                                        y: rect[1],
                                        width: rect[2],
                                        height: rect[3]
                                    });
                                    el.appendChild(rc);
                                    o.paper.defs.appendChild(el);
                                    $(node, { "clip-path": "url(#" + el.id + ")" });
                                    o.clip = rc;
                                }
                                if (!value) {
                                    var path = node.getAttribute("clip-path");
                                    if (path) {
                                        var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                        clip && clip.parentNode.removeChild(clip);
                                        $(node, { "clip-path": E });
                                        delete o.clip;
                                    }
                                }
                                break;
                            case "path":
                                if (o.type == "path") {
                                    $(node, { d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0" });
                                    o._.dirty = 1;
                                    if (o._.arrows) {
                                        "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                        "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                    }
                                }
                                break;
                            case "width":
                                node.setAttribute(att, value);
                                o._.dirty = 1;
                                if (attrs.fx) {
                                    att = "x";
                                    value = attrs.x;
                                } else {
                                    break;
                                }
                            case "x":
                                if (attrs.fx) {
                                    value = -attrs.x - (attrs.width || 0);
                                }
                            case "rx":
                                if (att == "rx" && o.type == "rect") {
                                    break;
                                }
                            case "cx":
                                node.setAttribute(att, value);
                                o.pattern && updatePosition(o);
                                o._.dirty = 1;
                                break;
                            case "height":
                                node.setAttribute(att, value);
                                o._.dirty = 1;
                                if (attrs.fy) {
                                    att = "y";
                                    value = attrs.y;
                                } else {
                                    break;
                                }
                            case "y":
                                if (attrs.fy) {
                                    value = -attrs.y - (attrs.height || 0);
                                }
                            case "ry":
                                if (att == "ry" && o.type == "rect") {
                                    break;
                                }
                            case "cy":
                                node.setAttribute(att, value);
                                o.pattern && updatePosition(o);
                                o._.dirty = 1;
                                break;
                            case "r":
                                if (o.type == "rect") {
                                    $(node, { rx: value, ry: value });
                                } else {
                                    node.setAttribute(att, value);
                                }
                                o._.dirty = 1;
                                break;
                            case "src":
                                if (o.type == "image") {
                                    node.setAttributeNS(xlink, "href", value);
                                }
                                break;
                            case "stroke-width":
                                // seats.io: stroke-width zooming bug fix
                                //if (o._.sx != 1 || o._.sy != 1) {
                                //    value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                                //}
                                //if (o.paper._vbSize) {
                                //    value *= o.paper._vbSize;
                                //}
                                node.setAttribute(att, value);
                                if (attrs["stroke-dasharray"]) {
                                    addDashes(o, attrs["stroke-dasharray"], params);
                                }
                                if (o._.arrows) {
                                    "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                    "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                }
                                break;
                            case "stroke-dasharray":
                                addDashes(o, value, params);
                                break;
                            case "fill":
                                var isURL = Str(value).match(R._ISURL);
                                if (isURL) {
                                    el = $("pattern");
                                    var ig = $("image");
                                    el.id = R.createUUID();
                                    $(el, { x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1 });
                                    $(ig, { x: 0, y: 0, "xlink:href": isURL[1] });
                                    el.appendChild(ig);

                                    (function (el) {
                                        R._preload(isURL[1], function () {
                                            var w = this.offsetWidth,
                                                h = this.offsetHeight;
                                            $(el, { width: w, height: h });
                                            $(ig, { width: w, height: h });
                                            if (o.paper) {
                                                o.paper.safari();
                                            }
                                        });
                                    })(el);
                                    o.paper.defs.appendChild(el);
                                    $(node, { fill: "url(#" + el.id + ")" });
                                    o.pattern = el;
                                    o.pattern && updatePosition(o);
                                    break;
                                }
                                var clr = R.getRGB(value);
                                if (!clr.error) {
                                    delete params.gradient;
                                    delete attrs.gradient;
                                    !R.is(attrs.opacity, "undefined") &&
                                        R.is(params.opacity, "undefined") &&
                                        $(node, { opacity: attrs.opacity });
                                    !R.is(attrs["fill-opacity"], "undefined") &&
                                        R.is(params["fill-opacity"], "undefined") &&
                                        $(node, { "fill-opacity": attrs["fill-opacity"] });
                                } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                                    if ("opacity" in attrs || "fill-opacity" in attrs) {
                                        var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                        if (gradient) {
                                            var stops = gradient.getElementsByTagName("stop");
                                            $(stops[stops.length - 1], { "stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1) });
                                        }
                                    }
                                    attrs.gradient = value;
                                    attrs.fill = "none";
                                    break;
                                }
                                clr[has]("opacity") && $(node, { "fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity });
                            case "stroke":
                                clr = R.getRGB(value);
                                node.setAttribute(att, clr.hex);
                                att == "stroke" && clr[has]("opacity") && $(node, { "stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity });
                                if (att == "stroke" && o._.arrows) {
                                    "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                    "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                }
                                break;
                            case "gradient":
                                (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                                break;
                            case "opacity":
                                if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                    $(node, { "stroke-opacity": value > 1 ? value / 100 : value });
                                }
                            // fall
                            case "fill-opacity":
                                if (attrs.gradient) {
                                    gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                    if (gradient) {
                                        stops = gradient.getElementsByTagName("stop");
                                        $(stops[stops.length - 1], { "stop-opacity": value });
                                    }
                                    break;
                                }
                            default:
                                att == "font-size" && (value = toInt(value, 10) + "px");
                                var cssrule = att.replace(/(\-.)/g, function (w) {
                                    return w.substring(1).toUpperCase();
                                });
                                node.style[cssrule] = value;
                                o._.dirty = 1;
                                node.setAttribute(att, value);
                                break;
                        }
                    }
                }

                //tuneText(o, params);
                node.style.visibility = vis;
            },
            leading = 1.2,
            tuneText = function (el, params) {
                if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
                    return;
                }
                var a = el.attrs,
                    node = el.node,
                    fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

                if (params[has]("text")) {
                    a.text = params.text;
                    while (node.firstChild) {
                        node.removeChild(node.firstChild);
                    }
                    var texts = Str(params.text).split("\n"),
                        tspans = [],
                        tspan;
                    for (var i = 0, ii = texts.length; i < ii; i++) {
                        tspan = $("tspan");
                        i && $(tspan, { dy: fontSize * leading, x: a.x });
                        tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                        node.appendChild(tspan);
                        tspans[i] = tspan;
                    }
                } else {
                    tspans = node.getElementsByTagName("tspan");
                    for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                        $(tspans[i], { dy: fontSize * leading, x: a.x });
                    } else {
                        $(tspans[0], { dy: 0 });
                    }
                }
                $(node, { x: a.x, y: a.y });
                el._.dirty = 1;
                var bb = el._getBBox(),
                    dif = a.y - (bb.y + bb.height / 2);
                dif && R.is(dif, "finite") && $(tspans[0], { dy: dif });
            },
            Element = function (node, svg) {
                var X = 0,
                    Y = 0;
                /*\
                 * Element.node
                 [ property (object) ]
                 **
                 * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
                 **
                 * Note: Don’t mess with it.
                 > Usage
                 | // draw a circle at coordinate 10,10 with radius of 10
                 | var c = paper.circle(10, 10, 10);
                 | c.node.onclick = function () {
                 |     c.attr("fill", "red");
                 | };
                \*/
                this[0] = this.node = node;
                /*\
                 * Element.raphael
                 [ property (object) ]
                 **
                 * Internal reference to @Raphael object. In case it is not available.
                 > Usage
                 | Raphael.el.red = function () {
                 |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
                 |     hsb.h = 1;
                 |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
                 | }
                \*/
                node.raphael = true;
                /*\
                 * Element.id
                 [ property (number) ]
                 **
                 * Unique id of the element. Especially usesful when you want to listen to events of the element,
                 * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
                \*/
                this.id = R._oid++;
                node.raphaelid = this.id;
                this.matrix = R.matrix();
                this.realPath = null;
                /*\
                 * Element.paper
                 [ property (object) ]
                 **
                 * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.
                 > Usage
                 | Raphael.el.cross = function () {
                 |     this.attr({fill: "red"});
                 |     this.paper.path("M10,10L50,50M50,10L10,50")
                 |         .attr({stroke: "red"});
                 | }
                \*/
                this.paper = svg;
                this.attrs = this.attrs || {};
                this._ = {
                    transform: [],
                    sx: 1,
                    sy: 1,
                    deg: 0,
                    dx: 0,
                    dy: 0,
                    dirty: 1
                };
                !svg.bottom && (svg.bottom = this);
                /*\
                 * Element.prev
                 [ property (object) ]
                 **
                 * Reference to the previous element in the hierarchy.
                \*/
                this.prev = svg.top;
                svg.top && (svg.top.next = this);
                svg.top = this;
                /*\
                 * Element.next
                 [ property (object) ]
                 **
                 * Reference to the next element in the hierarchy.
                \*/
                this.next = null;
            },
            elproto = R.el;

        Element.prototype = elproto;
        elproto.constructor = Element;

        R._engine.element = function (node, SVG) {
            let el = new Element(node, SVG)
            return el
        }

        R._engine.circleElement = function (node, cx, cy, r, SVG) {
            let el = new Element(node, SVG)
            el.attrs = { cx: cx, cy: cy, r: r, fill: "none", stroke: "#000" }
            el.type = 'circle'
            return el
        }

        R._engine.imageElement = function (node, src, x, y, w, h, SVG) {
            let el = new Element(node, SVG)
            el.attrs = { x: x, y: y, width: w, height: h, src: src }
            el.type = 'image'
            return el
        }

        R._engine.textElement = function (node, x, y, text, SVG) {
            let el = new Element(node, SVG)
            el.type = 'text'
            return el
        }

        R._engine.rectElement = function (node, x, y, width, height, cornerRadius, SVG) {
            let el = new Element(node, SVG)
            el.attrs = { x: x, y: y, width: width, height: height, r: cornerRadius || 0, rx: cornerRadius || 0, ry: cornerRadius || 0, fill: "none", stroke: "#000" }
            el.type = 'rect'
            return el
        }

        R._engine.pathElement = function (node, p, SVG) {
            let el = new Element(node, SVG)
            el.attrs = { fill: "none", stroke: "#000", path: p }
            el.type = 'path'
            return el
        }

        R._engine.ellipseElement = function (node, x, y, radius1, radius2, SVG) {
            let el = new Element(node, SVG)
            el.attrs = { cx: x, cy: y, rx: radius1, ry: radius2, fill: "none", stroke: "#000" }
            el.type = 'ellipse'
            return el
        }

        R._engine.path = function (pathString, SVG) {
            var el = $("path");
            SVG.canvas && SVG.canvas.appendChild(el);
            var p = new Element(el, SVG);
            p.type = "path";
            setFillAndStroke(p, {
                fill: "none",
                stroke: "#000",
                path: pathString
            });
            return p;
        };
        /*\
         * Element.rotate
         [ method ]
         **
         * Deprecated! Use @Element.transform instead.
         * Adds rotation by given angle around given point to the list of
         * transformations of the element.
         > Parameters
         - deg (number) angle in degrees
         - cx (number) #optional x coordinate of the centre of rotation
         - cy (number) #optional y coordinate of the centre of rotation
         * If cx & cy aren’t specified centre of the shape is used as a point of rotation.
         = (object) @Element
        \*/
        elproto.rotate = function (deg, cx, cy) {
            if (this.removed) {
                return this;
            }
            deg = Str(deg).split(separator);
            if (deg.length - 1) {
                cx = toFloat(deg[1]);
                cy = toFloat(deg[2]);
            }
            deg = toFloat(deg[0]);
            (cy == null) && (cx = cy);
            if (cx == null || cy == null) {
                var bbox = this.getBBox(1);
                cx = bbox.x + bbox.width / 2;
                cy = bbox.y + bbox.height / 2;
            }
            this.transform(this._.transform.concat([["r", deg, cx, cy]]));
            return this;
        };
        /*\
         * Element.scale
         [ method ]
         **
         * Deprecated! Use @Element.transform instead.
         * Adds scale by given amount relative to given point to the list of
         * transformations of the element.
         > Parameters
         - sx (number) horisontal scale amount
         - sy (number) vertical scale amount
         - cx (number) #optional x coordinate of the centre of scale
         - cy (number) #optional y coordinate of the centre of scale
         * If cx & cy aren’t specified centre of the shape is used instead.
         = (object) @Element
        \*/
        elproto.scale = function (sx, sy, cx, cy) {
            if (this.removed) {
                return this;
            }
            sx = Str(sx).split(separator);
            if (sx.length - 1) {
                sy = toFloat(sx[1]);
                cx = toFloat(sx[2]);
                cy = toFloat(sx[3]);
            }
            sx = toFloat(sx[0]);
            (sy == null) && (sy = sx);
            (cy == null) && (cx = cy);
            if (cx == null || cy == null) {
                var bbox = this.getBBox(1);
            }
            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
            cy = cy == null ? bbox.y + bbox.height / 2 : cy;
            this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
            return this;
        };
        /*\
         * Element.translate
         [ method ]
         **
         * Deprecated! Use @Element.transform instead.
         * Adds translation by given amount to the list of transformations of the element.
         > Parameters
         - dx (number) horisontal shift
         - dy (number) vertical shift
         = (object) @Element
        \*/
        elproto.translate = function (dx, dy) {
            if (this.removed) {
                return this;
            }
            dx = Str(dx).split(separator);
            if (dx.length - 1) {
                dy = toFloat(dx[1]);
            }
            dx = toFloat(dx[0]) || 0;
            dy = +dy || 0;
            this.transform(this._.transform.concat([["t", dx, dy]]));
            return this;
        };
        /*\
         * Element.transform
         [ method ]
         **
         * Adds transformation to the element which is separate to other attributes,
         * i.e. translation doesn’t change `x` or `y` of the rectange. The format
         * of transformation string is similar to the path string syntax:
         | "t100,100r30,100,100s2,2,100,100r45s1.5"
         * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
         * scale and `m` is for matrix.
         *
         * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
         *
         * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;
         * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin
         * coordinates as optional parameters, the default is the centre point of the element.
         * Matrix accepts six parameters.
         > Usage
         | var el = paper.rect(10, 20, 300, 200);
         | // translate 100, 100, rotate 45°, translate -100, 0
         | el.transform("t100,100r45t-100,0");
         | // if you want you can append or prepend transformations
         | el.transform("...t50,50");
         | el.transform("s2...");
         | // or even wrap
         | el.transform("t50,50...t-50-50");
         | // to reset transformation call method with empty string
         | el.transform("");
         | // to get current value call it without parameters
         | console.log(el.transform());
         > Parameters
         - tstr (string) #optional transformation string
         * If tstr isn’t specified
         = (string) current transformation string
         * else
         = (object) @Element
        \*/
        elproto.transform = function (tstr) {
            var _ = this._;
            if (tstr == null) {
                return _.transform;
            }
            R._extractTransform(this, tstr);

            this.clip && $(this.clip, { transform: this.matrix.invert() });
            this.pattern && updatePosition(this);
            this.node && $(this.node, { transform: this.matrix });

            /*
            if (_.sx != 1 || _.sy != 1) {
                var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
                this.attr({"stroke-width": sw});
            }
             */

            return this;
        };
        /*\
         * Element.hide
         [ method ]
         **
         * Makes element invisible. See @Element.show.
         = (object) @Element
        \*/
        elproto.hide = function () {
            !this.removed && this.paper.safari(this.node.style.display = "none");
            return this;
        };
        /*\
         * Element.show
         [ method ]
         **
         * Makes element visible. See @Element.hide.
         = (object) @Element
        \*/
        elproto.show = function () {
            !this.removed && this.paper.safari(this.node.style.display = "");
            return this;
        };
        /*\
         * Element.remove
         [ method ]
         **
         * Removes element from the paper.
        \*/
        elproto.remove = function () {
            if (this.removed || !this.node.parentNode) {
                return;
            }
            var paper = this.paper;
            paper.__set__ && paper.__set__.exclude(this);
            eve.unbind("raphael.*.*." + this.id);
            if (this.gradient) {
                paper.defs.removeChild(this.gradient);
            }
            R._tear(this, paper);
            if (this.node.parentNode.tagName.toLowerCase() == "a") {
                this.node.parentNode.parentNode.removeChild(this.node.parentNode);
            } else {
                this.node.parentNode.removeChild(this.node);
            }
            for (var i in this) {
                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
            }
            this.removed = true;
        };
        elproto._getBBox = function () {
            if (this.node.style.display == "none") {
                this.show();
                var hide = true;
            }
            var bbox = {};
            try {
                bbox = this.node.getBBox();
            } catch (e) {
                // Firefox 3.0.x plays badly here
            } finally {
                bbox = bbox || {};
            }
            hide && this.hide();
            return bbox;
        };
        /*\
         * Element.attr
         [ method ]
         **
         * Sets the attributes of the element.
         > Parameters
         - attrName (string) attribute’s name
         - value (string) value
         * or
         - params (object) object of name/value pairs
         * or
         - attrName (string) attribute’s name
         * or
         - attrNames (array) in this case method returns array of current values for given attribute names
         = (object) @Element if attrsName & value or params are passed in.
         = (...) value of the attribute if only attrsName is passed in.
         = (array) array of values of the attribute if attrsNames is passed in.
         = (object) object of attributes if nothing is passed in.
         > Possible parameters
         # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
         o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
         o clip-rect (string) comma or space separated values: x, y, width and height
         o cursor (string) CSS type of the cursor
         o cx (number) the x-axis coordinate of the center of the circle, or ellipse
         o cy (number) the y-axis coordinate of the center of the circle, or ellipse
         o fill (string) colour, gradient or image
         o fill-opacity (number)
         o font (string)
         o font-family (string)
         o font-size (number) font size in pixels
         o font-weight (string)
         o height (number)
         o href (string) URL, if specified element behaves as hyperlink
         o opacity (number)
         o path (string) SVG path string format
         o r (number) radius of the circle, ellipse or rounded corner on the rect
         o rx (number) horisontal radius of the ellipse
         o ry (number) vertical radius of the ellipse
         o src (string) image URL, only works for @Element.image element
         o stroke (string) stroke colour
         o stroke-dasharray (string) [“”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]
         o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]
         o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]
         o stroke-miterlimit (number)
         o stroke-opacity (number)
         o stroke-width (number) stroke width in pixels, default is '1'
         o target (string) used with href
         o text (string) contents of the text element. Use `\n` for multiline text
         o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”
         o title (string) will create tooltip with a given text
         o transform (string) see @Element.transform
         o width (number)
         o x (number)
         o y (number)
         > Gradients
         * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°
         * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.
         *
         * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –
         * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point
         * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
         > Path String
         # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path’s data attribute’s format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>
         > Colour Parsing
         # <ul>
         #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
         #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
         #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
         #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
         #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
         #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>
         #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>
         #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
         #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
         #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>
         #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
         #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
         #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>
         #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>
         # </ul>
        \*/
        elproto.attr = function (name, value) {
            if (this.removed) {
                return this;
            }
            if (name == null) {
                var res = {};
                for (var a in this.attrs) if (this.attrs[has](a)) {
                    res[a] = this.attrs[a];
                }
                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                res.transform = this._.transform;
                return res;
            }
            if (value == null && R.is(name, "string")) {
                if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                    return this.attrs.gradient;
                }
                if (name == "transform") {
                    return this._.transform;
                }
                var names = name.split(separator),
                    out = {};
                for (var i = 0, ii = names.length; i < ii; i++) {
                    name = names[i];
                    if (name in this.attrs) {
                        out[name] = this.attrs[name];
                    } else if (R.is(this.paper.customAttributes[name], "function")) {
                        out[name] = this.paper.customAttributes[name].def;
                    } else {
                        out[name] = R._availableAttrs[name];
                    }
                }
                return ii - 1 ? out : out[names[0]];
            }
            if (value == null && R.is(name, "array")) {
                out = {};
                for (i = 0, ii = name.length; i < ii; i++) {
                    out[name[i]] = this.attr(name[i]);
                }
                return out;
            }
            if (value != null) {
                var params = {};
                params[name] = value;
            } else if (name != null && R.is(name, "object")) {
                params = name;
            }
            for (var key in params) {
                eve("raphael.attr." + key + "." + this.id, this, params[key]);
            }
            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                this.attrs[key] = params[key];
                for (var subkey in par) if (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }
            setFillAndStroke(this, params);
            return this;
        };
        /*\
         * Element.toFront
         [ method ]
         **
         * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.
         = (object) @Element
        \*/
        elproto.toFront = function () {
            if (this.removed) {
                return this;
            }
            if (this.node.parentNode.tagName.toLowerCase() == "a") {
                this.node.parentNode.parentNode.appendChild(this.node.parentNode);
            } else {
                this.node.parentNode.appendChild(this.node);
            }
            var svg = this.paper;
            svg.top != this && R._tofront(this, svg);
            return this;
        };
        /*\
         * Element.toBack
         [ method ]
         **
         * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.
         = (object) @Element
        \*/
        elproto.toBack = function () {
            if (this.removed) {
                return this;
            }
            var parent = this.node.parentNode;
            if (parent.tagName.toLowerCase() == "a") {
                parent.parentNode.insertBefore(this.node.parentNode, this.node.parentNode.parentNode.firstChild);
            } else if (parent.firstChild != this.node) {
                parent.insertBefore(this.node, this.node.parentNode.firstChild);
            }
            R._toback(this, this.paper);
            var svg = this.paper;
            return this;
        };
        /*\
         * Element.insertAfter
         [ method ]
         **
         * Inserts current object after the given one.
         = (object) @Element
        \*/
        elproto.insertAfter = function (element) {
            if (this.removed) {
                return this;
            }
            var node = element.node || element[element.length - 1].node;
            if (node.nextSibling) {
                node.parentNode.insertBefore(this.node, node.nextSibling);
            } else {
                node.parentNode.appendChild(this.node);
            }
            R._insertafter(this, element, this.paper);
            return this;
        };
        /*\
         * Element.insertBefore
         [ method ]
         **
         * Inserts current object before the given one.
         = (object) @Element
        \*/
        elproto.insertBefore = function (element) {
            if (this.removed) {
                return this;
            }
            var node = element.node || element[0].node;
            node.parentNode.insertBefore(this.node, node);
            R._insertbefore(this, element, this.paper);
            return this;
        };
        elproto.blur = function (size) {
            // Experimental. No Safari support. Use it on your own risk.
            var t = this;
            if (+size !== 0) {
                var fltr = $("filter"),
                    blur = $("feGaussianBlur");
                t.attrs.blur = size;
                fltr.id = R.createUUID();
                $(blur, { stdDeviation: +size || 1.5 });
                fltr.appendChild(blur);
                t.paper.defs.appendChild(fltr);
                t._blur = fltr;
                $(t.node, { filter: "url(#" + fltr.id + ")" });
            } else {
                if (t._blur) {
                    t._blur.parentNode.removeChild(t._blur);
                    delete t._blur;
                    delete t.attrs.blur;
                }
                t.node.removeAttribute("filter");
            }
            return t;
        };
        R._engine.circle = function (svg, x, y, r) {
            var el = $("circle");
            svg.canvas && svg.canvas.appendChild(el);
            var res = new Element(el, svg);
            res.attrs = { cx: x, cy: y, r: r, fill: "none", stroke: "#000" };
            res.type = "circle";
            $(el, res.attrs);
            return res;
        };
        R._engine.rect = function (svg, x, y, w, h, r) {
            var el = $("rect");
            svg.canvas && svg.canvas.appendChild(el);
            var res = new Element(el, svg);
            res.attrs = { x: x, y: y, width: w, height: h, r: r || 0, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000" };
            res.type = "rect";
            $(el, res.attrs);
            return res;
        };
        R._engine.ellipse = function (svg, x, y, rx, ry) {
            var el = $("ellipse");
            svg.canvas && svg.canvas.appendChild(el);
            var res = new Element(el, svg);
            res.attrs = { cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000" };
            res.type = "ellipse";
            $(el, res.attrs);
            return res;
        };
        R._engine.image = function (svg, src, x, y, w, h) {
            var el = $("image");
            $(el, { x: x, y: y, width: w, height: h, preserveAspectRatio: "none" });
            el.setAttributeNS(xlink, "href", src);
            svg.canvas && svg.canvas.appendChild(el);
            var res = new Element(el, svg);
            res.attrs = { x: x, y: y, width: w, height: h, src: src };
            res.type = "image";
            return res;
        };
        R._engine.text = function (svg, x, y, text) {
            var el = $("text");
            svg.canvas && svg.canvas.appendChild(el);
            var res = new Element(el, svg);
            res.attrs = {
                x: x,
                y: y,
                "text-anchor": "middle",
                text: text,
                font: R._availableAttrs.font,
                stroke: "none",
                fill: "#000"
            };
            res.type = "text";
            setFillAndStroke(res, res.attrs);
            return res;
        };
        R._engine.setSize = function (width, height) {
            this.width = width || this.width;
            this.height = height || this.height;
            this.canvas.setAttribute("width", this.width);
            this.canvas.setAttribute("height", this.height);
            if (this._viewBox) {
                this.setViewBox.apply(this, this._viewBox);
            }
            return this;
        };
        R._engine.create = function () {
            var con = R._getContainer.apply(0, arguments),
                container = con && con.container,
                x = con.x,
                y = con.y,
                width = con.width,
                height = con.height;
            if (!container) {
                throw new Error("SVG container not found.");
            }
            var cnvs = $("svg"),
                css = "overflow:hidden;",
                isFloating;
            x = x || 0;
            y = y || 0;
            width = width || 512;
            height = height || 342;
            $(cnvs, {
                height: height,
                version: 1.1,
                width: width,
                xmlns: "http://www.w3.org/2000/svg"
            });
            if (container == 1) {
                cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
                R._g.doc.body.appendChild(cnvs);
                isFloating = 1;
            } else {
                cnvs.style.cssText = css + "position:relative";
                if (container.firstChild) {
                    container.insertBefore(cnvs, container.firstChild);
                } else {
                    container.appendChild(cnvs);
                }
            }
            container = new R._Paper;
            container.width = width;
            container.height = height;
            container.canvas = cnvs;
            container.clear();
            container._left = container._top = 0;
            isFloating && (container.renderfix = function () { });
            container.renderfix();
            return container;
        };
        R._engine.setViewBox = function (x, y, w, h, fit) {
            eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
            var size = mmax(w / this.width, h / this.height),
                top = this.top,
                aspectRatio = fit ? "meet" : "xMinYMin",
                vb,
                sw;
            if (x == null) {
                if (this._vbSize) {
                    size = 1;
                }
                delete this._vbSize;
                vb = "0 0 " + this.width + S + this.height;
            } else {
                this._vbSize = size;
                vb = x + S + y + S + w + S + h;
            }
            $(this.canvas, {
                viewBox: vb,
                preserveAspectRatio: aspectRatio
            });
            while (size && top) {
                sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
                top.attr({ "stroke-width": sw });
                top._.dirty = 1;
                top._.dirtyT = 1;
                top = top.prev;
            }
            this._viewBox = [x, y, w, h, !!fit];
            return this;
        };
        /*\
         * Paper.renderfix
         [ method ]
         **
         * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant
         * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
         * This method fixes the issue.
         **
           Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
        \*/
        R.prototype.renderfix = function () {
            var cnvs = this.canvas,
                s = cnvs.style,
                pos;
            try {
                pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
            } catch (e) {
                pos = cnvs.createSVGMatrix();
            }
            var left = -pos.e % 1,
                top = -pos.f % 1;
            if (left || top) {
                if (left) {
                    this._left = (this._left + left) % 1;
                    s.left = this._left + "px";
                }
                if (top) {
                    this._top = (this._top + top) % 1;
                    s.top = this._top + "px";
                }
            }
        };
        /*\
         * Paper.clear
         [ method ]
         **
         * Clears the paper, i.e. removes all the elements.
        \*/
        R.prototype.clear = function () {
            R.eve("raphael.clear", this);
            var c = this.canvas;
            while (c.firstChild) {
                c.removeChild(c.firstChild);
            }
            this.bottom = this.top = null;
            (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
            c.appendChild(this.desc);
            c.appendChild(this.defs = $("defs"));
        };
        /*\
         * Paper.remove
         [ method ]
         **
         * Removes the paper from the DOM.
        \*/
        R.prototype.remove = function () {
            eve("raphael.remove", this);
            this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
            for (var i in this) {
                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
            }
        };
        var setproto = R.st;
        for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
            setproto[method] = (function (methodname) {
                return function () {
                    var arg = arguments;
                    return this.forEach(function (el) {
                        el[methodname].apply(el, arg);
                    });
                };
            })(method);
        }
    })();

    // ┌─────────────────────────────────────────────────────────────────────┐ \\
    // │ Raphaël - JavaScript Vector Library                                 │ \\
    // ├─────────────────────────────────────────────────────────────────────┤ \\
    // │ VML Module                                                          │ \\
    // ├─────────────────────────────────────────────────────────────────────┤ \\
    // │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
    // │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
    // │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
    // └─────────────────────────────────────────────────────────────────────┘ \\

    (function () {
        if (!R.vml) {
            return;
        }
        var has = "hasOwnProperty",
            Str = String,
            toFloat = parseFloat,
            math = Math,
            round = math.round,
            mmax = math.max,
            mmin = math.min,
            abs = math.abs,
            fillString = "fill",
            separator = /[, ]+/,
            eve = R.eve,
            ms = " progid:DXImageTransform.Microsoft",
            S = " ",
            E = "",
            map = { M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x" },
            bites = /([clmz]),?([^clmz]*)/gi,
            blurregexp = / progid:\S+Blur\([^\)]+\)/g,
            val = /-?[^,\s-]+/g,
            cssDot = "position:absolute;left:0;top:0;width:1px;height:1px",
            zoom = 21600,
            pathTypes = { path: 1, rect: 1, image: 1 },
            ovalTypes = { circle: 1, ellipse: 1 },
            path2vml = function (path) {
                var total = /[ahqstv]/ig,
                    command = R._pathToAbsolute;
                Str(path).match(total) && (command = R._path2curve);
                total = /[clmz]/g;
                if (command == R._pathToAbsolute && !Str(path).match(total)) {
                    var res = Str(path).replace(bites, function (all, command, args) {
                        var vals = [],
                            isMove = command.toLowerCase() == "m",
                            res = map[command];
                        args.replace(val, function (value) {
                            if (isMove && vals.length == 2) {
                                res += vals + map[command == "m" ? "l" : "L"];
                                vals = [];
                            }
                            vals.push(round(value * zoom));
                        });
                        return res + vals;
                    });
                    return res;
                }
                var pa = command(path), p, r;
                res = [];
                for (var i = 0, ii = pa.length; i < ii; i++) {
                    p = pa[i];
                    r = pa[i][0].toLowerCase();
                    r == "z" && (r = "x");
                    for (var j = 1, jj = p.length; j < jj; j++) {
                        r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                    }
                    res.push(r);
                }
                return res.join(S);
            },
            compensation = function (deg, dx, dy) {
                var m = R.matrix();
                m.rotate(-deg, .5, .5);
                return {
                    dx: m.x(dx, dy),
                    dy: m.y(dx, dy)
                };
            },
            setCoords = function (p, sx, sy, dx, dy, deg) {
                var _ = p._,
                    m = p.matrix,
                    fillpos = _.fillpos,
                    o = p.node,
                    s = o.style,
                    y = 1,
                    flip = "",
                    dxdy,
                    kx = zoom / sx,
                    ky = zoom / sy;
                s.visibility = "hidden";
                if (!sx || !sy) {
                    return;
                }
                o.coordsize = abs(kx) + S + abs(ky);
                s.rotation = deg * (sx * sy < 0 ? -1 : 1);
                if (deg) {
                    var c = compensation(deg, dx, dy);
                    dx = c.dx;
                    dy = c.dy;
                }
                sx < 0 && (flip += "x");
                sy < 0 && (flip += " y") && (y = -1);
                s.flip = flip;
                o.coordorigin = (dx * -kx) + S + (dy * -ky);
                if (fillpos || _.fillsize) {
                    var fill = o.getElementsByTagName(fillString);
                    fill = fill && fill[0];
                    o.removeChild(fill);
                    if (fillpos) {
                        c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                        fill.position = c.dx * y + S + c.dy * y;
                    }
                    if (_.fillsize) {
                        fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                    }
                    o.appendChild(fill);
                }
                s.visibility = "visible";
            };
        R.toString = function () {
            return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
        };
        var addArrow = function (o, value, isEnd) {
            var values = Str(value).toLowerCase().split("-"),
                se = isEnd ? "end" : "start",
                i = values.length,
                type = "classic",
                w = "medium",
                h = "medium";
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide":
                    case "narrow": h = values[i]; break;
                    case "long":
                    case "short": w = values[i]; break;
                }
            }
            var stroke = o.node.getElementsByTagName("stroke")[0];
            stroke[se + "arrow"] = type;
            stroke[se + "arrowlength"] = w;
            stroke[se + "arrowwidth"] = h;
        },
            setFillAndStroke = function (o, params) {
                // o.paper.canvas.style.display = "none";
                o.attrs = o.attrs || {};
                var node = o.node,
                    a = o.attrs,
                    s = node.style,
                    xy,
                    newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
                    isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
                    res = o;


                for (var par in params) if (params[has](par)) {
                    a[par] = params[par];
                }
                if (newpath) {
                    a.path = R._getPath[o.type](o);
                    o._.dirty = 1;
                }
                params.href && (node.href = params.href);
                params.title && (node.title = params.title);
                params.target && (node.target = params.target);
                params.cursor && (s.cursor = params.cursor);
                "blur" in params && o.blur(params.blur);
                if (params.path && o.type == "path" || newpath) {
                    node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
                    if (o.type == "image") {
                        o._.fillpos = [a.x, a.y];
                        o._.fillsize = [a.width, a.height];
                        setCoords(o, 1, 1, 0, 0, 0);
                    }
                }
                "transform" in params && o.transform(params.transform);
                if (isOval) {
                    var cx = +a.cx,
                        cy = +a.cy,
                        rx = +a.rx || +a.r || 0,
                        ry = +a.ry || +a.r || 0;
                    node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
                    o._.dirty = 1;
                }
                if ("clip-rect" in params) {
                    var rect = Str(params["clip-rect"]).split(separator);
                    if (rect.length == 4) {
                        rect[2] = +rect[2] + (+rect[0]);
                        rect[3] = +rect[3] + (+rect[1]);
                        var div = node.clipRect || R._g.doc.createElement("div"),
                            dstyle = div.style;
                        dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                        if (!node.clipRect) {
                            dstyle.position = "absolute";
                            dstyle.top = 0;
                            dstyle.left = 0;
                            dstyle.width = o.paper.width + "px";
                            dstyle.height = o.paper.height + "px";
                            node.parentNode.insertBefore(div, node);
                            div.appendChild(node);
                            node.clipRect = div;
                        }
                    }
                    if (!params["clip-rect"]) {
                        node.clipRect && (node.clipRect.style.clip = "auto");
                    }
                }
                if (o.textpath) {
                    var textpathStyle = o.textpath.style;
                    params.font && (textpathStyle.font = params.font);
                    params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
                    params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
                    params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
                    params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
                }
                if ("arrow-start" in params) {
                    addArrow(res, params["arrow-start"]);
                }
                if ("arrow-end" in params) {
                    addArrow(res, params["arrow-end"], 1);
                }
                if (params.opacity != null ||
                    params["stroke-width"] != null ||
                    params.fill != null ||
                    params.src != null ||
                    params.stroke != null ||
                    params["stroke-width"] != null ||
                    params["stroke-opacity"] != null ||
                    params["fill-opacity"] != null ||
                    params["stroke-dasharray"] != null ||
                    params["stroke-miterlimit"] != null ||
                    params["stroke-linejoin"] != null ||
                    params["stroke-linecap"] != null) {
                    var fill = node.getElementsByTagName(fillString),
                        newfill = false;
                    fill = fill && fill[0];
                    !fill && (newfill = fill = createNode(fillString));
                    if (o.type == "image" && params.src) {
                        fill.src = params.src;
                    }
                    params.fill && (fill.on = true);
                    if (fill.on == null || params.fill == "none" || params.fill === null) {
                        fill.on = false;
                    }
                    if (fill.on && params.fill) {
                        var isURL = Str(params.fill).match(R._ISURL);
                        if (isURL) {
                            fill.parentNode == node && node.removeChild(fill);
                            fill.rotate = true;
                            fill.src = isURL[1];
                            fill.type = "tile";
                            var bbox = o.getBBox(1);
                            fill.position = bbox.x + S + bbox.y;
                            o._.fillpos = [bbox.x, bbox.y];

                            R._preload(isURL[1], function () {
                                o._.fillsize = [this.offsetWidth, this.offsetHeight];
                            });
                        } else {
                            fill.color = R.getRGB(params.fill).hex;
                            fill.src = E;
                            fill.type = "solid";
                            if (R.getRGB(params.fill).error && (res.type in { circle: 1, ellipse: 1 } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                                a.fill = "none";
                                a.gradient = params.fill;
                                fill.rotate = false;
                            }
                        }
                    }
                    if ("fill-opacity" in params || "opacity" in params) {
                        var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                        opacity = mmin(mmax(opacity, 0), 1);
                        fill.opacity = opacity;
                        if (fill.src) {
                            fill.color = "none";
                        }
                    }
                    node.appendChild(fill);
                    var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                        newstroke = false;
                    !stroke && (newstroke = stroke = createNode("stroke"));
                    if ((params.stroke && params.stroke != "none") ||
                        params["stroke-width"] ||
                        params["stroke-opacity"] != null ||
                        params["stroke-dasharray"] ||
                        params["stroke-miterlimit"] ||
                        params["stroke-linejoin"] ||
                        params["stroke-linecap"]) {
                        stroke.on = true;
                    }
                    (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                    var strokeColor = R.getRGB(params.stroke);
                    stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                    opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
                    var width = (toFloat(params["stroke-width"]) || 1) * .75;
                    opacity = mmin(mmax(opacity, 0), 1);
                    params["stroke-width"] == null && (width = a["stroke-width"]);
                    params["stroke-width"] && (stroke.weight = width);
                    width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                    stroke.opacity = opacity;

                    params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
                    stroke.miterlimit = params["stroke-miterlimit"] || 8;
                    params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                    if (params["stroke-dasharray"]) {
                        var dasharray = {
                            "-": "shortdash",
                            ".": "shortdot",
                            "-.": "shortdashdot",
                            "-..": "shortdashdotdot",
                            ". ": "dot",
                            "- ": "dash",
                            "--": "longdash",
                            "- .": "dashdot",
                            "--.": "longdashdot",
                            "--..": "longdashdotdot"
                        };
                        stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
                    }
                    newstroke && node.appendChild(stroke);
                }
                if (res.type == "text") {
                    res.paper.canvas.style.display = E;
                    var span = res.paper.span,
                        m = 100,
                        fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
                    s = span.style;
                    a.font && (s.font = a.font);
                    a["font-family"] && (s.fontFamily = a["font-family"]);
                    a["font-weight"] && (s.fontWeight = a["font-weight"]);
                    a["font-style"] && (s.fontStyle = a["font-style"]);
                    fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
                    s.fontSize = fontSize * m + "px";
                    res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
                    var brect = span.getBoundingClientRect();
                    res.W = a.w = (brect.right - brect.left) / m;
                    res.H = a.h = (brect.bottom - brect.top) / m;
                    // res.paper.canvas.style.display = "none";
                    res.X = a.x;
                    res.Y = a.y + res.H / 2;

                    ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
                    var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
                    for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                        res._.dirty = 1;
                        break;
                    }

                    // text-anchor emulation
                    switch (a["text-anchor"]) {
                        case "start":
                            res.textpath.style["v-text-align"] = "left";
                            res.bbx = res.W / 2;
                            break;
                        case "end":
                            res.textpath.style["v-text-align"] = "right";
                            res.bbx = -res.W / 2;
                            break;
                        default:
                            res.textpath.style["v-text-align"] = "center";
                            res.bbx = 0;
                            break;
                    }
                    res.textpath.style["v-text-kern"] = true;
                }
                // res.paper.canvas.style.display = E;
            },
            addGradientFill = function (o, gradient, fill) {
                o.attrs = o.attrs || {};
                var attrs = o.attrs,
                    pow = Math.pow,
                    opacity,
                    oindex,
                    type = "linear",
                    fxfy = ".5 .5";
                o.attrs.gradient = gradient;
                gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
                    type = "radial";
                    if (fx && fy) {
                        fx = toFloat(fx);
                        fy = toFloat(fy);
                        pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                        fxfy = fx + S + fy;
                    }
                    return E;
                });
                gradient = gradient.split(/\s*\-\s*/);
                if (type == "linear") {
                    var angle = gradient.shift();
                    angle = -toFloat(angle);
                    if (isNaN(angle)) {
                        return null;
                    }
                }
                var dots = R._parseDots(gradient);
                if (!dots) {
                    return null;
                }
                o = o.shape || o.node;
                if (dots.length) {
                    o.removeChild(fill);
                    fill.on = true;
                    fill.method = "none";
                    fill.color = dots[0].color;
                    fill.color2 = dots[dots.length - 1].color;
                    var clrs = [];
                    for (var i = 0, ii = dots.length; i < ii; i++) {
                        dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                    }
                    fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                    if (type == "radial") {
                        fill.type = "gradientTitle";
                        fill.focus = "100%";
                        fill.focussize = "0 0";
                        fill.focusposition = fxfy;
                        fill.angle = 0;
                    } else {
                        // fill.rotate= true;
                        fill.type = "gradient";
                        fill.angle = (270 - angle) % 360;
                    }
                    o.appendChild(fill);
                }
                return 1;
            },
            Element = function (node, vml) {
                this[0] = this.node = node;
                node.raphael = true;
                this.id = R._oid++;
                node.raphaelid = this.id;
                this.X = 0;
                this.Y = 0;
                this.attrs = {};
                this.paper = vml;
                this.matrix = R.matrix();
                this._ = {
                    transform: [],
                    sx: 1,
                    sy: 1,
                    dx: 0,
                    dy: 0,
                    deg: 0,
                    dirty: 1,
                    dirtyT: 1
                };
                !vml.bottom && (vml.bottom = this);
                this.prev = vml.top;
                vml.top && (vml.top.next = this);
                vml.top = this;
                this.next = null;
            };
        var elproto = R.el;

        Element.prototype = elproto;
        elproto.constructor = Element;
        elproto.transform = function (tstr) {
            if (tstr == null) {
                return this._.transform;
            }
            var vbs = this.paper._viewBoxShift,
                vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
                oldt;
            if (vbs) {
                oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
            }
            R._extractTransform(this, vbt + tstr);
            var matrix = this.matrix.clone(),
                skew = this.skew,
                o = this.node,
                split,
                isGrad = ~Str(this.attrs.fill).indexOf("-"),
                isPatt = !Str(this.attrs.fill).indexOf("url(");
            matrix.translate(1, 1);
            if (isPatt || isGrad || this.type == "image") {
                skew.matrix = "1 0 0 1";
                skew.offset = "0 0";
                split = matrix.split();
                if ((isGrad && split.noRotation) || !split.isSimple) {
                    o.style.filter = matrix.toFilter();
                    var bb = this.getBBox(),
                        bbt = this.getBBox(1),
                        dx = bb.x - bbt.x,
                        dy = bb.y - bbt.y;
                    o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                    setCoords(this, 1, 1, dx, dy, 0);
                } else {
                    o.style.filter = E;
                    setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
                }
            } else {
                o.style.filter = E;
                skew.matrix = Str(matrix);
                skew.offset = matrix.offset();
            }
            oldt && (this._.transform = oldt);
            return this;
        };
        elproto.rotate = function (deg, cx, cy) {
            if (this.removed) {
                return this;
            }
            if (deg == null) {
                return;
            }
            deg = Str(deg).split(separator);
            if (deg.length - 1) {
                cx = toFloat(deg[1]);
                cy = toFloat(deg[2]);
            }
            deg = toFloat(deg[0]);
            (cy == null) && (cx = cy);
            if (cx == null || cy == null) {
                var bbox = this.getBBox(1);
                cx = bbox.x + bbox.width / 2;
                cy = bbox.y + bbox.height / 2;
            }
            this._.dirtyT = 1;
            this.transform(this._.transform.concat([["r", deg, cx, cy]]));
            return this;
        };
        elproto.translate = function (dx, dy) {
            if (this.removed) {
                return this;
            }
            dx = Str(dx).split(separator);
            if (dx.length - 1) {
                dy = toFloat(dx[1]);
            }
            dx = toFloat(dx[0]) || 0;
            dy = +dy || 0;
            if (this._.bbox) {
                this._.bbox.x += dx;
                this._.bbox.y += dy;
            }
            this.transform(this._.transform.concat([["t", dx, dy]]));
            return this;
        };
        elproto.scale = function (sx, sy, cx, cy) {
            if (this.removed) {
                return this;
            }
            sx = Str(sx).split(separator);
            if (sx.length - 1) {
                sy = toFloat(sx[1]);
                cx = toFloat(sx[2]);
                cy = toFloat(sx[3]);
                isNaN(cx) && (cx = null);
                isNaN(cy) && (cy = null);
            }
            sx = toFloat(sx[0]);
            (sy == null) && (sy = sx);
            (cy == null) && (cx = cy);
            if (cx == null || cy == null) {
                var bbox = this.getBBox(1);
            }
            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
            cy = cy == null ? bbox.y + bbox.height / 2 : cy;

            this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
            this._.dirtyT = 1;
            return this;
        };
        elproto.hide = function () {
            !this.removed && (this.node.style.display = "none");
            return this;
        };
        elproto.show = function () {
            !this.removed && (this.node.style.display = E);
            return this;
        };
        elproto._getBBox = function () {
            if (this.removed) {
                return {};
            }
            return {
                x: this.X + (this.bbx || 0) - this.W / 2,
                y: this.Y - this.H,
                width: this.W,
                height: this.H
            };
        };
        elproto.remove = function () {
            if (this.removed || !this.node.parentNode) {
                return;
            }
            this.paper.__set__ && this.paper.__set__.exclude(this);
            R.eve.unbind("raphael.*.*." + this.id);
            R._tear(this, this.paper);
            this.node.parentNode.removeChild(this.node);
            this.shape && this.shape.parentNode.removeChild(this.shape);
            for (var i in this) {
                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
            }
            this.removed = true;
        };
        elproto.attr = function (name, value) {
            if (this.removed) {
                return this;
            }
            if (name == null) {
                var res = {};
                for (var a in this.attrs) if (this.attrs[has](a)) {
                    res[a] = this.attrs[a];
                }
                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                res.transform = this._.transform;
                return res;
            }
            if (value == null && R.is(name, "string")) {
                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                    return this.attrs.gradient;
                }
                var names = name.split(separator),
                    out = {};
                for (var i = 0, ii = names.length; i < ii; i++) {
                    name = names[i];
                    if (name in this.attrs) {
                        out[name] = this.attrs[name];
                    } else if (R.is(this.paper.customAttributes[name], "function")) {
                        out[name] = this.paper.customAttributes[name].def;
                    } else {
                        out[name] = R._availableAttrs[name];
                    }
                }
                return ii - 1 ? out : out[names[0]];
            }
            if (this.attrs && value == null && R.is(name, "array")) {
                out = {};
                for (i = 0, ii = name.length; i < ii; i++) {
                    out[name[i]] = this.attr(name[i]);
                }
                return out;
            }
            var params;
            if (value != null) {
                params = {};
                params[name] = value;
            }
            value == null && R.is(name, "object") && (params = name);
            for (var key in params) {
                eve("raphael.attr." + key + "." + this.id, this, params[key]);
            }
            if (params) {
                for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                    var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                    this.attrs[key] = params[key];
                    for (var subkey in par) if (par[has](subkey)) {
                        params[subkey] = par[subkey];
                    }
                }
                // this.paper.canvas.style.display = "none";
                if (params.text && this.type == "text") {
                    this.textpath.string = params.text;
                }
                setFillAndStroke(this, params);
                // this.paper.canvas.style.display = E;
            }
            return this;
        };
        elproto.toFront = function () {
            !this.removed && this.node.parentNode.appendChild(this.node);
            this.paper && this.paper.top != this && R._tofront(this, this.paper);
            return this;
        };
        elproto.toBack = function () {
            if (this.removed) {
                return this;
            }
            if (this.node.parentNode.firstChild != this.node) {
                this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
                R._toback(this, this.paper);
            }
            return this;
        };
        elproto.insertAfter = function (element) {
            if (this.removed) {
                return this;
            }
            if (element.constructor == R.st.constructor) {
                element = element[element.length - 1];
            }
            if (element.node.nextSibling) {
                element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
            } else {
                element.node.parentNode.appendChild(this.node);
            }
            R._insertafter(this, element, this.paper);
            return this;
        };
        elproto.insertBefore = function (element) {
            if (this.removed) {
                return this;
            }
            if (element.constructor == R.st.constructor) {
                element = element[0];
            }
            element.node.parentNode.insertBefore(this.node, element.node);
            R._insertbefore(this, element, this.paper);
            return this;
        };
        elproto.blur = function (size) {
            var s = this.node.runtimeStyle,
                f = s.filter;
            f = f.replace(blurregexp, E);
            if (+size !== 0) {
                this.attrs.blur = size;
                s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
                s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
            } else {
                s.filter = f;
                s.margin = 0;
                delete this.attrs.blur;
            }
            return this;
        };

        R._engine.path = function (pathString, vml) {
            var el = createNode("shape");
            el.style.cssText = cssDot;
            el.coordsize = zoom + S + zoom;
            el.coordorigin = vml.coordorigin;
            var p = new Element(el, vml),
                attr = { fill: "none", stroke: "#000" };
            pathString && (attr.path = pathString);
            p.type = "path";
            p.path = [];
            p.Path = E;
            setFillAndStroke(p, attr);
            vml.canvas.appendChild(el);
            var skew = createNode("skew");
            skew.on = true;
            el.appendChild(skew);
            p.skew = skew;
            p.transform(E);
            return p;
        };
        R._engine.rect = function (vml, x, y, w, h, r) {
            var path = R._rectPath(x, y, w, h, r),
                res = vml.path(path),
                a = res.attrs;
            res.X = a.x = x;
            res.Y = a.y = y;
            res.W = a.width = w;
            res.H = a.height = h;
            a.r = r;
            a.path = path;
            res.type = "rect";
            return res;
        };
        R._engine.ellipse = function (vml, x, y, rx, ry) {
            var res = vml.path(),
                a = res.attrs;
            res.X = x - rx;
            res.Y = y - ry;
            res.W = rx * 2;
            res.H = ry * 2;
            res.type = "ellipse";
            setFillAndStroke(res, {
                cx: x,
                cy: y,
                rx: rx,
                ry: ry
            });
            return res;
        };
        R._engine.circle = function (vml, x, y, r) {
            var res = vml.path(),
                a = res.attrs;
            res.X = x - r;
            res.Y = y - r;
            res.W = res.H = r * 2;
            res.type = "circle";
            setFillAndStroke(res, {
                cx: x,
                cy: y,
                r: r
            });
            return res;
        };
        R._engine.image = function (vml, src, x, y, w, h) {
            var path = R._rectPath(x, y, w, h),
                res = vml.path(path).attr({ stroke: "none" }),
                a = res.attrs,
                node = res.node,
                fill = node.getElementsByTagName(fillString)[0];
            a.src = src;
            res.X = a.x = x;
            res.Y = a.y = y;
            res.W = a.width = w;
            res.H = a.height = h;
            a.path = path;
            res.type = "image";
            fill.parentNode == node && node.removeChild(fill);
            fill.rotate = true;
            fill.src = src;
            fill.type = "tile";
            res._.fillpos = [x, y];
            res._.fillsize = [w, h];
            node.appendChild(fill);
            setCoords(res, 1, 1, 0, 0, 0);
            return res;
        };
        R._engine.text = function (vml, x, y, text) {
            var el = createNode("shape"),
                path = createNode("path"),
                o = createNode("textpath");
            x = x || 0;
            y = y || 0;
            text = text || "";
            path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
            path.textpathok = true;
            o.string = Str(text);
            o.on = true;
            el.style.cssText = cssDot;
            el.coordsize = zoom + S + zoom;
            el.coordorigin = "0 0";
            var p = new Element(el, vml),
                attr = {
                    fill: "#000",
                    stroke: "none",
                    font: R._availableAttrs.font,
                    text: text
                };
            p.shape = el;
            p.path = path;
            p.textpath = o;
            p.type = "text";
            p.attrs.text = Str(text);
            p.attrs.x = x;
            p.attrs.y = y;
            p.attrs.w = 1;
            p.attrs.h = 1;
            setFillAndStroke(p, attr);
            el.appendChild(o);
            el.appendChild(path);
            vml.canvas.appendChild(el);
            var skew = createNode("skew");
            skew.on = true;
            el.appendChild(skew);
            p.skew = skew;
            p.transform(E);
            return p;
        };
        R._engine.setSize = function (width, height) {
            var cs = this.canvas.style;
            this.width = width;
            this.height = height;
            width == +width && (width += "px");
            height == +height && (height += "px");
            cs.width = width;
            cs.height = height;
            cs.clip = "rect(0 " + width + " " + height + " 0)";
            if (this._viewBox) {
                R._engine.setViewBox.apply(this, this._viewBox);
            }
            return this;
        };
        R._engine.setViewBox = function (x, y, w, h, fit) {
            R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
            var width = this.width,
                height = this.height,
                size = 1 / mmax(w / width, h / height),
                H, W;
            if (fit) {
                H = height / h;
                W = width / w;
                if (w * H < width) {
                    x -= (width - w * H) / 2 / H;
                }
                if (h * W < height) {
                    y -= (height - h * W) / 2 / W;
                }
            }
            this._viewBox = [x, y, w, h, !!fit];
            this._viewBoxShift = {
                dx: -x,
                dy: -y,
                scale: size
            };
            this.forEach(function (el) {
                el.transform("...");
            });
            return this;
        };
        var createNode;
        R._engine.initWin = function (win) {
            var doc = win.document;
            doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
            try {
                !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                createNode = function (tagName) {
                    return doc.createElement('<rvml:' + tagName + ' class="rvml">');
                };
            } catch (e) {
                createNode = function (tagName) {
                    return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                };
            }
        };
        R._engine.initWin(R._g.win);
        R._engine.create = function () {
            var con = R._getContainer.apply(0, arguments),
                container = con.container,
                height = con.height,
                s,
                width = con.width,
                x = con.x,
                y = con.y;
            if (!container) {
                throw new Error("VML container not found.");
            }
            var res = new R._Paper,
                c = res.canvas = R._g.doc.createElement("div"),
                cs = c.style;
            x = x || 0;
            y = y || 0;
            width = width || 512;
            height = height || 342;
            res.width = width;
            res.height = height;
            width == +width && (width += "px");
            height == +height && (height += "px");
            res.coordsize = zoom * 1e3 + S + zoom * 1e3;
            res.coordorigin = "0 0";
            res.span = R._g.doc.createElement("span");
            res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
            c.appendChild(res.span);
            cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
            if (container == 1) {
                R._g.doc.body.appendChild(c);
                cs.left = x + "px";
                cs.top = y + "px";
                cs.position = "absolute";
            } else {
                if (container.firstChild) {
                    container.insertBefore(c, container.firstChild);
                } else {
                    container.appendChild(c);
                }
            }
            res.renderfix = function () { };
            return res;
        };
        R.prototype.clear = function () {
            R.eve("raphael.clear", this);
            this.canvas.innerHTML = E;
            this.span = R._g.doc.createElement("span");
            this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
            this.canvas.appendChild(this.span);
            this.bottom = this.top = null;
        };
        R.prototype.remove = function () {
            R.eve("raphael.remove", this);
            this.canvas.parentNode.removeChild(this.canvas);
            for (var i in this) {
                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
            }
            return true;
        };

        var setproto = R.st;
        for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
            setproto[method] = (function (methodname) {
                return function () {
                    var arg = arguments;
                    return this.forEach(function (el) {
                        el[methodname].apply(el, arg);
                    });
                };
            })(method);
        }
    })();

    // EXPOSE
    // SVG and VML are appended just before the EXPOSE line
    // Even with AMD, Raphael should be defined globally
    oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

    return R;
}));

/*!
* @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.
* @version 3.0.16
* https://svgdotjs.github.io/
*
* @copyright Wout Fierens <wout@mick-wout.com>
* @license MIT
*
* BUILT: Tue Nov 12 2019 21:57:16 GMT+0100 (GMT+01:00)
*/;
var SVG = (function () {
    'use strict';

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var check = function (it) {
        return it && it.Math == Math && it;
    };

    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    var global_1 =
        // eslint-disable-next-line no-undef
        check(typeof globalThis == 'object' && globalThis) ||
        check(typeof window == 'object' && window) ||
        check(typeof self == 'object' && self) ||
        check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
        // eslint-disable-next-line no-new-func
        Function('return this')();

    var fails = function (exec) {
        try {
            return !!exec();
        } catch (error) {
            return true;
        }
    };

    // Thank's IE8 for his funny defineProperty
    var descriptors = !fails(function () {
        return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
    });

    var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

    // Nashorn ~ JDK8 bug
    var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

    // `Object.prototype.propertyIsEnumerable` method implementation
    // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
    var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
        var descriptor = getOwnPropertyDescriptor(this, V);
        return !!descriptor && descriptor.enumerable;
    } : nativePropertyIsEnumerable;

    var objectPropertyIsEnumerable = {
        f: f
    };

    var createPropertyDescriptor = function (bitmap, value) {
        return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
        };
    };

    var toString = {}.toString;

    var classofRaw = function (it) {
        return toString.call(it).slice(8, -1);
    };

    var split = ''.split;

    // fallback for non-array-like ES3 and non-enumerable old V8 strings
    var indexedObject = fails(function () {
        // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
        // eslint-disable-next-line no-prototype-builtins
        return !Object('z').propertyIsEnumerable(0);
    }) ? function (it) {
        return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
    } : Object;

    // `RequireObjectCoercible` abstract operation
    // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
    var requireObjectCoercible = function (it) {
        if (it == undefined) throw TypeError("Can't call method on " + it);
        return it;
    };

    // toObject with fallback for non-array-like ES3 strings



    var toIndexedObject = function (it) {
        return indexedObject(requireObjectCoercible(it));
    };

    var isObject = function (it) {
        return typeof it === 'object' ? it !== null : typeof it === 'function';
    };

    // `ToPrimitive` abstract operation
    // https://tc39.github.io/ecma262/#sec-toprimitive
    // instead of the ES6 spec version, we didn't implement @@toPrimitive case
    // and the second argument - flag - preferred type is a string
    var toPrimitive = function (input, PREFERRED_STRING) {
        if (!isObject(input)) return input;
        var fn, val;
        if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
        if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
        if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
        throw TypeError("Can't convert object to primitive value");
    };

    var hasOwnProperty = {}.hasOwnProperty;

    var has = function (it, key) {
        return hasOwnProperty.call(it, key);
    };

    var document$1 = global_1.document;
    // typeof document.createElement is 'object' in old IE
    var EXISTS = isObject(document$1) && isObject(document$1.createElement);

    var documentCreateElement = function (it) {
        return EXISTS ? document$1.createElement(it) : {};
    };

    // Thank's IE8 for his funny defineProperty
    var ie8DomDefine = !descriptors && !fails(function () {
        return Object.defineProperty(documentCreateElement('div'), 'a', {
            get: function () { return 7; }
        }).a != 7;
    });

    var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
    var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
        O = toIndexedObject(O);
        P = toPrimitive(P, true);
        if (ie8DomDefine) try {
            return nativeGetOwnPropertyDescriptor(O, P);
        } catch (error) { /* empty */ }
        if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
    };

    var objectGetOwnPropertyDescriptor = {
        f: f$1
    };

    var anObject = function (it) {
        if (!isObject(it)) {
            throw TypeError(String(it) + ' is not an object');
        } return it;
    };

    var nativeDefineProperty = Object.defineProperty;

    // `Object.defineProperty` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperty
    var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (ie8DomDefine) try {
            return nativeDefineProperty(O, P, Attributes);
        } catch (error) { /* empty */ }
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
    };

    var objectDefineProperty = {
        f: f$2
    };

    var createNonEnumerableProperty = descriptors ? function (object, key, value) {
        return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
    } : function (object, key, value) {
        object[key] = value;
        return object;
    };

    var setGlobal = function (key, value) {
        try {
            createNonEnumerableProperty(global_1, key, value);
        } catch (error) {
            global_1[key] = value;
        } return value;
    };

    var SHARED = '__core-js_shared__';
    var store = global_1[SHARED] || setGlobal(SHARED, {});

    var sharedStore = store;

    var shared = createCommonjsModule(function (module) {
        (module.exports = function (key, value) {
            return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
        })('versions', []).push({
            version: '3.3.6',
            mode: 'global',
            copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
        });
    });

    var functionToString = shared('native-function-to-string', Function.toString);

    var WeakMap = global_1.WeakMap;

    var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(functionToString.call(WeakMap));

    var id = 0;
    var postfix = Math.random();

    var uid = function (key) {
        return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
    };

    var keys = shared('keys');

    var sharedKey = function (key) {
        return keys[key] || (keys[key] = uid(key));
    };

    var hiddenKeys = {};

    var WeakMap$1 = global_1.WeakMap;
    var set, get, has$1;

    var enforce = function (it) {
        return has$1(it) ? get(it) : set(it, {});
    };

    var getterFor = function (TYPE) {
        return function (it) {
            var state;
            if (!isObject(it) || (state = get(it)).type !== TYPE) {
                throw TypeError('Incompatible receiver, ' + TYPE + ' required');
            } return state;
        };
    };

    if (nativeWeakMap) {
        var store$1 = new WeakMap$1();
        var wmget = store$1.get;
        var wmhas = store$1.has;
        var wmset = store$1.set;
        set = function (it, metadata) {
            wmset.call(store$1, it, metadata);
            return metadata;
        };
        get = function (it) {
            return wmget.call(store$1, it) || {};
        };
        has$1 = function (it) {
            return wmhas.call(store$1, it);
        };
    } else {
        var STATE = sharedKey('state');
        hiddenKeys[STATE] = true;
        set = function (it, metadata) {
            createNonEnumerableProperty(it, STATE, metadata);
            return metadata;
        };
        get = function (it) {
            return has(it, STATE) ? it[STATE] : {};
        };
        has$1 = function (it) {
            return has(it, STATE);
        };
    }

    var internalState = {
        set: set,
        get: get,
        has: has$1,
        enforce: enforce,
        getterFor: getterFor
    };

    var redefine = createCommonjsModule(function (module) {
        var getInternalState = internalState.get;
        var enforceInternalState = internalState.enforce;
        var TEMPLATE = String(functionToString).split('toString');

        shared('inspectSource', function (it) {
            return functionToString.call(it);
        });

        (module.exports = function (O, key, value, options) {
            var unsafe = options ? !!options.unsafe : false;
            var simple = options ? !!options.enumerable : false;
            var noTargetGet = options ? !!options.noTargetGet : false;
            if (typeof value == 'function') {
                if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
                enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
            }
            if (O === global_1) {
                if (simple) O[key] = value;
                else setGlobal(key, value);
                return;
            } else if (!unsafe) {
                delete O[key];
            } else if (!noTargetGet && O[key]) {
                simple = true;
            }
            if (simple) O[key] = value;
            else createNonEnumerableProperty(O, key, value);
            // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
        })(Function.prototype, 'toString', function toString() {
            return typeof this == 'function' && getInternalState(this).source || functionToString.call(this);
        });
    });

    var path = global_1;

    var aFunction = function (variable) {
        return typeof variable == 'function' ? variable : undefined;
    };

    var getBuiltIn = function (namespace, method) {
        return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
            : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
    };

    var ceil = Math.ceil;
    var floor = Math.floor;

    // `ToInteger` abstract operation
    // https://tc39.github.io/ecma262/#sec-tointeger
    var toInteger = function (argument) {
        return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
    };

    var min = Math.min;

    // `ToLength` abstract operation
    // https://tc39.github.io/ecma262/#sec-tolength
    var toLength = function (argument) {
        return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
    };

    var max = Math.max;
    var min$1 = Math.min;

    // Helper for a popular repeating case of the spec:
    // Let integer be ? ToInteger(index).
    // If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).
    var toAbsoluteIndex = function (index, length) {
        var integer = toInteger(index);
        return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
    };

    // `Array.prototype.{ indexOf, includes }` methods implementation
    var createMethod = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
            var O = toIndexedObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare
            if (IS_INCLUDES && el != el) while (length > index) {
                value = O[index++];
                // eslint-disable-next-line no-self-compare
                if (value != value) return true;
                // Array#indexOf ignores holes, Array#includes - not
            } else for (; length > index; index++) {
                if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
            } return !IS_INCLUDES && -1;
        };
    };

    var arrayIncludes = {
        // `Array.prototype.includes` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false)
    };

    var indexOf = arrayIncludes.indexOf;


    var objectKeysInternal = function (object, names) {
        var O = toIndexedObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
        // Don't enum bug & hidden keys
        while (names.length > i) if (has(O, key = names[i++])) {
            ~indexOf(result, key) || result.push(key);
        }
        return result;
    };

    // IE8- don't enum bug keys
    var enumBugKeys = [
        'constructor',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'toLocaleString',
        'toString',
        'valueOf'
    ];

    var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

    // `Object.getOwnPropertyNames` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
    var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return objectKeysInternal(O, hiddenKeys$1);
    };

    var objectGetOwnPropertyNames = {
        f: f$3
    };

    var f$4 = Object.getOwnPropertySymbols;

    var objectGetOwnPropertySymbols = {
        f: f$4
    };

    // all object keys, includes non-enumerable and symbols
    var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
        var keys = objectGetOwnPropertyNames.f(anObject(it));
        var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
        return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
    };

    var copyConstructorProperties = function (target, source) {
        var keys = ownKeys(source);
        var defineProperty = objectDefineProperty.f;
        var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
    };

    var replacement = /#|\.prototype\./;

    var isForced = function (feature, detection) {
        var value = data[normalize(feature)];
        return value == POLYFILL ? true
            : value == NATIVE ? false
                : typeof detection == 'function' ? fails(detection)
                    : !!detection;
    };

    var normalize = isForced.normalize = function (string) {
        return String(string).replace(replacement, '.').toLowerCase();
    };

    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = 'N';
    var POLYFILL = isForced.POLYFILL = 'P';

    var isForced_1 = isForced;

    var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






    /*
      options.target      - name of the target object
      options.global      - target is the global object
      options.stat        - export as static methods of target
      options.proto       - export as prototype methods of target
      options.real        - real prototype method for the `pure` version
      options.forced      - export even if the native feature is available
      options.bind        - bind methods to the target, required for the `pure` version
      options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
      options.unsafe      - use the simple assignment of property instead of delete + defineProperty
      options.sham        - add a flag to not completely full polyfills
      options.enumerable  - export as enumerable property
      options.noTargetGet - prevent calling a getter on target
    */
    var _export = function (options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
            target = global_1;
        } else if (STATIC) {
            target = global_1[TARGET] || setGlobal(TARGET, {});
        } else {
            target = (global_1[TARGET] || {}).prototype;
        }
        if (target) for (key in source) {
            sourceProperty = source[key];
            if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor$1(target, key);
                targetProperty = descriptor && descriptor.value;
            } else targetProperty = target[key];
            FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
            // contained in target
            if (!FORCED && targetProperty !== undefined) {
                if (typeof sourceProperty === typeof targetProperty) continue;
                copyConstructorProperties(sourceProperty, targetProperty);
            }
            // add a flag to not completely full polyfills
            if (options.sham || (targetProperty && targetProperty.sham)) {
                createNonEnumerableProperty(sourceProperty, 'sham', true);
            }
            // extend global
            redefine(target, key, sourceProperty, options);
        }
    };

    // `Object.keys` method
    // https://tc39.github.io/ecma262/#sec-object.keys
    var objectKeys = Object.keys || function keys(O) {
        return objectKeysInternal(O, enumBugKeys);
    };

    // `ToObject` abstract operation
    // https://tc39.github.io/ecma262/#sec-toobject
    var toObject = function (argument) {
        return Object(requireObjectCoercible(argument));
    };

    var nativeAssign = Object.assign;

    // `Object.assign` method
    // https://tc39.github.io/ecma262/#sec-object.assign
    // should work with symbols and should have deterministic property order (V8 bug)
    var objectAssign = !nativeAssign || fails(function () {
        var A = {};
        var B = {};
        // eslint-disable-next-line no-undef
        var symbol = Symbol();
        var alphabet = 'abcdefghijklmnopqrst';
        A[symbol] = 7;
        alphabet.split('').forEach(function (chr) { B[chr] = chr; });
        return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
    }) ? function assign(target, source) { // eslint-disable-line no-unused-vars
        var T = toObject(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
        var propertyIsEnumerable = objectPropertyIsEnumerable.f;
        while (argumentsLength > index) {
            var S = indexedObject(arguments[index++]);
            var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
            var length = keys.length;
            var j = 0;
            var key;
            while (length > j) {
                key = keys[j++];
                if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
            }
        } return T;
    } : nativeAssign;

    // `Object.assign` method
    // https://tc39.github.io/ecma262/#sec-object.assign
    _export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
        assign: objectAssign
    });

    // `IsArray` abstract operation
    // https://tc39.github.io/ecma262/#sec-isarray
    var isArray = Array.isArray || function isArray(arg) {
        return classofRaw(arg) == 'Array';
    };

    var createProperty = function (object, key, value) {
        var propertyKey = toPrimitive(key);
        if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
        else object[propertyKey] = value;
    };

    var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
        // Chrome 38 Symbol has incorrect toString conversion
        // eslint-disable-next-line no-undef
        return !String(Symbol());
    });

    var Symbol$1 = global_1.Symbol;
    var store$2 = shared('wks');

    var wellKnownSymbol = function (name) {
        return store$2[name] || (store$2[name] = nativeSymbol && Symbol$1[name]
            || (nativeSymbol ? Symbol$1 : uid)('Symbol.' + name));
    };

    var userAgent = getBuiltIn('navigator', 'userAgent') || '';

    var process = global_1.process;
    var versions = process && process.versions;
    var v8 = versions && versions.v8;
    var match, version;

    if (v8) {
        match = v8.split('.');
        version = match[0] + match[1];
    } else if (userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
            match = userAgent.match(/Chrome\/(\d+)/);
            if (match) version = match[1];
        }
    }

    var v8Version = version && +version;

    var SPECIES = wellKnownSymbol('species');

    var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
        // We can't use this feature detection in V8 since it causes
        // deoptimization and serious performance degradation
        // https://github.com/zloirock/core-js/issues/677
        return v8Version >= 51 || !fails(function () {
            var array = [];
            var constructor = array.constructor = {};
            constructor[SPECIES] = function () {
                return { foo: 1 };
            };
            return array[METHOD_NAME](Boolean).foo !== 1;
        });
    };

    var SPECIES$1 = wellKnownSymbol('species');
    var nativeSlice = [].slice;
    var max$1 = Math.max;

    // `Array.prototype.slice` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.slice
    // fallback for not array-like ES3 strings and DOM objects
    _export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('slice') }, {
        slice: function slice(start, end) {
            var O = toIndexedObject(this);
            var length = toLength(O.length);
            var k = toAbsoluteIndex(start, length);
            var fin = toAbsoluteIndex(end === undefined ? length : end, length);
            // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
            var Constructor, result, n;
            if (isArray(O)) {
                Constructor = O.constructor;
                // cross-realm fallback
                if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
                    Constructor = undefined;
                } else if (isObject(Constructor)) {
                    Constructor = Constructor[SPECIES$1];
                    if (Constructor === null) Constructor = undefined;
                }
                if (Constructor === Array || Constructor === undefined) {
                    return nativeSlice.call(O, k, fin);
                }
            }
            result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
            for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
            result.length = n;
            return result;
        }
    });

    var defineProperty = objectDefineProperty.f;

    var FunctionPrototype = Function.prototype;
    var FunctionPrototypeToString = FunctionPrototype.toString;
    var nameRE = /^\s*function ([^ (]*)/;
    var NAME = 'name';

    // Function instances `.name` property
    // https://tc39.github.io/ecma262/#sec-function-instances-name
    if (descriptors && !(NAME in FunctionPrototype)) {
        defineProperty(FunctionPrototype, NAME, {
            configurable: true,
            get: function () {
                try {
                    return FunctionPrototypeToString.call(this).match(nameRE)[1];
                } catch (error) {
                    return '';
                }
            }
        });
    }

    var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

    var toString$1 = {}.toString;

    var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
        ? Object.getOwnPropertyNames(window) : [];

    var getWindowNames = function (it) {
        try {
            return nativeGetOwnPropertyNames(it);
        } catch (error) {
            return windowNames.slice();
        }
    };

    // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
    var f$5 = function getOwnPropertyNames(it) {
        return windowNames && toString$1.call(it) == '[object Window]'
            ? getWindowNames(it)
            : nativeGetOwnPropertyNames(toIndexedObject(it));
    };

    var objectGetOwnPropertyNamesExternal = {
        f: f$5
    };

    var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;

    var FAILS_ON_PRIMITIVES = fails(function () { return !Object.getOwnPropertyNames(1); });

    // `Object.getOwnPropertyNames` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
    _export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
        getOwnPropertyNames: nativeGetOwnPropertyNames$1
    });

    function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

    function _typeof(obj) {
        if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
            _typeof = function _typeof(obj) {
                return _typeof2(obj);
            };
        } else {
            _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
            };
        }

        return _typeof(obj);
    }

    // `Object.defineProperties` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperties
    var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = objectKeys(Properties);
        var length = keys.length;
        var index = 0;
        var key;
        while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
        return O;
    };

    var html = getBuiltIn('document', 'documentElement');

    var IE_PROTO = sharedKey('IE_PROTO');

    var PROTOTYPE = 'prototype';
    var Empty = function () { /* empty */ };

    // Create object with fake `null` prototype: use iframe Object with cleared prototype
    var createDict = function () {
        // Thrash, waste and sodomy: IE GC bug
        var iframe = documentCreateElement('iframe');
        var length = enumBugKeys.length;
        var lt = '<';
        var script = 'script';
        var gt = '>';
        var js = 'java' + script + ':';
        var iframeDocument;
        iframe.style.display = 'none';
        html.appendChild(iframe);
        iframe.src = String(js);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
        iframeDocument.close();
        createDict = iframeDocument.F;
        while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
        return createDict();
    };

    // `Object.create` method
    // https://tc39.github.io/ecma262/#sec-object.create
    var objectCreate = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
            Empty[PROTOTYPE] = anObject(O);
            result = new Empty();
            Empty[PROTOTYPE] = null;
            // add "__proto__" for Object.getPrototypeOf polyfill
            result[IE_PROTO] = O;
        } else result = createDict();
        return Properties === undefined ? result : objectDefineProperties(result, Properties);
    };

    hiddenKeys[IE_PROTO] = true;

    var f$6 = wellKnownSymbol;

    var wrappedWellKnownSymbol = {
        f: f$6
    };

    var defineProperty$1 = objectDefineProperty.f;

    var defineWellKnownSymbol = function (NAME) {
        var Symbol = path.Symbol || (path.Symbol = {});
        if (!has(Symbol, NAME)) defineProperty$1(Symbol, NAME, {
            value: wrappedWellKnownSymbol.f(NAME)
        });
    };

    var defineProperty$2 = objectDefineProperty.f;



    var TO_STRING_TAG = wellKnownSymbol('toStringTag');

    var setToStringTag = function (it, TAG, STATIC) {
        if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
            defineProperty$2(it, TO_STRING_TAG, { configurable: true, value: TAG });
        }
    };

    var aFunction$1 = function (it) {
        if (typeof it != 'function') {
            throw TypeError(String(it) + ' is not a function');
        } return it;
    };

    // optional / simple context binding
    var bindContext = function (fn, that, length) {
        aFunction$1(fn);
        if (that === undefined) return fn;
        switch (length) {
            case 0: return function () {
                return fn.call(that);
            };
            case 1: return function (a) {
                return fn.call(that, a);
            };
            case 2: return function (a, b) {
                return fn.call(that, a, b);
            };
            case 3: return function (a, b, c) {
                return fn.call(that, a, b, c);
            };
        }
        return function (/* ...args */) {
            return fn.apply(that, arguments);
        };
    };

    var SPECIES$2 = wellKnownSymbol('species');

    // `ArraySpeciesCreate` abstract operation
    // https://tc39.github.io/ecma262/#sec-arrayspeciescreate
    var arraySpeciesCreate = function (originalArray, length) {
        var C;
        if (isArray(originalArray)) {
            C = originalArray.constructor;
            // cross-realm fallback
            if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
            else if (isObject(C)) {
                C = C[SPECIES$2];
                if (C === null) C = undefined;
            }
        } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
    };

    var push = [].push;

    // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
    var createMethod$1 = function (TYPE) {
        var IS_MAP = TYPE == 1;
        var IS_FILTER = TYPE == 2;
        var IS_SOME = TYPE == 3;
        var IS_EVERY = TYPE == 4;
        var IS_FIND_INDEX = TYPE == 6;
        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
        return function ($this, callbackfn, that, specificCreate) {
            var O = toObject($this);
            var self = indexedObject(O);
            var boundFunction = bindContext(callbackfn, that, 3);
            var length = toLength(self.length);
            var index = 0;
            var create = specificCreate || arraySpeciesCreate;
            var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
            var value, result;
            for (; length > index; index++) if (NO_HOLES || index in self) {
                value = self[index];
                result = boundFunction(value, index, O);
                if (TYPE) {
                    if (IS_MAP) target[index] = result; // map
                    else if (result) switch (TYPE) {
                        case 3: return true;              // some
                        case 5: return value;             // find
                        case 6: return index;             // findIndex
                        case 2: push.call(target, value); // filter
                    } else if (IS_EVERY) return false;  // every
                }
            }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
    };

    var arrayIteration = {
        // `Array.prototype.forEach` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
        forEach: createMethod$1(0),
        // `Array.prototype.map` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.map
        map: createMethod$1(1),
        // `Array.prototype.filter` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.filter
        filter: createMethod$1(2),
        // `Array.prototype.some` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.some
        some: createMethod$1(3),
        // `Array.prototype.every` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.every
        every: createMethod$1(4),
        // `Array.prototype.find` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.find
        find: createMethod$1(5),
        // `Array.prototype.findIndex` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod$1(6)
    };

    var $forEach = arrayIteration.forEach;

    var HIDDEN = sharedKey('hidden');
    var SYMBOL = 'Symbol';
    var PROTOTYPE$1 = 'prototype';
    var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
    var setInternalState = internalState.set;
    var getInternalState = internalState.getterFor(SYMBOL);
    var ObjectPrototype = Object[PROTOTYPE$1];
    var $Symbol = global_1.Symbol;
    var JSON$1 = global_1.JSON;
    var nativeJSONStringify = JSON$1 && JSON$1.stringify;
    var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
    var nativeDefineProperty$1 = objectDefineProperty.f;
    var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;
    var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
    var AllSymbols = shared('symbols');
    var ObjectPrototypeSymbols = shared('op-symbols');
    var StringToSymbolRegistry = shared('string-to-symbol-registry');
    var SymbolToStringRegistry = shared('symbol-to-string-registry');
    var WellKnownSymbolsStore = shared('wks');
    var QObject = global_1.QObject;
    // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
    var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

    // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
    var setSymbolDescriptor = descriptors && fails(function () {
        return objectCreate(nativeDefineProperty$1({}, 'a', {
            get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
        })).a != 7;
    }) ? function (O, P, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
        if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
        nativeDefineProperty$1(O, P, Attributes);
        if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
            nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
        }
    } : nativeDefineProperty$1;

    var wrap = function (tag, description) {
        var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
        setInternalState(symbol, {
            type: SYMBOL,
            tag: tag,
            description: description
        });
        if (!descriptors) symbol.description = description;
        return symbol;
    };

    var isSymbol = nativeSymbol && typeof $Symbol.iterator == 'symbol' ? function (it) {
        return typeof it == 'symbol';
    } : function (it) {
        return Object(it) instanceof $Symbol;
    };

    var $defineProperty = function defineProperty(O, P, Attributes) {
        if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
        anObject(O);
        var key = toPrimitive(P, true);
        anObject(Attributes);
        if (has(AllSymbols, key)) {
            if (!Attributes.enumerable) {
                if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
                O[HIDDEN][key] = true;
            } else {
                if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
                Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
            } return setSymbolDescriptor(O, key, Attributes);
        } return nativeDefineProperty$1(O, key, Attributes);
    };

    var $defineProperties = function defineProperties(O, Properties) {
        anObject(O);
        var properties = toIndexedObject(Properties);
        var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach(keys, function (key) {
            if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
        });
        return O;
    };

    var $create = function create(O, Properties) {
        return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
    };

    var $propertyIsEnumerable = function propertyIsEnumerable(V) {
        var P = toPrimitive(V, true);
        var enumerable = nativePropertyIsEnumerable$1.call(this, P);
        if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
        return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
    };

    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
        var it = toIndexedObject(O);
        var key = toPrimitive(P, true);
        if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
        var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
        if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
            descriptor.enumerable = true;
        }
        return descriptor;
    };

    var $getOwnPropertyNames = function getOwnPropertyNames(O) {
        var names = nativeGetOwnPropertyNames$2(toIndexedObject(O));
        var result = [];
        $forEach(names, function (key) {
            if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
        });
        return result;
    };

    var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
        var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
        var names = nativeGetOwnPropertyNames$2(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
        var result = [];
        $forEach(names, function (key) {
            if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
                result.push(AllSymbols[key]);
            }
        });
        return result;
    };

    // `Symbol` constructor
    // https://tc39.github.io/ecma262/#sec-symbol-constructor
    if (!nativeSymbol) {
        $Symbol = function Symbol() {
            if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
            var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
            var tag = uid(description);
            var setter = function (value) {
                if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
                if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
            };
            if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
            return wrap(tag, description);
        };

        redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
            return getInternalState(this).tag;
        });

        objectPropertyIsEnumerable.f = $propertyIsEnumerable;
        objectDefineProperty.f = $defineProperty;
        objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
        objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
        objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

        if (descriptors) {
            // https://github.com/tc39/proposal-Symbol-description
            nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
                configurable: true,
                get: function description() {
                    return getInternalState(this).description;
                }
            });
            {
                redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
            }
        }

        wrappedWellKnownSymbol.f = function (name) {
            return wrap(wellKnownSymbol(name), name);
        };
    }

    _export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
        Symbol: $Symbol
    });

    $forEach(objectKeys(WellKnownSymbolsStore), function (name) {
        defineWellKnownSymbol(name);
    });

    _export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
        // `Symbol.for` method
        // https://tc39.github.io/ecma262/#sec-symbol.for
        'for': function (key) {
            var string = String(key);
            if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
            var symbol = $Symbol(string);
            StringToSymbolRegistry[string] = symbol;
            SymbolToStringRegistry[symbol] = string;
            return symbol;
        },
        // `Symbol.keyFor` method
        // https://tc39.github.io/ecma262/#sec-symbol.keyfor
        keyFor: function keyFor(sym) {
            if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
            if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
        },
        useSetter: function () { USE_SETTER = true; },
        useSimple: function () { USE_SETTER = false; }
    });

    _export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
        // `Object.create` method
        // https://tc39.github.io/ecma262/#sec-object.create
        create: $create,
        // `Object.defineProperty` method
        // https://tc39.github.io/ecma262/#sec-object.defineproperty
        defineProperty: $defineProperty,
        // `Object.defineProperties` method
        // https://tc39.github.io/ecma262/#sec-object.defineproperties
        defineProperties: $defineProperties,
        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor
    });

    _export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
        // `Object.getOwnPropertyNames` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
        getOwnPropertyNames: $getOwnPropertyNames,
        // `Object.getOwnPropertySymbols` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
        getOwnPropertySymbols: $getOwnPropertySymbols
    });

    // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
    // https://bugs.chromium.org/p/v8/issues/detail?id=3443
    _export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
        getOwnPropertySymbols: function getOwnPropertySymbols(it) {
            return objectGetOwnPropertySymbols.f(toObject(it));
        }
    });

    // `JSON.stringify` method behavior with symbols
    // https://tc39.github.io/ecma262/#sec-json.stringify
    JSON$1 && _export({
        target: 'JSON', stat: true, forced: !nativeSymbol || fails(function () {
            var symbol = $Symbol();
            // MS Edge converts symbol values to JSON as {}
            return nativeJSONStringify([symbol]) != '[null]'
                // WebKit converts symbol values to JSON as null
                || nativeJSONStringify({ a: symbol }) != '{}'
                // V8 throws on boxed symbols
                || nativeJSONStringify(Object(symbol)) != '{}';
        })
    }, {
        stringify: function stringify(it) {
            var args = [it];
            var index = 1;
            var replacer, $replacer;
            while (arguments.length > index) args.push(arguments[index++]);
            $replacer = replacer = args[1];
            if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
            if (!isArray(replacer)) replacer = function (key, value) {
                if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
                if (!isSymbol(value)) return value;
            };
            args[1] = replacer;
            return nativeJSONStringify.apply(JSON$1, args);
        }
    });

    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
    if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
        createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
    }
    // `Symbol.prototype[@@toStringTag]` property
    // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
    setToStringTag($Symbol, SYMBOL);

    hiddenKeys[HIDDEN] = true;

    var defineProperty$3 = objectDefineProperty.f;


    var NativeSymbol = global_1.Symbol;

    if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
        // Safari 12 bug
        NativeSymbol().description !== undefined
    )) {
        var EmptyStringDescriptionStore = {};
        // wrap Symbol constructor for correct work with undefined description
        var SymbolWrapper = function Symbol() {
            var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
            var result = this instanceof SymbolWrapper
                ? new NativeSymbol(description)
                // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
                : description === undefined ? NativeSymbol() : NativeSymbol(description);
            if (description === '') EmptyStringDescriptionStore[result] = true;
            return result;
        };
        copyConstructorProperties(SymbolWrapper, NativeSymbol);
        var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
        symbolPrototype.constructor = SymbolWrapper;

        var symbolToString = symbolPrototype.toString;
        var native = String(NativeSymbol('test')) == 'Symbol(test)';
        var regexp = /^Symbol\((.*)\)[^)]+$/;
        defineProperty$3(symbolPrototype, 'description', {
            configurable: true,
            get: function description() {
                var symbol = isObject(this) ? this.valueOf() : this;
                var string = symbolToString.call(symbol);
                if (has(EmptyStringDescriptionStore, symbol)) return '';
                var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
                return desc === '' ? undefined : desc;
            }
        });

        _export({ global: true, forced: true }, {
            Symbol: SymbolWrapper
        });
    }

    // `Symbol.iterator` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.iterator
    defineWellKnownSymbol('iterator');

    var UNSCOPABLES = wellKnownSymbol('unscopables');
    var ArrayPrototype = Array.prototype;

    // Array.prototype[@@unscopables]
    // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
    if (ArrayPrototype[UNSCOPABLES] == undefined) {
        createNonEnumerableProperty(ArrayPrototype, UNSCOPABLES, objectCreate(null));
    }

    // add a key to Array.prototype[@@unscopables]
    var addToUnscopables = function (key) {
        ArrayPrototype[UNSCOPABLES][key] = true;
    };

    var iterators = {};

    var correctPrototypeGetter = !fails(function () {
        function F() { /* empty */ }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
    });

    var IE_PROTO$1 = sharedKey('IE_PROTO');
    var ObjectPrototype$1 = Object.prototype;

    // `Object.getPrototypeOf` method
    // https://tc39.github.io/ecma262/#sec-object.getprototypeof
    var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
        O = toObject(O);
        if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
        if (typeof O.constructor == 'function' && O instanceof O.constructor) {
            return O.constructor.prototype;
        } return O instanceof Object ? ObjectPrototype$1 : null;
    };

    var ITERATOR = wellKnownSymbol('iterator');
    var BUGGY_SAFARI_ITERATORS = false;

    var returnThis = function () { return this; };

    // `%IteratorPrototype%` object
    // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
    var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

    if ([].keys) {
        arrayIterator = [].keys();
        // Safari 8 has buggy iterators w/o `next`
        if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
        else {
            PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
    }

    if (IteratorPrototype == undefined) IteratorPrototype = {};

    // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
    if (!has(IteratorPrototype, ITERATOR)) {
        createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
    }

    var iteratorsCore = {
        IteratorPrototype: IteratorPrototype,
        BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
    };

    var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





    var returnThis$1 = function () { return this; };

    var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
        var TO_STRING_TAG = NAME + ' Iterator';
        IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
        iterators[TO_STRING_TAG] = returnThis$1;
        return IteratorConstructor;
    };

    var aPossiblePrototype = function (it) {
        if (!isObject(it) && it !== null) {
            throw TypeError("Can't set " + String(it) + ' as a prototype');
        } return it;
    };

    // `Object.setPrototypeOf` method
    // https://tc39.github.io/ecma262/#sec-object.setprototypeof
    // Works with __proto__ only. Old v8 can't work with null proto objects.
    /* eslint-disable no-proto */
    var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
        var CORRECT_SETTER = false;
        var test = {};
        var setter;
        try {
            setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
            setter.call(test, []);
            CORRECT_SETTER = test instanceof Array;
        } catch (error) { /* empty */ }
        return function setPrototypeOf(O, proto) {
            anObject(O);
            aPossiblePrototype(proto);
            if (CORRECT_SETTER) setter.call(O, proto);
            else O.__proto__ = proto;
            return O;
        };
    }() : undefined);

    var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR$1 = wellKnownSymbol('iterator');
    var KEYS = 'keys';
    var VALUES = 'values';
    var ENTRIES = 'entries';

    var returnThis$2 = function () { return this; };

    var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);

        var getIterationMethod = function (KIND) {
            if (KIND === DEFAULT && defaultIterator) return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
            switch (KIND) {
                case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
                case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
                case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
            } return function () { return new IteratorConstructor(this); };
        };

        var TO_STRING_TAG = NAME + ' Iterator';
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR$1]
            || IterablePrototype['@@iterator']
            || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;

        // fix native
        if (anyNativeIterator) {
            CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
            if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
                if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
                    if (objectSetPrototypeOf) {
                        objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
                    } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
                        createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
                    }
                }
                // Set @@toStringTag to native iterators
                setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
            }
        }

        // fix Array#{values, @@iterator}.name in V8 / FF
        if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() { return nativeIterator.call(this); };
        }

        // define iterator
        if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
            createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
        }
        iterators[NAME] = defaultIterator;

        // export additional methods
        if (DEFAULT) {
            methods = {
                values: getIterationMethod(VALUES),
                keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                entries: getIterationMethod(ENTRIES)
            };
            if (FORCED) for (KEY in methods) {
                if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                    redefine(IterablePrototype, KEY, methods[KEY]);
                }
            } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
        }

        return methods;
    };

    var ARRAY_ITERATOR = 'Array Iterator';
    var setInternalState$1 = internalState.set;
    var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

    // `Array.prototype.entries` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.entries
    // `Array.prototype.keys` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.keys
    // `Array.prototype.values` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.values
    // `Array.prototype[@@iterator]` method
    // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
    // `CreateArrayIterator` internal method
    // https://tc39.github.io/ecma262/#sec-createarrayiterator
    var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
        setInternalState$1(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated), // target
            index: 0,                          // next index
            kind: kind                         // kind
        });
        // `%ArrayIteratorPrototype%.next` method
        // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
    }, function () {
        var state = getInternalState$1(this);
        var target = state.target;
        var kind = state.kind;
        var index = state.index++;
        if (!target || index >= target.length) {
            state.target = undefined;
            return { value: undefined, done: true };
        }
        if (kind == 'keys') return { value: index, done: false };
        if (kind == 'values') return { value: target[index], done: false };
        return { value: [index, target[index]], done: false };
    }, 'values');

    // argumentsList[@@iterator] is %ArrayProto_values%
    // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
    // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
    iterators.Arguments = iterators.Array;

    // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
    addToUnscopables('keys');
    addToUnscopables('values');
    addToUnscopables('entries');

    var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
    // ES3 wrong here
    var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

    // fallback for IE11 Script Access Denied error
    var tryGet = function (it, key) {
        try {
            return it[key];
        } catch (error) { /* empty */ }
    };

    // getting tag from ES6+ `Object.prototype.toString`
    var classof = function (it) {
        var O, tag, result;
        return it === undefined ? 'Undefined' : it === null ? 'Null'
            // @@toStringTag case
            : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag
                // builtinTag case
                : CORRECT_ARGUMENTS ? classofRaw(O)
                    // ES3 arguments fallback
                    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
    };

    var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
    var test = {};

    test[TO_STRING_TAG$2] = 'z';

    // `Object.prototype.toString` method implementation
    // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
    var objectToString = String(test) !== '[object z]' ? function toString() {
        return '[object ' + classof(this) + ']';
    } : test.toString;

    var ObjectPrototype$2 = Object.prototype;

    // `Object.prototype.toString` method
    // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
    if (objectToString !== ObjectPrototype$2.toString) {
        redefine(ObjectPrototype$2, 'toString', objectToString, { unsafe: true });
    }

    var freezing = !fails(function () {
        return Object.isExtensible(Object.preventExtensions({}));
    });

    var internalMetadata = createCommonjsModule(function (module) {
        var defineProperty = objectDefineProperty.f;



        var METADATA = uid('meta');
        var id = 0;

        var isExtensible = Object.isExtensible || function () {
            return true;
        };

        var setMetadata = function (it) {
            defineProperty(it, METADATA, {
                value: {
                    objectID: 'O' + ++id, // object ID
                    weakData: {}          // weak collections IDs
                }
            });
        };

        var fastKey = function (it, create) {
            // return a primitive with prefix
            if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
            if (!has(it, METADATA)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return 'F';
                // not necessary to add metadata
                if (!create) return 'E';
                // add missing metadata
                setMetadata(it);
                // return object ID
            } return it[METADATA].objectID;
        };

        var getWeakData = function (it, create) {
            if (!has(it, METADATA)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return true;
                // not necessary to add metadata
                if (!create) return false;
                // add missing metadata
                setMetadata(it);
                // return the store of weak collections IDs
            } return it[METADATA].weakData;
        };

        // add metadata on freeze-family methods calling
        var onFreeze = function (it) {
            if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
            return it;
        };

        var meta = module.exports = {
            REQUIRED: false,
            fastKey: fastKey,
            getWeakData: getWeakData,
            onFreeze: onFreeze
        };

        hiddenKeys[METADATA] = true;
    });

    var ITERATOR$2 = wellKnownSymbol('iterator');
    var ArrayPrototype$1 = Array.prototype;

    // check on default Array iterator
    var isArrayIteratorMethod = function (it) {
        return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);
    };

    var ITERATOR$3 = wellKnownSymbol('iterator');

    var getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR$3]
            || it['@@iterator']
            || iterators[classof(it)];
    };

    // call something on iterator step with safe closing on error
    var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
        try {
            return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
            // 7.4.6 IteratorClose(iterator, completion)
        } catch (error) {
            var returnMethod = iterator['return'];
            if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
            throw error;
        }
    };

    var iterate_1 = createCommonjsModule(function (module) {
        var Result = function (stopped, result) {
            this.stopped = stopped;
            this.result = result;
        };

        var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
            var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);
            var iterator, iterFn, index, length, result, next, step;

            if (IS_ITERATOR) {
                iterator = iterable;
            } else {
                iterFn = getIteratorMethod(iterable);
                if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
                // optimisation for array iterators
                if (isArrayIteratorMethod(iterFn)) {
                    for (index = 0, length = toLength(iterable.length); length > index; index++) {
                        result = AS_ENTRIES
                            ? boundFunction(anObject(step = iterable[index])[0], step[1])
                            : boundFunction(iterable[index]);
                        if (result && result instanceof Result) return result;
                    } return new Result(false);
                }
                iterator = iterFn.call(iterable);
            }

            next = iterator.next;
            while (!(step = next.call(iterator)).done) {
                result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
                if (typeof result == 'object' && result && result instanceof Result) return result;
            } return new Result(false);
        };

        iterate.stop = function (result) {
            return new Result(true, result);
        };
    });

    var anInstance = function (it, Constructor, name) {
        if (!(it instanceof Constructor)) {
            throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
        } return it;
    };

    var ITERATOR$4 = wellKnownSymbol('iterator');
    var SAFE_CLOSING = false;

    try {
        var called = 0;
        var iteratorWithReturn = {
            next: function () {
                return { done: !!called++ };
            },
            'return': function () {
                SAFE_CLOSING = true;
            }
        };
        iteratorWithReturn[ITERATOR$4] = function () {
            return this;
        };
        // eslint-disable-next-line no-throw-literal
        Array.from(iteratorWithReturn, function () { throw 2; });
    } catch (error) { /* empty */ }

    var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
        if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
        var ITERATION_SUPPORT = false;
        try {
            var object = {};
            object[ITERATOR$4] = function () {
                return {
                    next: function () {
                        return { done: ITERATION_SUPPORT = true };
                    }
                };
            };
            exec(object);
        } catch (error) { /* empty */ }
        return ITERATION_SUPPORT;
    };

    // makes subclassing work correct for wrapped built-ins
    var inheritIfRequired = function ($this, dummy, Wrapper) {
        var NewTarget, NewTargetPrototype;
        if (
            // it can work only with native `setPrototypeOf`
            objectSetPrototypeOf &&
            // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
            typeof (NewTarget = dummy.constructor) == 'function' &&
            NewTarget !== Wrapper &&
            isObject(NewTargetPrototype = NewTarget.prototype) &&
            NewTargetPrototype !== Wrapper.prototype
        ) objectSetPrototypeOf($this, NewTargetPrototype);
        return $this;
    };

    var collection = function (CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {
        var NativeConstructor = global_1[CONSTRUCTOR_NAME];
        var NativePrototype = NativeConstructor && NativeConstructor.prototype;
        var Constructor = NativeConstructor;
        var ADDER = IS_MAP ? 'set' : 'add';
        var exported = {};

        var fixMethod = function (KEY) {
            var nativeMethod = NativePrototype[KEY];
            redefine(NativePrototype, KEY,
                KEY == 'add' ? function add(value) {
                    nativeMethod.call(this, value === 0 ? 0 : value);
                    return this;
                } : KEY == 'delete' ? function (key) {
                    return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
                } : KEY == 'get' ? function get(key) {
                    return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
                } : KEY == 'has' ? function has(key) {
                    return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
                } : function set(key, value) {
                    nativeMethod.call(this, key === 0 ? 0 : key, value);
                    return this;
                }
            );
        };

        // eslint-disable-next-line max-len
        if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
            new NativeConstructor().entries().next();
        })))) {
            // create collection constructor
            Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
            internalMetadata.REQUIRED = true;
        } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
            var instance = new Constructor();
            // early implementations not supports chaining
            var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
            // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
            var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
            // most early implementations doesn't supports iterables, most modern - not close it correctly
            // eslint-disable-next-line no-new
            var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
            // for early implementations -0 and +0 not the same
            var BUGGY_ZERO = !IS_WEAK && fails(function () {
                // V8 ~ Chromium 42- fails only with 5+ elements
                var $instance = new NativeConstructor();
                var index = 5;
                while (index--) $instance[ADDER](index, index);
                return !$instance.has(-0);
            });

            if (!ACCEPT_ITERABLES) {
                Constructor = wrapper(function (dummy, iterable) {
                    anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
                    var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                    if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
                    return that;
                });
                Constructor.prototype = NativePrototype;
                NativePrototype.constructor = Constructor;
            }

            if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                fixMethod('delete');
                fixMethod('has');
                IS_MAP && fixMethod('get');
            }

            if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

            // weak collections should not contains .clear method
            if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
        }

        exported[CONSTRUCTOR_NAME] = Constructor;
        _export({ global: true, forced: Constructor != NativeConstructor }, exported);

        setToStringTag(Constructor, CONSTRUCTOR_NAME);

        if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

        return Constructor;
    };

    var redefineAll = function (target, src, options) {
        for (var key in src) redefine(target, key, src[key], options);
        return target;
    };

    var SPECIES$3 = wellKnownSymbol('species');

    var setSpecies = function (CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
        var defineProperty = objectDefineProperty.f;

        if (descriptors && Constructor && !Constructor[SPECIES$3]) {
            defineProperty(Constructor, SPECIES$3, {
                configurable: true,
                get: function () { return this; }
            });
        }
    };

    var defineProperty$4 = objectDefineProperty.f;








    var fastKey = internalMetadata.fastKey;


    var setInternalState$2 = internalState.set;
    var internalStateGetterFor = internalState.getterFor;

    var collectionStrong = {
        getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
            var C = wrapper(function (that, iterable) {
                anInstance(that, C, CONSTRUCTOR_NAME);
                setInternalState$2(that, {
                    type: CONSTRUCTOR_NAME,
                    index: objectCreate(null),
                    first: undefined,
                    last: undefined,
                    size: 0
                });
                if (!descriptors) that.size = 0;
                if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
            });

            var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

            var define = function (that, key, value) {
                var state = getInternalState(that);
                var entry = getEntry(that, key);
                var previous, index;
                // change existing entry
                if (entry) {
                    entry.value = value;
                    // create new entry
                } else {
                    state.last = entry = {
                        index: index = fastKey(key, true),
                        key: key,
                        value: value,
                        previous: previous = state.last,
                        next: undefined,
                        removed: false
                    };
                    if (!state.first) state.first = entry;
                    if (previous) previous.next = entry;
                    if (descriptors) state.size++;
                    else that.size++;
                    // add to index
                    if (index !== 'F') state.index[index] = entry;
                } return that;
            };

            var getEntry = function (that, key) {
                var state = getInternalState(that);
                // fast case
                var index = fastKey(key);
                var entry;
                if (index !== 'F') return state.index[index];
                // frozen object case
                for (entry = state.first; entry; entry = entry.next) {
                    if (entry.key == key) return entry;
                }
            };

            redefineAll(C.prototype, {
                // 23.1.3.1 Map.prototype.clear()
                // 23.2.3.2 Set.prototype.clear()
                clear: function clear() {
                    var that = this;
                    var state = getInternalState(that);
                    var data = state.index;
                    var entry = state.first;
                    while (entry) {
                        entry.removed = true;
                        if (entry.previous) entry.previous = entry.previous.next = undefined;
                        delete data[entry.index];
                        entry = entry.next;
                    }
                    state.first = state.last = undefined;
                    if (descriptors) state.size = 0;
                    else that.size = 0;
                },
                // 23.1.3.3 Map.prototype.delete(key)
                // 23.2.3.4 Set.prototype.delete(value)
                'delete': function (key) {
                    var that = this;
                    var state = getInternalState(that);
                    var entry = getEntry(that, key);
                    if (entry) {
                        var next = entry.next;
                        var prev = entry.previous;
                        delete state.index[entry.index];
                        entry.removed = true;
                        if (prev) prev.next = next;
                        if (next) next.previous = prev;
                        if (state.first == entry) state.first = next;
                        if (state.last == entry) state.last = prev;
                        if (descriptors) state.size--;
                        else that.size--;
                    } return !!entry;
                },
                // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
                // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
                forEach: function forEach(callbackfn /* , that = undefined */) {
                    var state = getInternalState(this);
                    var boundFunction = bindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
                    var entry;
                    while (entry = entry ? entry.next : state.first) {
                        boundFunction(entry.value, entry.key, this);
                        // revert to the last existing entry
                        while (entry && entry.removed) entry = entry.previous;
                    }
                },
                // 23.1.3.7 Map.prototype.has(key)
                // 23.2.3.7 Set.prototype.has(value)
                has: function has(key) {
                    return !!getEntry(this, key);
                }
            });

            redefineAll(C.prototype, IS_MAP ? {
                // 23.1.3.6 Map.prototype.get(key)
                get: function get(key) {
                    var entry = getEntry(this, key);
                    return entry && entry.value;
                },
                // 23.1.3.9 Map.prototype.set(key, value)
                set: function set(key, value) {
                    return define(this, key === 0 ? 0 : key, value);
                }
            } : {
                // 23.2.3.1 Set.prototype.add(value)
                add: function add(value) {
                    return define(this, value = value === 0 ? 0 : value, value);
                }
            });
            if (descriptors) defineProperty$4(C.prototype, 'size', {
                get: function () {
                    return getInternalState(this).size;
                }
            });
            return C;
        },
        setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
            var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
            var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
            var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
            // add .keys, .values, .entries, [@@iterator]
            // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
            defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
                setInternalState$2(this, {
                    type: ITERATOR_NAME,
                    target: iterated,
                    state: getInternalCollectionState(iterated),
                    kind: kind,
                    last: undefined
                });
            }, function () {
                var state = getInternalIteratorState(this);
                var kind = state.kind;
                var entry = state.last;
                // revert to the last existing entry
                while (entry && entry.removed) entry = entry.previous;
                // get next entry
                if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                    // or finish the iteration
                    state.target = undefined;
                    return { value: undefined, done: true };
                }
                // return step by kind
                if (kind == 'keys') return { value: entry.key, done: false };
                if (kind == 'values') return { value: entry.value, done: false };
                return { value: [entry.key, entry.value], done: false };
            }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

            // add [@@species], 23.1.2.2, 23.2.2.2
            setSpecies(CONSTRUCTOR_NAME);
        }
    };

    // `Set` constructor
    // https://tc39.github.io/ecma262/#sec-set-objects
    var es_set = collection('Set', function (get) {
        return function Set() { return get(this, arguments.length ? arguments[0] : undefined); };
    }, collectionStrong);

    // `String.prototype.{ codePointAt, at }` methods implementation
    var createMethod$2 = function (CONVERT_TO_STRING) {
        return function ($this, pos) {
            var S = String(requireObjectCoercible($this));
            var position = toInteger(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
            first = S.charCodeAt(position);
            return first < 0xD800 || first > 0xDBFF || position + 1 === size
                || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
                ? CONVERT_TO_STRING ? S.charAt(position) : first
                : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
        };
    };

    var stringMultibyte = {
        // `String.prototype.codePointAt` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
        codeAt: createMethod$2(false),
        // `String.prototype.at` method
        // https://github.com/mathiasbynens/String.prototype.at
        charAt: createMethod$2(true)
    };

    var charAt = stringMultibyte.charAt;



    var STRING_ITERATOR = 'String Iterator';
    var setInternalState$3 = internalState.set;
    var getInternalState$2 = internalState.getterFor(STRING_ITERATOR);

    // `String.prototype[@@iterator]` method
    // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
    defineIterator(String, 'String', function (iterated) {
        setInternalState$3(this, {
            type: STRING_ITERATOR,
            string: String(iterated),
            index: 0
        });
        // `%StringIteratorPrototype%.next` method
        // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
    }, function next() {
        var state = getInternalState$2(this);
        var string = state.string;
        var index = state.index;
        var point;
        if (index >= string.length) return { value: undefined, done: true };
        point = charAt(string, index);
        state.index += point.length;
        return { value: point, done: false };
    });

    // iterable DOM collections
    // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
    var domIterables = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
    };

    var ITERATOR$5 = wellKnownSymbol('iterator');
    var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
    var ArrayValues = es_array_iterator.values;

    for (var COLLECTION_NAME in domIterables) {
        var Collection = global_1[COLLECTION_NAME];
        var CollectionPrototype = Collection && Collection.prototype;
        if (CollectionPrototype) {
            // some Chrome versions have non-configurable methods on DOMTokenList
            if (CollectionPrototype[ITERATOR$5] !== ArrayValues) try {
                createNonEnumerableProperty(CollectionPrototype, ITERATOR$5, ArrayValues);
            } catch (error) {
                CollectionPrototype[ITERATOR$5] = ArrayValues;
            }
            if (!CollectionPrototype[TO_STRING_TAG$3]) {
                createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
            }
            if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
                // some Chrome versions have non-configurable methods on DOMTokenList
                if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
                    createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
                } catch (error) {
                    CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
                }
            }
        }
    }

    function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i];
            }

            return arr2;
        }
    }

    function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    var methods = {};
    var names = [];
    function registerMethods(name, m) {
        if (Array.isArray(name)) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = name[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _name = _step.value;
                    registerMethods(_name, m);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return;
        }

        if (_typeof(name) === 'object') {
            for (var _name2 in name) {
                registerMethods(_name2, name[_name2]);
            }

            return;
        }

        addMethodNames(Object.getOwnPropertyNames(m));
        methods[name] = Object.assign(methods[name] || {}, m);
    }
    function getMethodsFor(name) {
        return methods[name] || {};
    }
    function getMethodNames() {
        return _toConsumableArray(new Set(names));
    }
    function addMethodNames(_names) {
        names.push.apply(names, _toConsumableArray(_names));
    }

    var $includes = arrayIncludes.includes;


    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    _export({ target: 'Array', proto: true }, {
        includes: function includes(el /* , fromIndex = 0 */) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
        }
    });

    // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
    addToUnscopables('includes');

    // `RegExp.prototype.flags` getter implementation
    // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
    var regexpFlags = function () {
        var that = anObject(this);
        var result = '';
        if (that.global) result += 'g';
        if (that.ignoreCase) result += 'i';
        if (that.multiline) result += 'm';
        if (that.dotAll) result += 's';
        if (that.unicode) result += 'u';
        if (that.sticky) result += 'y';
        return result;
    };

    var nativeExec = RegExp.prototype.exec;
    // This always refers to the native implementation, because the
    // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
    // which loads this file before patching the method.
    var nativeReplace = String.prototype.replace;

    var patchedExec = nativeExec;

    var UPDATES_LAST_INDEX_WRONG = (function () {
        var re1 = /a/;
        var re2 = /b*/g;
        nativeExec.call(re1, 'a');
        nativeExec.call(re2, 'a');
        return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    })();

    // nonparticipating capturing group, copied from es5-shim's String#split patch.
    var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

    if (PATCH) {
        patchedExec = function exec(str) {
            var re = this;
            var lastIndex, reCopy, match, i;

            if (NPCG_INCLUDED) {
                reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
            }
            if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

            match = nativeExec.call(re, str);

            if (UPDATES_LAST_INDEX_WRONG && match) {
                re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match && match.length > 1) {
                // Fix browsers whose `exec` methods don't consistently return `undefined`
                // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
                nativeReplace.call(match[0], reCopy, function () {
                    for (i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined) match[i] = undefined;
                    }
                });
            }

            return match;
        };
    }

    var regexpExec = patchedExec;

    _export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
        exec: regexpExec
    });

    var MATCH = wellKnownSymbol('match');

    // `IsRegExp` abstract operation
    // https://tc39.github.io/ecma262/#sec-isregexp
    var isRegexp = function (it) {
        var isRegExp;
        return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
    };

    var notARegexp = function (it) {
        if (isRegexp(it)) {
            throw TypeError("The method doesn't accept regular expressions");
        } return it;
    };

    var MATCH$1 = wellKnownSymbol('match');

    var correctIsRegexpLogic = function (METHOD_NAME) {
        var regexp = /./;
        try {
            '/./'[METHOD_NAME](regexp);
        } catch (e) {
            try {
                regexp[MATCH$1] = false;
                return '/./'[METHOD_NAME](regexp);
            } catch (f) { /* empty */ }
        } return false;
    };

    // `String.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.includes
    _export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
        includes: function includes(searchString /* , position = 0 */) {
            return !!~String(requireObjectCoercible(this))
                .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
        }
    });

    var SPECIES$4 = wellKnownSymbol('species');

    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
        // #replace needs built-in support for named groups.
        // #match works fine because it just return the exec results, even if it has
        // a "grops" property.
        var re = /./;
        re.exec = function () {
            var result = [];
            result.groups = { a: '7' };
            return result;
        };
        return ''.replace(re, '$<a>') !== '7';
    });

    // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
    // Weex JS has frozen built-in prototypes, so use try / catch wrapper
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
        var re = /(?:)/;
        var originalExec = re.exec;
        re.exec = function () { return originalExec.apply(this, arguments); };
        var result = 'ab'.split(re);
        return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
    });

    var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
        var SYMBOL = wellKnownSymbol(KEY);

        var DELEGATES_TO_SYMBOL = !fails(function () {
            // String methods call symbol-named RegEp methods
            var O = {};
            O[SYMBOL] = function () { return 7; };
            return ''[KEY](O) != 7;
        });

        var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
            // Symbol-named RegExp methods call .exec
            var execCalled = false;
            var re = /a/;

            if (KEY === 'split') {
                // We can't use real regex here since it causes deoptimization
                // and serious performance degradation in V8
                // https://github.com/zloirock/core-js/issues/306
                re = {};
                // RegExp[@@split] doesn't call the regex's exec method, but first creates
                // a new one. We need to return the patched regex when creating the new one.
                re.constructor = {};
                re.constructor[SPECIES$4] = function () { return re; };
                re.flags = '';
                re[SYMBOL] = /./[SYMBOL];
            }

            re.exec = function () { execCalled = true; return null; };

            re[SYMBOL]('');
            return !execCalled;
        });

        if (
            !DELEGATES_TO_SYMBOL ||
            !DELEGATES_TO_EXEC ||
            (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
            (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
        ) {
            var nativeRegExpMethod = /./[SYMBOL];
            var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
                if (regexp.exec === regexpExec) {
                    if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                        // The native String method already delegates to @@method (this
                        // polyfilled function), leasing to infinite recursion.
                        // We avoid it by directly calling the native @@method method.
                        return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                    }
                    return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                }
                return { done: false };
            });
            var stringMethod = methods[0];
            var regexMethod = methods[1];

            redefine(String.prototype, KEY, stringMethod);
            redefine(RegExp.prototype, SYMBOL, length == 2
                // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
                // 21.2.5.11 RegExp.prototype[@@split](string, limit)
                ? function (string, arg) { return regexMethod.call(string, this, arg); }
                // 21.2.5.6 RegExp.prototype[@@match](string)
                // 21.2.5.9 RegExp.prototype[@@search](string)
                : function (string) { return regexMethod.call(string, this); }
            );
            if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
        }
    };

    var charAt$1 = stringMultibyte.charAt;

    // `AdvanceStringIndex` abstract operation
    // https://tc39.github.io/ecma262/#sec-advancestringindex
    var advanceStringIndex = function (S, index, unicode) {
        return index + (unicode ? charAt$1(S, index).length : 1);
    };

    // `RegExpExec` abstract operation
    // https://tc39.github.io/ecma262/#sec-regexpexec
    var regexpExecAbstract = function (R, S) {
        var exec = R.exec;
        if (typeof exec === 'function') {
            var result = exec.call(R, S);
            if (typeof result !== 'object') {
                throw TypeError('RegExp exec method returned something other than an Object or null');
            }
            return result;
        }

        if (classofRaw(R) !== 'RegExp') {
            throw TypeError('RegExp#exec called on incompatible receiver');
        }

        return regexpExec.call(R, S);
    };

    var max$2 = Math.max;
    var min$2 = Math.min;
    var floor$1 = Math.floor;
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

    var maybeToString = function (it) {
        return it === undefined ? it : String(it);
    };

    // @@replace logic
    fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative) {
        return [
            // `String.prototype.replace` method
            // https://tc39.github.io/ecma262/#sec-string.prototype.replace
            function replace(searchValue, replaceValue) {
                var O = requireObjectCoercible(this);
                var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
                return replacer !== undefined
                    ? replacer.call(searchValue, O, replaceValue)
                    : nativeReplace.call(String(O), searchValue, replaceValue);
            },
            // `RegExp.prototype[@@replace]` method
            // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
            function (regexp, replaceValue) {
                var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                if (res.done) return res.value;

                var rx = anObject(regexp);
                var S = String(this);

                var functionalReplace = typeof replaceValue === 'function';
                if (!functionalReplace) replaceValue = String(replaceValue);

                var global = rx.global;
                if (global) {
                    var fullUnicode = rx.unicode;
                    rx.lastIndex = 0;
                }
                var results = [];
                while (true) {
                    var result = regexpExecAbstract(rx, S);
                    if (result === null) break;

                    results.push(result);
                    if (!global) break;

                    var matchStr = String(result[0]);
                    if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                }

                var accumulatedResult = '';
                var nextSourcePosition = 0;
                for (var i = 0; i < results.length; i++) {
                    result = results[i];

                    var matched = String(result[0]);
                    var position = max$2(min$2(toInteger(result.index), S.length), 0);
                    var captures = [];
                    // NOTE: This is equivalent to
                    //   captures = result.slice(1).map(maybeToString)
                    // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                    // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                    // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                    for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
                    var namedCaptures = result.groups;
                    if (functionalReplace) {
                        var replacerArgs = [matched].concat(captures, position, S);
                        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                        var replacement = String(replaceValue.apply(undefined, replacerArgs));
                    } else {
                        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                    }
                    if (position >= nextSourcePosition) {
                        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                        nextSourcePosition = position + matched.length;
                    }
                }
                return accumulatedResult + S.slice(nextSourcePosition);
            }
        ];

        // https://tc39.github.io/ecma262/#sec-getsubstitution
        function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
            var tailPos = position + matched.length;
            var m = captures.length;
            var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
            if (namedCaptures !== undefined) {
                namedCaptures = toObject(namedCaptures);
                symbols = SUBSTITUTION_SYMBOLS;
            }
            return nativeReplace.call(replacement, symbols, function (match, ch) {
                var capture;
                switch (ch.charAt(0)) {
                    case '$': return '$';
                    case '&': return matched;
                    case '`': return str.slice(0, position);
                    case "'": return str.slice(tailPos);
                    case '<':
                        capture = namedCaptures[ch.slice(1, -1)];
                        break;
                    default: // \d\d?
                        var n = +ch;
                        if (n === 0) return match;
                        if (n > m) {
                            var f = floor$1(n / 10);
                            if (f === 0) return match;
                            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                            return match;
                        }
                        capture = captures[n - 1];
                }
                return capture === undefined ? '' : capture;
            });
        }
    });

    // a string of all valid unicode whitespaces
    // eslint-disable-next-line max-len
    var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

    var whitespace = '[' + whitespaces + ']';
    var ltrim = RegExp('^' + whitespace + whitespace + '*');
    var rtrim = RegExp(whitespace + whitespace + '*$');

    // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
    var createMethod$3 = function (TYPE) {
        return function ($this) {
            var string = String(requireObjectCoercible($this));
            if (TYPE & 1) string = string.replace(ltrim, '');
            if (TYPE & 2) string = string.replace(rtrim, '');
            return string;
        };
    };

    var stringTrim = {
        // `String.prototype.{ trimLeft, trimStart }` methods
        // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
        start: createMethod$3(1),
        // `String.prototype.{ trimRight, trimEnd }` methods
        // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
        end: createMethod$3(2),
        // `String.prototype.trim` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.trim
        trim: createMethod$3(3)
    };

    var non = '\u200B\u0085\u180E';

    // check that a method works with the correct list
    // of whitespaces and has a correct name
    var forcedStringTrimMethod = function (METHOD_NAME) {
        return fails(function () {
            return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
        });
    };

    var $trim = stringTrim.trim;


    // `String.prototype.trim` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.trim
    _export({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
        trim: function trim() {
            return $trim(this);
        }
    });

    // Map function
    function map(array, block) {
        var i;
        var il = array.length;
        var result = [];

        for (i = 0; i < il; i++) {
            result.push(block(array[i]));
        }

        return result;
    } // Filter function

    function filter(array, block) {
        var i;
        var il = array.length;
        var result = [];

        for (i = 0; i < il; i++) {
            if (block(array[i])) {
                result.push(array[i]);
            }
        }

        return result;
    } // Degrees to radians

    function radians(d) {
        return d % 360 * Math.PI / 180;
    } // Radians to degrees

    function degrees(r) {
        return r * 180 / Math.PI % 360;
    } // Convert dash-separated-string to camelCase

    function camelCase(s) {
        return s.toLowerCase().replace(/-(.)/g, function (m, g) {
            return g.toUpperCase();
        });
    } // Convert camel cased string to string seperated

    function unCamelCase(s) {
        return s.replace(/([A-Z])/g, function (m, g) {
            return '-' + g.toLowerCase();
        });
    } // Capitalize first letter of a string

    function capitalize(s) {
        return s.charAt(0).toUpperCase() + s.slice(1);
    } // Calculate proportional width and height values when necessary

    function proportionalSize(element, width, height, box) {
        if (width == null || height == null) {
            box = box || element.bbox();

            if (width == null) {
                width = box.width / box.height * height;
            } else if (height == null) {
                height = box.height / box.width * width;
            }
        }

        return {
            width: width,
            height: height
        };
    }
    function getOrigin(o, element) {
        // Allow origin or around as the names
        var origin = o.origin; // o.around == null ? o.origin : o.around

        var ox, oy; // Allow the user to pass a string to rotate around a given point

        if (typeof origin === 'string' || origin == null) {
            // mercator
            if (o.ox !== undefined && o.oy !== undefined) {
                return [o.ox, o.oy]
            }

            // Get the bounding box of the element with no transformations applied
            var string = (origin || 'center').toLowerCase().trim();

            var _element$bbox = element.bbox(),
                height = _element$bbox.height,
                width = _element$bbox.width,
                x = _element$bbox.x,
                y = _element$bbox.y; // Calculate the transformed x and y coordinates


            var bx = string.includes('left') ? x : string.includes('right') ? x + width : x + width / 2;
            var by = string.includes('top') ? y : string.includes('bottom') ? y + height : y + height / 2; // Set the bounds eg : "bottom-left", "Top right", "middle" etc...

            ox = o.ox != null ? o.ox : bx;
            oy = o.oy != null ? o.oy : by;
        } else {
            ox = origin[0];
            oy = origin[1];
        } // Return the origin as it is if it wasn't a string


        return [ox, oy];
    }

    var utils = ({
        __proto__: null,
        map: map,
        filter: filter,
        radians: radians,
        degrees: degrees,
        camelCase: camelCase,
        unCamelCase: unCamelCase,
        capitalize: capitalize,
        proportionalSize: proportionalSize,
        getOrigin: getOrigin
    });

    // Default namespaces
    var ns = 'http://www.w3.org/2000/svg';
    var xmlns = 'http://www.w3.org/2000/xmlns/';
    var xlink = 'http://www.w3.org/1999/xlink';
    var svgjs = 'http://svgjs.com/svgjs';

    var namespaces = ({
        __proto__: null,
        ns: ns,
        xmlns: xmlns,
        xlink: xlink,
        svgjs: svgjs
    });

    var globals = {
        window: typeof window === 'undefined' ? null : window,
        document: typeof document === 'undefined' ? null : document
    };
    function registerWindow() {
        var win = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        globals.window = win;
        globals.document = doc;
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var Base = function Base() {
        _classCallCheck(this, Base);
    };

    var elements = {};
    var root = '___SYMBOL___ROOT___'; // Method for element creation

    function create(name) {
        // create element
        return globals.document.createElementNS(ns, name);
    }
    function makeInstance(element) {
        if (element instanceof Base) return element;

        if (_typeof(element) === 'object') {
            return adopter(element);
        }

        if (element == null) {
            return new elements[root]();
        }

        if (typeof element === 'string' && element.charAt(0) !== '<') {
            return adopter(globals.document.querySelector(element));
        }

        var node = create('svg');
        node.innerHTML = element; // We can use firstChild here because we know,
        // that the first char is < and thus an element

        element = adopter(node.firstChild);
        return element;
    }
    function nodeOrNew(name, node) {
        return node instanceof globals.window.Node ? node : create(name);
    } // Adopt existing svg elements

    function adopt(node) {
        // check for presence of node
        if (!node) return null; // make sure a node isn't already adopted

        if (node.instance instanceof Base) return node.instance; // initialize variables

        var className = capitalize(node.nodeName || 'Dom'); // Make sure that gradients are adopted correctly

        if (className === 'LinearGradient' || className === 'RadialGradient') {
            className = 'Gradient'; // Fallback to Dom if element is not known
        } else if (!elements[className]) {
            className = 'Dom';
        }

        return new elements[className](node);
    }
    var adopter = adopt;
    function mockAdopt() {
        var mock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : adopt;
        adopter = mock;
    }
    function register(element) {
        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element.name;
        var asRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        elements[name] = element;
        if (asRoot) elements[root] = element;
        addMethodNames(Object.getOwnPropertyNames(element.prototype));
        return element;
    }
    function getClass(name) {
        return elements[name];
    } // Element id sequence

    var did = 1000; // Get next named element id

    function eid(name) {
        return 'Svgjs' + capitalize(name) + did++;
    } // Deep new id assignment

    function assignNewId(node) {
        // do the same for SVG child nodes as well
        for (var i = node.children.length - 1; i >= 0; i--) {
            assignNewId(node.children[i]);
        }

        if (node.id) {
            return adopt(node).id(eid(node.nodeName));
        }

        return adopt(node);
    } // Method for extending objects

    function extend(modules, methods, attrCheck) {
        var key, i;
        modules = Array.isArray(modules) ? modules : [modules];

        for (i = modules.length - 1; i >= 0; i--) {
            for (key in methods) {
                var method = methods[key];

                if (attrCheck) {
                    method = wrapWithAttrCheck(methods[key]);
                }

                modules[i].prototype[key] = method;
            }
        }
    } // export function extendWithAttrCheck (...args) {
    //   extend(...args, true)
    // }

    function wrapWithAttrCheck(fn) {
        return function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var o = args[args.length - 1];

            if (o && o.constructor === Object && !(o instanceof Array)) {
                return fn.apply(this, args.slice(0, -1)).attr(o);
            } else {
                return fn.apply(this, args);
            }
        };
    }
    function invent(config) {
        // Create element initializer
        var initializer = typeof config.create === 'function' ? config.create : function (node) {
            this.constructor(node || create(config.create));
        }; // Inherit prototype

        if (config.inherit) {
            /* eslint new-cap: off */
            initializer.prototype = new config.inherit();
            initializer.prototype.constructor = initializer;
        } // Extend with methods


        if (config.extend) {
            extend(initializer, config.extend);
        } // Attach construct method to parent


        if (config.construct) {
            extend(config.parent || elements.Container, config.construct);
        }

        return initializer;
    }

    function siblings() {
        return this.parent().children();
    } // Get the curent position siblings

    function position() {
        return this.parent().index(this);
    } // Get the next element (will return null if there is none)

    function next() {
        return this.siblings()[this.position() + 1];
    } // Get the next element (will return null if there is none)

    function prev() {
        return this.siblings()[this.position() - 1];
    } // Send given element one step forward

    function forward() {
        var i = this.position() + 1;
        var p = this.parent(); // move node one step forward

        p.removeElement(this).add(this, i); // make sure defs node is always at the top

        if (typeof p.isRoot === 'function' && p.isRoot()) {
            p.node.appendChild(p.defs().node);
        }

        return this;
    } // Send given element one step backward

    function backward() {
        var i = this.position();

        if (i > 0) {
            this.parent().removeElement(this).add(this, i - 1);
        }

        return this;
    } // Send given element all the way to the front

    function front() {
        var p = this.parent(); // Move node forward

        p.node.appendChild(this.node); // Make sure defs node is always at the top

        if (typeof p.isRoot === 'function' && p.isRoot()) {
            p.node.appendChild(p.defs().node);
        }

        return this;
    } // Send given element all the way to the back

    function back() {
        if (this.position() > 0) {
            this.parent().removeElement(this).add(this, 0);
        }

        return this;
    } // Inserts a given element before the targeted element

    function before(element) {
        element = makeInstance(element);
        element.remove();
        var i = this.position();
        this.parent().add(element, i);
        return this;
    } // Inserts a given element after the targeted element

    function after(element) {
        element = makeInstance(element);
        element.remove();
        var i = this.position();
        this.parent().add(element, i + 1);
        return this;
    }
    function insertBefore(element) {
        element = makeInstance(element);
        element.before(this);
        return this;
    }
    function insertAfter(element) {
        element = makeInstance(element);
        element.after(this);
        return this;
    }
    registerMethods('Dom', {
        siblings: siblings,
        position: position,
        next: next,
        prev: prev,
        forward: forward,
        backward: backward,
        front: front,
        back: back,
        before: before,
        after: after,
        insertBefore: insertBefore,
        insertAfter: insertAfter
    });

    var $filter = arrayIteration.filter;


    // `Array.prototype.filter` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.filter
    // with adding support of @@species
    _export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('filter') }, {
        filter: function filter(callbackfn /* , thisArg */) {
            return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        }
    });

    var sloppyArrayMethod = function (METHOD_NAME, argument) {
        var method = [][METHOD_NAME];
        return !method || !fails(function () {
            // eslint-disable-next-line no-useless-call,no-throw-literal
            method.call(null, argument || function () { throw 1; }, 1);
        });
    };

    var $indexOf = arrayIncludes.indexOf;


    var nativeIndexOf = [].indexOf;

    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
    var SLOPPY_METHOD = sloppyArrayMethod('indexOf');

    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    _export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || SLOPPY_METHOD }, {
        indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
            return NEGATIVE_ZERO
                // convert -0 to +0
                ? nativeIndexOf.apply(this, arguments) || 0
                : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
        }
    });

    var nativeJoin = [].join;

    var ES3_STRINGS = indexedObject != Object;
    var SLOPPY_METHOD$1 = sloppyArrayMethod('join', ',');

    // `Array.prototype.join` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.join
    _export({ target: 'Array', proto: true, forced: ES3_STRINGS || SLOPPY_METHOD$1 }, {
        join: function join(separator) {
            return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
        }
    });

    var SPECIES$5 = wellKnownSymbol('species');

    // `SpeciesConstructor` abstract operation
    // https://tc39.github.io/ecma262/#sec-speciesconstructor
    var speciesConstructor = function (O, defaultConstructor) {
        var C = anObject(O).constructor;
        var S;
        return C === undefined || (S = anObject(C)[SPECIES$5]) == undefined ? defaultConstructor : aFunction$1(S);
    };

    var arrayPush = [].push;
    var min$3 = Math.min;
    var MAX_UINT32 = 0xFFFFFFFF;

    // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
    var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

    // @@split logic
    fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
        var internalSplit;
        if (
            'abbc'.split(/(b)*/)[1] == 'c' ||
            'test'.split(/(?:)/, -1).length != 4 ||
            'ab'.split(/(?:ab)*/).length != 2 ||
            '.'.split(/(.?)(.?)/).length != 4 ||
            '.'.split(/()()/).length > 1 ||
            ''.split(/.?/).length
        ) {
            // based on es5-shim implementation, need to rework it
            internalSplit = function (separator, limit) {
                var string = String(requireObjectCoercible(this));
                var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                if (lim === 0) return [];
                if (separator === undefined) return [string];
                // If `separator` is not a regex, use native split
                if (!isRegexp(separator)) {
                    return nativeSplit.call(string, separator, lim);
                }
                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
                var lastLastIndex = 0;
                // Make `global` and avoid `lastIndex` issues by working with a copy
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                var match, lastIndex, lastLength;
                while (match = regexpExec.call(separatorCopy, string)) {
                    lastIndex = separatorCopy.lastIndex;
                    if (lastIndex > lastLastIndex) {
                        output.push(string.slice(lastLastIndex, match.index));
                        if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= lim) break;
                    }
                    if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) output.push('');
                } else output.push(string.slice(lastLastIndex));
                return output.length > lim ? output.slice(0, lim) : output;
            };
            // Chakra, V8
        } else if ('0'.split(undefined, 0).length) {
            internalSplit = function (separator, limit) {
                return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
            };
        } else internalSplit = nativeSplit;

        return [
            // `String.prototype.split` method
            // https://tc39.github.io/ecma262/#sec-string.prototype.split
            function split(separator, limit) {
                var O = requireObjectCoercible(this);
                var splitter = separator == undefined ? undefined : separator[SPLIT];
                return splitter !== undefined
                    ? splitter.call(separator, O, limit)
                    : internalSplit.call(String(O), separator, limit);
            },
            // `RegExp.prototype[@@split]` method
            // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
            //
            // NOTE: This cannot be properly polyfilled in engines that don't support
            // the 'y' flag.
            function (regexp, limit) {
                var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
                if (res.done) return res.value;

                var rx = anObject(regexp);
                var S = String(this);
                var C = speciesConstructor(rx, RegExp);

                var unicodeMatching = rx.unicode;
                var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (SUPPORTS_Y ? 'y' : 'g');

                // ^(? + rx + ) is needed, in combination with some S slicing, to
                // simulate the 'y' flag.
                var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
                var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                if (lim === 0) return [];
                if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
                var p = 0;
                var q = 0;
                var A = [];
                while (q < S.length) {
                    splitter.lastIndex = SUPPORTS_Y ? q : 0;
                    var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
                    var e;
                    if (
                        z === null ||
                        (e = min$3(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
                    ) {
                        q = advanceStringIndex(S, q, unicodeMatching);
                    } else {
                        A.push(S.slice(p, q));
                        if (A.length === lim) return A;
                        for (var i = 1; i <= z.length - 1; i++) {
                            A.push(z[i]);
                            if (A.length === lim) return A;
                        }
                        q = p = e;
                    }
                }
                A.push(S.slice(p));
                return A;
            }
        ];
    }, !SUPPORTS_Y);

    // Parse unit value
    var numberAndUnit = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i; // Parse hex value

    var hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i; // Parse rgb value

    var rgb = /rgb\((\d+),(\d+),(\d+)\)/; // Parse reference id

    var reference = /(#[a-z0-9\-_]+)/i; // splits a transformation chain

    var transforms = /\)\s*,?\s*/; // Whitespace

    var whitespace$1 = /\s/g; // Test hex value

    var isHex = /^#[a-f0-9]{3,6}$/i; // Test rgb value

    var isRgb = /^rgb\(/; // Test css declaration

    var isCss = /[^:]+:[^;]+;?/; // Test for blank string

    var isBlank = /^(\s+)?$/; // Test for numeric string

    var isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i; // Test for percent value

    var isPercent = /^-?[\d.]+%$/; // Test for image url

    var isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i; // split at whitespace and comma

    var delimiter = /[\s,]+/; // The following regex are used to parse the d attribute of a path
    // Matches all hyphens which are not after an exponent

    var hyphen = /([^e])-/gi; // Replaces and tests for all path letters

    var pathLetters = /[MLHVCSQTAZ]/gi; // yes we need this one, too

    var isPathLetter = /[MLHVCSQTAZ]/i; // matches 0.154.23.45

    var numbersWithDots = /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi; // matches .

    var dots = /\./g;

    var regex = ({
        __proto__: null,
        numberAndUnit: numberAndUnit,
        hex: hex,
        rgb: rgb,
        reference: reference,
        transforms: transforms,
        whitespace: whitespace$1,
        isHex: isHex,
        isRgb: isRgb,
        isCss: isCss,
        isBlank: isBlank,
        isNumber: isNumber,
        isPercent: isPercent,
        isImage: isImage,
        delimiter: delimiter,
        hyphen: hyphen,
        pathLetters: pathLetters,
        isPathLetter: isPathLetter,
        numbersWithDots: numbersWithDots,
        dots: dots
    });

    function classes() {
        var attr = this.attr('class');
        return attr == null ? [] : attr.trim().split(delimiter);
    } // Return true if class exists on the node, false otherwise

    function hasClass(name) {
        return this.classes().indexOf(name) !== -1;
    } // Add class to the node

    function addClass(name) {
        if (!this.hasClass(name)) {
            var array = this.classes();
            array.push(name);
            this.attr('class', array.join(' '));
        }

        return this;
    } // Remove class from the node

    function removeClass(name) {
        if (this.hasClass(name)) {
            this.attr('class', this.classes().filter(function (c) {
                return c !== name;
            }).join(' '));
        }

        return this;
    } // Toggle the presence of a class on the node

    function toggleClass(name) {
        return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
    }
    registerMethods('Dom', {
        classes: classes,
        hasClass: hasClass,
        addClass: addClass,
        removeClass: removeClass,
        toggleClass: toggleClass
    });

    var $forEach$1 = arrayIteration.forEach;


    // `Array.prototype.forEach` method implementation
    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
    var arrayForEach = sloppyArrayMethod('forEach') ? function forEach(callbackfn /* , thisArg */) {
        return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    } : [].forEach;

    // `Array.prototype.forEach` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
    _export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
        forEach: arrayForEach
    });

    for (var COLLECTION_NAME$1 in domIterables) {
        var Collection$1 = global_1[COLLECTION_NAME$1];
        var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype$1 && CollectionPrototype$1.forEach !== arrayForEach) try {
            createNonEnumerableProperty(CollectionPrototype$1, 'forEach', arrayForEach);
        } catch (error) {
            CollectionPrototype$1.forEach = arrayForEach;
        }
    }

    function css(style, val) {
        var ret = {};

        if (arguments.length === 0) {
            // get full style as object
            this.node.style.cssText.split(/\s*;\s*/).filter(function (el) {
                return !!el.length;
            }).forEach(function (el) {
                var t = el.split(/\s*:\s*/);
                ret[t[0]] = t[1];
            });
            return ret;
        }

        if (arguments.length < 2) {
            // get style properties in the array
            if (Array.isArray(style)) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = style[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var name = _step.value;
                        var cased = camelCase(name);
                        ret[cased] = this.node.style[cased];
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return ret;
            } // get style for property


            if (typeof style === 'string') {
                return this.node.style[camelCase(style)];
            } // set styles in object


            if (_typeof(style) === 'object') {
                for (var _name in style) {
                    // set empty string if null/undefined/'' was given
                    this.node.style[camelCase(_name)] = style[_name] == null || isBlank.test(style[_name]) ? '' : style[_name];
                }
            }
        } // set style for property


        if (arguments.length === 2) {
            this.node.style[camelCase(style)] = val == null || isBlank.test(val) ? '' : val;
        }

        return this;
    } // Show element

    function show() {
        return this.css('display', '');
    } // Hide element

    function hide() {
        return this.css('display', 'none');
    } // Is element visible?

    function visible() {
        return this.css('display') !== 'none';
    }
    registerMethods('Dom', {
        css: css,
        show: show,
        hide: hide,
        visible: visible
    });

    function data$1(a, v, r) {
        if (_typeof(a) === 'object') {
            for (v in a) {
                this.data(v, a[v]);
            }
        } else if (arguments.length < 2) {
            try {
                return JSON.parse(this.attr('data-' + a));
            } catch (e) {
                return this.attr('data-' + a);
            }
        } else {
            this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));
        }

        return this;
    }
    registerMethods('Dom', {
        data: data$1
    });

    function remember(k, v) {
        // remember every item in an object individually
        if (_typeof(arguments[0]) === 'object') {
            for (var key in k) {
                this.remember(key, k[key]);
            }
        } else if (arguments.length === 1) {
            // retrieve memory
            return this.memory()[k];
        } else {
            // store memory
            this.memory()[k] = v;
        }

        return this;
    } // Erase a given memory

    function forget() {
        if (arguments.length === 0) {
            this._memory = {};
        } else {
            for (var i = arguments.length - 1; i >= 0; i--) {
                delete this.memory()[arguments[i]];
            }
        }

        return this;
    } // This triggers creation of a new hidden class which is not performant
    // However, this function is not rarely used so it will not happen frequently
    // Return local memory object

    function memory() {
        return this._memory = this._memory || {};
    }
    registerMethods('Dom', {
        remember: remember,
        forget: forget,
        memory: memory
    });

    // `Array.prototype.{ reduce, reduceRight }` methods implementation
    var createMethod$4 = function (IS_RIGHT) {
        return function (that, callbackfn, argumentsLength, memo) {
            aFunction$1(callbackfn);
            var O = toObject(that);
            var self = indexedObject(O);
            var length = toLength(O.length);
            var index = IS_RIGHT ? length - 1 : 0;
            var i = IS_RIGHT ? -1 : 1;
            if (argumentsLength < 2) while (true) {
                if (index in self) {
                    memo = self[index];
                    index += i;
                    break;
                }
                index += i;
                if (IS_RIGHT ? index < 0 : length <= index) {
                    throw TypeError('Reduce of empty array with no initial value');
                }
            }
            for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
                memo = callbackfn(memo, self[index], index, O);
            }
            return memo;
        };
    };

    var arrayReduce = {
        // `Array.prototype.reduce` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
        left: createMethod$4(false),
        // `Array.prototype.reduceRight` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
        right: createMethod$4(true)
    };

    var $reduce = arrayReduce.left;


    // `Array.prototype.reduce` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
    _export({ target: 'Array', proto: true, forced: sloppyArrayMethod('reduce') }, {
        reduce: function reduce(callbackfn /* , initialValue */) {
            return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
        }
    });

    var listenerId = 0;
    var windowEvents = {};

    function getEvents(instance) {
        var n = instance.getEventHolder(); // We dont want to save events in global space

        if (n === globals.window) n = windowEvents;
        if (!n.events) n.events = {};
        return n.events;
    }

    function getEventTarget(instance) {
        return instance.getEventTarget();
    }

    function clearEvents(instance) {
        var n = instance.getEventHolder();
        if (n.events) n.events = {};
    } // Add event binder in the SVG namespace


    function on(node, events, listener, binding, options) {
        var l = listener.bind(binding || node);
        var instance = makeInstance(node);
        var bag = getEvents(instance);
        var n = getEventTarget(instance); // events can be an array of events or a string of events

        events = Array.isArray(events) ? events : events.split(delimiter); // add id to listener

        if (!listener._svgjsListenerId) {
            listener._svgjsListenerId = ++listenerId;
        }

        events.forEach(function (event) {
            var ev = event.split('.')[0];
            var ns = event.split('.')[1] || '*'; // ensure valid object

            bag[ev] = bag[ev] || {};
            bag[ev][ns] = bag[ev][ns] || {}; // reference listener

            bag[ev][ns][listener._svgjsListenerId] = l; // add listener

            n.addEventListener(ev, l, options || false);
        });
    } // Add event unbinder in the SVG namespace

    function off(node, events, listener, options) {
        var instance = makeInstance(node);
        var bag = getEvents(instance);
        var n = getEventTarget(instance); // listener can be a function or a number

        if (typeof listener === 'function') {
            listener = listener._svgjsListenerId;
            if (!listener) return;
        } // events can be an array of events or a string or undefined


        events = Array.isArray(events) ? events : (events || '').split(delimiter);
        events.forEach(function (event) {
            var ev = event && event.split('.')[0];
            var ns = event && event.split('.')[1];
            var namespace, l;

            if (listener) {
                // remove listener reference
                if (bag[ev] && bag[ev][ns || '*']) {
                    // removeListener
                    n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);
                    delete bag[ev][ns || '*'][listener];
                }
            } else if (ev && ns) {
                // remove all listeners for a namespaced event
                if (bag[ev] && bag[ev][ns]) {
                    for (l in bag[ev][ns]) {
                        off(n, [ev, ns].join('.'), l);
                    }

                    delete bag[ev][ns];
                }
            } else if (ns) {
                // remove all listeners for a specific namespace
                for (event in bag) {
                    for (namespace in bag[event]) {
                        if (ns === namespace) {
                            off(n, [event, ns].join('.'));
                        }
                    }
                }
            } else if (ev) {
                // remove all listeners for the event
                if (bag[ev]) {
                    for (namespace in bag[ev]) {
                        off(n, [ev, namespace].join('.'));
                    }

                    delete bag[ev];
                }
            } else {
                // remove all listeners on a given node
                for (event in bag) {
                    off(n, event);
                }

                clearEvents(instance);
            }
        });
    }
    function dispatch(node, event, data) {
        var n = getEventTarget(node); // Dispatch event

        if (event instanceof globals.window.Event) {
            n.dispatchEvent(event);
        } else {
            event = new globals.window.CustomEvent(event, {
                detail: data,
                cancelable: true
            });
            n.dispatchEvent(event);
        }

        return event;
    }

    var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
    var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
    var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/679
    var IS_CONCAT_SPREADABLE_SUPPORT = v8Version >= 51 || !fails(function () {
        var array = [];
        array[IS_CONCAT_SPREADABLE] = false;
        return array.concat()[0] !== array;
    });

    var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

    var isConcatSpreadable = function (O) {
        if (!isObject(O)) return false;
        var spreadable = O[IS_CONCAT_SPREADABLE];
        return spreadable !== undefined ? !!spreadable : isArray(O);
    };

    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

    // `Array.prototype.concat` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.concat
    // with adding support of @@isConcatSpreadable and @@species
    _export({ target: 'Array', proto: true, forced: FORCED }, {
        concat: function concat(arg) { // eslint-disable-line no-unused-vars
            var O = toObject(this);
            var A = arraySpeciesCreate(O, 0);
            var n = 0;
            var i, k, length, len, E;
            for (i = -1, length = arguments.length; i < length; i++) {
                E = i === -1 ? O : arguments[i];
                if (isConcatSpreadable(E)) {
                    len = toLength(E.length);
                    if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                    for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
                } else {
                    if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                    createProperty(A, n++, E);
                }
            }
            A.length = n;
            return A;
        }
    });

    var $map = arrayIteration.map;


    // `Array.prototype.map` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.map
    // with adding support of @@species
    _export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('map') }, {
        map: function map(callbackfn /* , thisArg */) {
            return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        }
    });

    var DatePrototype = Date.prototype;
    var INVALID_DATE = 'Invalid Date';
    var TO_STRING = 'toString';
    var nativeDateToString = DatePrototype[TO_STRING];
    var getTime = DatePrototype.getTime;

    // `Date.prototype.toString` method
    // https://tc39.github.io/ecma262/#sec-date.prototype.tostring
    if (new Date(NaN) + '' != INVALID_DATE) {
        redefine(DatePrototype, TO_STRING, function toString() {
            var value = getTime.call(this);
            // eslint-disable-next-line no-self-compare
            return value === value ? nativeDateToString.call(this) : INVALID_DATE;
        });
    }

    var trim = stringTrim.trim;


    var nativeParseInt = global_1.parseInt;
    var hex$1 = /^[+-]?0[Xx]/;
    var FORCED$1 = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22;

    // `parseInt` method
    // https://tc39.github.io/ecma262/#sec-parseint-string-radix
    var _parseInt = FORCED$1 ? function parseInt(string, radix) {
        var S = trim(String(string));
        return nativeParseInt(S, (radix >>> 0) || (hex$1.test(S) ? 16 : 10));
    } : nativeParseInt;

    // `parseInt` method
    // https://tc39.github.io/ecma262/#sec-parseint-string-radix
    _export({ global: true, forced: parseInt != _parseInt }, {
        parseInt: _parseInt
    });

    var TO_STRING$1 = 'toString';
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING$1];

    var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
    // FF44- RegExp#toString has a wrong name
    var INCORRECT_NAME = nativeToString.name != TO_STRING$1;

    // `RegExp.prototype.toString` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
    if (NOT_GENERIC || INCORRECT_NAME) {
        redefine(RegExp.prototype, TO_STRING$1, function toString() {
            var R = anObject(this);
            var p = String(R.source);
            var rf = R.flags;
            var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
            return '/' + p + '/' + f;
        }, { unsafe: true });
    }

    function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
        if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
            return;
        }

        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally {
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally {
                if (_d) throw _e;
            }
        }

        return _arr;
    }

    function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
    }

    function sixDigitHex(hex) {
        return hex.length === 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;
    }

    function componentHex(component) {
        var integer = Math.round(component);
        var bounded = Math.max(0, Math.min(255, integer));
        var hex = bounded.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }

    function is(object, space) {
        for (var i = space.length; i--;) {
            if (object[space[i]] == null) {
                return false;
            }
        }

        return true;
    }

    function getParameters(a, b) {
        var params = is(a, 'rgb') ? {
            _a: a.r,
            _b: a.g,
            _c: a.b,
            space: 'rgb'
        } : is(a, 'xyz') ? {
            _a: a.x,
            _b: a.y,
            _c: a.z,
            _d: 0,
            space: 'xyz'
        } : is(a, 'hsl') ? {
            _a: a.h,
            _b: a.s,
            _c: a.l,
            _d: 0,
            space: 'hsl'
        } : is(a, 'lab') ? {
            _a: a.l,
            _b: a.a,
            _c: a.b,
            _d: 0,
            space: 'lab'
        } : is(a, 'lch') ? {
            _a: a.l,
            _b: a.c,
            _c: a.h,
            _d: 0,
            space: 'lch'
        } : is(a, 'cmyk') ? {
            _a: a.c,
            _b: a.m,
            _c: a.y,
            _d: a.k,
            space: 'cmyk'
        } : {
            _a: 0,
            _b: 0,
            _c: 0,
            space: 'rgb'
        };
        params.space = b || params.space;
        return params;
    }

    function cieSpace(space) {
        if (space === 'lab' || space === 'xyz' || space === 'lch') {
            return true;
        } else {
            return false;
        }
    }

    function hueToRgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
    }

    var Color =
        /*#__PURE__*/
        function () {
            function Color() {
                _classCallCheck(this, Color);

                this.init.apply(this, arguments);
            }

            _createClass(Color, [{
                key: "init",
                value: function init() {
                    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                    var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                    var space = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'rgb';
                    // This catches the case when a falsy value is passed like ''
                    a = !a ? 0 : a; // Reset all values in case the init function is rerun with new color space

                    if (this.space) {
                        for (var component in this.space) {
                            delete this[this.space[component]];
                        }
                    }

                    if (typeof a === 'number') {
                        // Allow for the case that we don't need d...
                        space = typeof d === 'string' ? d : space;
                        d = typeof d === 'string' ? 0 : d; // Assign the values straight to the color

                        Object.assign(this, {
                            _a: a,
                            _b: b,
                            _c: c,
                            _d: d,
                            space: space
                        }); // If the user gave us an array, make the color from it
                    } else if (a instanceof Array) {
                        this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';
                        Object.assign(this, {
                            _a: a[0],
                            _b: a[1],
                            _c: a[2],
                            _d: a[3] || 0
                        });
                    } else if (a instanceof Object) {
                        // Set the object up and assign its values directly
                        var values = getParameters(a, b);
                        Object.assign(this, values);
                    } else if (typeof a === 'string') {
                        if (isRgb.test(a)) {
                            var noWhitespace = a.replace(whitespace$1, '');

                            var _rgb$exec$slice$map = rgb.exec(noWhitespace).slice(1, 4).map(function (v) {
                                return parseInt(v);
                            }),
                                _rgb$exec$slice$map2 = _slicedToArray(_rgb$exec$slice$map, 3),
                                _a2 = _rgb$exec$slice$map2[0],
                                _b2 = _rgb$exec$slice$map2[1],
                                _c2 = _rgb$exec$slice$map2[2];

                            Object.assign(this, {
                                _a: _a2,
                                _b: _b2,
                                _c: _c2,
                                _d: 0,
                                space: 'rgb'
                            });
                        } else if (isHex.test(a)) {
                            var hexParse = function hexParse(v) {
                                return parseInt(v, 16);
                            };

                            var _hex$exec$map = hex.exec(sixDigitHex(a)).map(hexParse),
                                _hex$exec$map2 = _slicedToArray(_hex$exec$map, 4),
                                _a3 = _hex$exec$map2[1],
                                _b3 = _hex$exec$map2[2],
                                _c3 = _hex$exec$map2[3];

                            Object.assign(this, {
                                _a: _a3,
                                _b: _b3,
                                _c: _c3,
                                _d: 0,
                                space: 'rgb'
                            });
                        } else throw Error('Unsupported string format, can\'t construct Color');
                    } // Now add the components as a convenience


                    var _a = this._a,
                        _b = this._b,
                        _c = this._c,
                        _d = this._d;
                    var components = this.space === 'rgb' ? {
                        r: _a,
                        g: _b,
                        b: _c
                    } : this.space === 'xyz' ? {
                        x: _a,
                        y: _b,
                        z: _c
                    } : this.space === 'hsl' ? {
                        h: _a,
                        s: _b,
                        l: _c
                    } : this.space === 'lab' ? {
                        l: _a,
                        a: _b,
                        b: _c
                    } : this.space === 'lch' ? {
                        l: _a,
                        c: _b,
                        h: _c
                    } : this.space === 'cmyk' ? {
                        c: _a,
                        m: _b,
                        y: _c,
                        k: _d
                    } : {};
                    Object.assign(this, components);
                }
                /*
                Conversion Methods
                */

            }, {
                key: "rgb",
                value: function rgb() {
                    if (this.space === 'rgb') {
                        return this;
                    } else if (cieSpace(this.space)) {
                        // Convert to the xyz color space
                        var x = this.x,
                            y = this.y,
                            z = this.z;

                        if (this.space === 'lab' || this.space === 'lch') {
                            // Get the values in the lab space
                            var l = this.l,
                                a = this.a,
                                _b4 = this.b;

                            if (this.space === 'lch') {
                                var c = this.c,
                                    h = this.h;
                                var dToR = Math.PI / 180;
                                a = c * Math.cos(dToR * h);
                                _b4 = c * Math.sin(dToR * h);
                            } // Undo the nonlinear function


                            var yL = (l + 16) / 116;
                            var xL = a / 500 + yL;
                            var zL = yL - _b4 / 200; // Get the xyz values

                            var ct = 16 / 116;
                            var mx = 0.008856;
                            var nm = 7.787;
                            x = 0.95047 * (Math.pow(xL, 3) > mx ? Math.pow(xL, 3) : (xL - ct) / nm);
                            y = 1.00000 * (Math.pow(yL, 3) > mx ? Math.pow(yL, 3) : (yL - ct) / nm);
                            z = 1.08883 * (Math.pow(zL, 3) > mx ? Math.pow(zL, 3) : (zL - ct) / nm);
                        } // Convert xyz to unbounded rgb values


                        var rU = x * 3.2406 + y * -1.5372 + z * -0.4986;
                        var gU = x * -0.9689 + y * 1.8758 + z * 0.0415;
                        var bU = x * 0.0557 + y * -0.2040 + z * 1.0570; // Convert the values to true rgb values

                        var pow = Math.pow;
                        var bd = 0.0031308;
                        var r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
                        var g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
                        var b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU; // Make and return the color

                        var color = new Color(255 * r, 255 * g, 255 * b);
                        return color;
                    } else if (this.space === 'hsl') {
                        // https://bgrins.github.io/TinyColor/docs/tinycolor.html
                        // Get the current hsl values
                        var _h = this.h,
                            s = this.s,
                            _l = this.l;
                        _h /= 360;
                        s /= 100;
                        _l /= 100; // If we are grey, then just make the color directly

                        if (s === 0) {
                            _l *= 255;

                            var _color2 = new Color(_l, _l, _l);

                            return _color2;
                        } // TODO I have no idea what this does :D If you figure it out, tell me!


                        var q = _l < 0.5 ? _l * (1 + s) : _l + s - _l * s;
                        var p = 2 * _l - q; // Get the rgb values

                        var _r = 255 * hueToRgb(p, q, _h + 1 / 3);

                        var _g = 255 * hueToRgb(p, q, _h);

                        var _b5 = 255 * hueToRgb(p, q, _h - 1 / 3); // Make a new color


                        var _color = new Color(_r, _g, _b5);

                        return _color;
                    } else if (this.space === 'cmyk') {
                        // https://gist.github.com/felipesabino/5066336
                        // Get the normalised cmyk values
                        var _c4 = this.c,
                            m = this.m,
                            _y = this.y,
                            k = this.k; // Get the rgb values

                        var _r2 = 255 * (1 - Math.min(1, _c4 * (1 - k) + k));

                        var _g2 = 255 * (1 - Math.min(1, m * (1 - k) + k));

                        var _b6 = 255 * (1 - Math.min(1, _y * (1 - k) + k)); // Form the color and return it


                        var _color3 = new Color(_r2, _g2, _b6);

                        return _color3;
                    } else {
                        return this;
                    }
                }
            }, {
                key: "lab",
                value: function lab() {
                    // Get the xyz color
                    var _this$xyz = this.xyz(),
                        x = _this$xyz.x,
                        y = _this$xyz.y,
                        z = _this$xyz.z; // Get the lab components


                    var l = 116 * y - 16;
                    var a = 500 * (x - y);
                    var b = 200 * (y - z); // Construct and return a new color

                    var color = new Color(l, a, b, 'lab');
                    return color;
                }
            }, {
                key: "xyz",
                value: function xyz() {
                    // Normalise the red, green and blue values
                    var _this$rgb = this.rgb(),
                        r255 = _this$rgb._a,
                        g255 = _this$rgb._b,
                        b255 = _this$rgb._c;

                    var _map = [r255, g255, b255].map(function (v) {
                        return v / 255;
                    }),
                        _map2 = _slicedToArray(_map, 3),
                        r = _map2[0],
                        g = _map2[1],
                        b = _map2[2]; // Convert to the lab rgb space


                    var rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                    var gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                    var bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92; // Convert to the xyz color space without bounding the values

                    var xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
                    var yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.00000;
                    var zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883; // Get the proper xyz values by applying the bounding

                    var x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
                    var y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
                    var z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116; // Make and return the color

                    var color = new Color(x, y, z, 'xyz');
                    return color;
                }
            }, {
                key: "lch",
                value: function lch() {
                    // Get the lab color directly
                    var _this$lab = this.lab(),
                        l = _this$lab.l,
                        a = _this$lab.a,
                        b = _this$lab.b; // Get the chromaticity and the hue using polar coordinates


                    var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
                    var h = 180 * Math.atan2(b, a) / Math.PI;

                    if (h < 0) {
                        h *= -1;
                        h = 360 - h;
                    } // Make a new color and return it


                    var color = new Color(l, c, h, 'lch');
                    return color;
                }
            }, {
                key: "hsl",
                value: function hsl() {
                    // Get the rgb values
                    var _this$rgb2 = this.rgb(),
                        _a = _this$rgb2._a,
                        _b = _this$rgb2._b,
                        _c = _this$rgb2._c;

                    var _map3 = [_a, _b, _c].map(function (v) {
                        return v / 255;
                    }),
                        _map4 = _slicedToArray(_map3, 3),
                        r = _map4[0],
                        g = _map4[1],
                        b = _map4[2]; // Find the maximum and minimum values to get the lightness


                    var max = Math.max(r, g, b);
                    var min = Math.min(r, g, b);
                    var l = (max + min) / 2; // If the r, g, v values are identical then we are grey

                    var isGrey = max === min; // Calculate the hue and saturation

                    var delta = max - min;
                    var s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
                    var h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0; // Construct and return the new color

                    var color = new Color(360 * h, 100 * s, 100 * l, 'hsl');
                    return color;
                }
            }, {
                key: "cmyk",
                value: function cmyk() {
                    // Get the rgb values for the current color
                    var _this$rgb3 = this.rgb(),
                        _a = _this$rgb3._a,
                        _b = _this$rgb3._b,
                        _c = _this$rgb3._c;

                    var _map5 = [_a, _b, _c].map(function (v) {
                        return v / 255;
                    }),
                        _map6 = _slicedToArray(_map5, 3),
                        r = _map6[0],
                        g = _map6[1],
                        b = _map6[2]; // Get the cmyk values in an unbounded format


                    var k = Math.min(1 - r, 1 - g, 1 - b);

                    if (k === 1) {
                        // Catch the black case
                        return new Color(0, 0, 0, 1, 'cmyk');
                    }

                    var c = (1 - r - k) / (1 - k);
                    var m = (1 - g - k) / (1 - k);
                    var y = (1 - b - k) / (1 - k); // Construct the new color

                    var color = new Color(c, m, y, k, 'cmyk');
                    return color;
                }
                /*
                Input and Output methods
                */

            }, {
                key: "_clamped",
                value: function _clamped() {
                    var _this$rgb4 = this.rgb(),
                        _a = _this$rgb4._a,
                        _b = _this$rgb4._b,
                        _c = _this$rgb4._c;

                    var max = Math.max,
                        min = Math.min,
                        round = Math.round;

                    var format = function format(v) {
                        return max(0, min(round(v), 255));
                    };

                    return [_a, _b, _c].map(format);
                }
            }, {
                key: "toHex",
                value: function toHex() {
                    var _this$_clamped$map = this._clamped().map(componentHex),
                        _this$_clamped$map2 = _slicedToArray(_this$_clamped$map, 3),
                        r = _this$_clamped$map2[0],
                        g = _this$_clamped$map2[1],
                        b = _this$_clamped$map2[2];

                    return "#".concat(r).concat(g).concat(b);
                }
            }, {
                key: "toString",
                value: function toString() {
                    return this.toHex();
                }
            }, {
                key: "toRgb",
                value: function toRgb() {
                    var _this$_clamped = this._clamped(),
                        _this$_clamped2 = _slicedToArray(_this$_clamped, 3),
                        rV = _this$_clamped2[0],
                        gV = _this$_clamped2[1],
                        bV = _this$_clamped2[2];

                    var string = "rgb(".concat(rV, ",").concat(gV, ",").concat(bV, ")");
                    return string;
                }
            }, {
                key: "toArray",
                value: function toArray() {
                    var _a = this._a,
                        _b = this._b,
                        _c = this._c,
                        _d = this._d,
                        space = this.space;
                    return [_a, _b, _c, _d, space];
                }
                /*
                Generating random colors
                */

            }], [{
                key: "random",
                value: function random() {
                    var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'vibrant';
                    var t = arguments.length > 1 ? arguments[1] : undefined;
                    // Get the math modules
                    var random = Math.random,
                        round = Math.round,
                        sin = Math.sin,
                        pi = Math.PI; // Run the correct generator

                    if (mode === 'vibrant') {
                        var l = (81 - 57) * random() + 57;
                        var c = (83 - 45) * random() + 45;
                        var h = 360 * random();
                        var color = new Color(l, c, h, 'lch');
                        return color;
                    } else if (mode === 'sine') {
                        t = t == null ? random() : t;
                        var r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);
                        var g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);
                        var b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);

                        var _color4 = new Color(r, g, b);

                        return _color4;
                    } else if (mode === 'pastel') {
                        var _l2 = (94 - 86) * random() + 86;

                        var _c5 = (26 - 9) * random() + 9;

                        var _h2 = 360 * random();

                        var _color5 = new Color(_l2, _c5, _h2, 'lch');

                        return _color5;
                    } else if (mode === 'dark') {
                        var _l3 = 10 + 10 * random();

                        var _c6 = (125 - 75) * random() + 86;

                        var _h3 = 360 * random();

                        var _color6 = new Color(_l3, _c6, _h3, 'lch');

                        return _color6;
                    } else if (mode === 'rgb') {
                        var _r3 = 255 * random();

                        var _g3 = 255 * random();

                        var _b7 = 255 * random();

                        var _color7 = new Color(_r3, _g3, _b7);

                        return _color7;
                    } else if (mode === 'lab') {
                        var _l4 = 100 * random();

                        var a = 256 * random() - 128;

                        var _b8 = 256 * random() - 128;

                        var _color8 = new Color(_l4, a, _b8, 'lab');

                        return _color8;
                    } else if (mode === 'grey') {
                        var grey = 255 * random();

                        var _color9 = new Color(grey, grey, grey);

                        return _color9;
                    }
                }
                /*
                Constructing colors
                */
                // Test if given value is a color string

            }, {
                key: "test",
                value: function test(color) {
                    return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));
                } // Test if given value is an rgb object

            }, {
                key: "isRgb",
                value: function isRgb(color) {
                    return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';
                } // Test if given value is a color

            }, {
                key: "isColor",
                value: function isColor(color) {
                    return color && (color instanceof Color || this.isRgb(color) || this.test(color));
                }
            }]);

            return Color;
        }();

    var FAILS_ON_PRIMITIVES$1 = fails(function () { objectKeys(1); });

    // `Object.keys` method
    // https://tc39.github.io/ecma262/#sec-object.keys
    _export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$1 }, {
        keys: function keys(it) {
            return objectKeys(toObject(it));
        }
    });

    // @@match logic
    fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
        return [
            // `String.prototype.match` method
            // https://tc39.github.io/ecma262/#sec-string.prototype.match
            function match(regexp) {
                var O = requireObjectCoercible(this);
                var matcher = regexp == undefined ? undefined : regexp[MATCH];
                return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
            },
            // `RegExp.prototype[@@match]` method
            // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
            function (regexp) {
                var res = maybeCallNative(nativeMatch, regexp, this);
                if (res.done) return res.value;

                var rx = anObject(regexp);
                var S = String(this);

                if (!rx.global) return regexpExecAbstract(rx, S);

                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
                var A = [];
                var n = 0;
                var result;
                while ((result = regexpExecAbstract(rx, S)) !== null) {
                    var matchStr = String(result[0]);
                    A[n] = matchStr;
                    if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                    n++;
                }
                return n === 0 ? null : A;
            }
        ];
    });

    function _assertThisInitialized(self) {
        if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
    }

    function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call;
        }

        return _assertThisInitialized(self);
    }

    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
    }

    function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break;
        }

        return object;
    }

    function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
            _get = Reflect.get;
        } else {
            _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);
                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);

                if (desc.get) {
                    return desc.get.call(receiver);
                }

                return desc.value;
            };
        }

        return _get(target, property, receiver || target);
    }

    function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
        };

        return _setPrototypeOf(o, p);
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: true,
                configurable: true
            }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
    }

    var getOwnPropertyNames = objectGetOwnPropertyNames.f;
    var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
    var defineProperty$5 = objectDefineProperty.f;
    var trim$1 = stringTrim.trim;

    var NUMBER = 'Number';
    var NativeNumber = global_1[NUMBER];
    var NumberPrototype = NativeNumber.prototype;

    // Opera ~12 has broken Object#toString
    var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;

    // `ToNumber` abstract operation
    // https://tc39.github.io/ecma262/#sec-tonumber
    var toNumber = function (argument) {
        var it = toPrimitive(argument, false);
        var first, third, radix, maxCode, digits, length, index, code;
        if (typeof it == 'string' && it.length > 2) {
            it = trim$1(it);
            first = it.charCodeAt(0);
            if (first === 43 || first === 45) {
                third = it.charCodeAt(2);
                if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
            } else if (first === 48) {
                switch (it.charCodeAt(1)) {
                    case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
                    case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
                    default: return +it;
                }
                digits = it.slice(2);
                length = digits.length;
                for (index = 0; index < length; index++) {
                    code = digits.charCodeAt(index);
                    // parseInt parses a string to a first unavailable symbol
                    // but ToNumber should return NaN if a string contains unavailable symbols
                    if (code < 48 || code > maxCode) return NaN;
                } return parseInt(digits, radix);
            }
        } return +it;
    };

    // `Number` constructor
    // https://tc39.github.io/ecma262/#sec-number-constructor
    if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
        var NumberWrapper = function Number(value) {
            var it = arguments.length < 1 ? 0 : value;
            var dummy = this;
            return dummy instanceof NumberWrapper
                // check on 1..constructor(foo) case
                && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
                ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
        };
        for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : (
            // ES3:
            'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
            // ES2015 (in case, if modules with ES2015 Number statics required before):
            'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
            'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
        ).split(','), j = 0, key; keys$1.length > j; j++) {
            if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
                defineProperty$5(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
            }
        }
        NumberWrapper.prototype = NumberPrototype;
        NumberPrototype.constructor = NumberWrapper;
        redefine(global_1, NUMBER, NumberWrapper);
    }

    var trim$2 = stringTrim.trim;


    var nativeParseFloat = global_1.parseFloat;
    var FORCED$2 = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity;

    // `parseFloat` method
    // https://tc39.github.io/ecma262/#sec-parsefloat-string
    var _parseFloat = FORCED$2 ? function parseFloat(string) {
        var trimmedString = trim$2(String(string));
        var result = nativeParseFloat(trimmedString);
        return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
    } : nativeParseFloat;

    // `parseFloat` method
    // https://tc39.github.io/ecma262/#sec-parsefloat-string
    _export({ global: true, forced: parseFloat != _parseFloat }, {
        parseFloat: _parseFloat
    });

    var Point =
        /*#__PURE__*/
        function () {
            // Initialize
            function Point() {
                _classCallCheck(this, Point);

                this.init.apply(this, arguments);
            }

            _createClass(Point, [{
                key: "init",
                value: function init(x, y) {
                    var base = {
                        x: 0,
                        y: 0
                    }; // ensure source as object

                    var source = Array.isArray(x) ? {
                        x: x[0],
                        y: x[1]
                    } : _typeof(x) === 'object' ? {
                        x: x.x,
                        y: x.y
                    } : {
                        x: x,
                        y: y
                    }; // merge source

                    this.x = source.x == null ? base.x : source.x;
                    this.y = source.y == null ? base.y : source.y;
                    return this;
                } // Clone point

            }, {
                key: "clone",
                value: function clone() {
                    return new Point(this);
                }
            }, {
                key: "transform",
                value: function transform(m) {
                    return this.clone().transformO(m);
                } // Transform point with matrix

            }, {
                key: "transformO",
                value: function transformO(m) {
                    if (!Matrix.isMatrixLike(m)) {
                        m = new Matrix(m);
                    }

                    var x = this.x,
                        y = this.y; // Perform the matrix multiplication

                    this.x = m.a * x + m.c * y + m.e;
                    this.y = m.b * x + m.d * y + m.f;
                    return this;
                }
            }, {
                key: "toArray",
                value: function toArray() {
                    return [this.x, this.y];
                }
            }]);

            return Point;
        }();
    function point(x, y) {
        return new Point(x, y).transform(this.screenCTM().inverse());
    }

    function closeEnough(a, b, threshold) {
        return Math.abs(b - a) < (threshold || 1e-6);
    }

    var Matrix =
        /*#__PURE__*/
        function () {
            function Matrix() {
                _classCallCheck(this, Matrix);

                this.init.apply(this, arguments);
            } // Initialize


            _createClass(Matrix, [{
                key: "init",
                value: function init(source) {
                    var base = Matrix.fromArray([1, 0, 0, 1, 0, 0]); // ensure source as object

                    source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : _typeof(source) === 'object' && Matrix.isMatrixLike(source) ? source : _typeof(source) === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base; // Merge the source matrix with the base matrix

                    this.a = source.a != null ? source.a : base.a;
                    this.b = source.b != null ? source.b : base.b;
                    this.c = source.c != null ? source.c : base.c;
                    this.d = source.d != null ? source.d : base.d;
                    this.e = source.e != null ? source.e : base.e;
                    this.f = source.f != null ? source.f : base.f;
                    return this;
                } // Clones this matrix

            }, {
                key: "clone",
                value: function clone() {
                    return new Matrix(this);
                } // Transform a matrix into another matrix by manipulating the space

            }, {
                key: "transform",
                value: function transform(o) {
                    // Check if o is a matrix and then left multiply it directly
                    if (Matrix.isMatrixLike(o)) {
                        var matrix = new Matrix(o);
                        return matrix.multiplyO(this);
                    } // Get the proposed transformations and the current transformations


                    var t = Matrix.formatTransforms(o);
                    var current = this;

                    var _transform = new Point(t.ox, t.oy).transform(current),
                        ox = _transform.x,
                        oy = _transform.y; // Construct the resulting matrix


                    var transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy); // If we want the origin at a particular place, we force it there

                    if (isFinite(t.px) || isFinite(t.py)) {
                        var origin = new Point(ox, oy).transform(transformer); // TODO: Replace t.px with isFinite(t.px)

                        var dx = t.px ? t.px - origin.x : 0;
                        var dy = t.py ? t.py - origin.y : 0;
                        transformer.translateO(dx, dy);
                    } // Translate now after positioning


                    transformer.translateO(t.tx, t.ty);
                    return transformer;
                } // Applies a matrix defined by its affine parameters

            }, {
                key: "compose",
                value: function compose(o) {
                    if (o.origin) {
                        o.originX = o.origin[0];
                        o.originY = o.origin[1];
                    } // Get the parameters


                    var ox = o.originX || 0;
                    var oy = o.originY || 0;
                    var sx = o.scaleX || 1;
                    var sy = o.scaleY || 1;
                    var lam = o.shear || 0;
                    var theta = o.rotate || 0;
                    var tx = o.translateX || 0;
                    var ty = o.translateY || 0; // Apply the standard matrix

                    var result = new Matrix().translateO(-ox, -oy).scaleO(sx, sy).shearO(lam).rotateO(theta).translateO(tx, ty).lmultiplyO(this).translateO(ox, oy);
                    return result;
                } // Decomposes this matrix into its affine parameters

            }, {
                key: "decompose",
                value: function decompose() {
                    var cx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var cy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    // Get the parameters from the matrix
                    var a = this.a;
                    var b = this.b;
                    var c = this.c;
                    var d = this.d;
                    var e = this.e;
                    var f = this.f; // Figure out if the winding direction is clockwise or counterclockwise

                    var determinant = a * d - b * c;
                    var ccw = determinant > 0 ? 1 : -1; // Since we only shear in x, we can use the x basis to get the x scale
                    // and the rotation of the resulting matrix

                    var sx = ccw * Math.sqrt(a * a + b * b);
                    var thetaRad = Math.atan2(ccw * b, ccw * a);
                    var theta = 180 / Math.PI * thetaRad;
                    var ct = Math.cos(thetaRad);
                    var st = Math.sin(thetaRad); // We can then solve the y basis vector simultaneously to get the other
                    // two affine parameters directly from these parameters

                    var lam = (a * c + b * d) / determinant;
                    var sy = c * sx / (lam * a - b) || d * sx / (lam * b + a); // Use the translations

                    var tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);
                    var ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy); // Construct the decomposition and return it

                    return {
                        // Return the affine parameters
                        scaleX: sx,
                        scaleY: sy,
                        shear: lam,
                        rotate: theta,
                        translateX: tx,
                        translateY: ty,
                        originX: cx,
                        originY: cy,
                        // Return the matrix parameters
                        a: this.a,
                        b: this.b,
                        c: this.c,
                        d: this.d,
                        e: this.e,
                        f: this.f
                    };
                } // Left multiplies by the given matrix

            }, {
                key: "multiply",
                value: function multiply(matrix) {
                    return this.clone().multiplyO(matrix);
                }
            }, {
                key: "multiplyO",
                value: function multiplyO(matrix) {
                    // Get the matrices
                    var l = this;
                    var r = matrix instanceof Matrix ? matrix : new Matrix(matrix);
                    return Matrix.matrixMultiply(l, r, this);
                }
            }, {
                key: "lmultiply",
                value: function lmultiply(matrix) {
                    return this.clone().lmultiplyO(matrix);
                }
            }, {
                key: "lmultiplyO",
                value: function lmultiplyO(matrix) {
                    var r = this;
                    var l = matrix instanceof Matrix ? matrix : new Matrix(matrix);
                    return Matrix.matrixMultiply(l, r, this);
                } // Inverses matrix

            }, {
                key: "inverseO",
                value: function inverseO() {
                    // Get the current parameters out of the matrix
                    var a = this.a;
                    var b = this.b;
                    var c = this.c;
                    var d = this.d;
                    var e = this.e;
                    var f = this.f; // Invert the 2x2 matrix in the top left

                    var det = a * d - b * c;
                    if (!det) throw new Error('Cannot invert ' + this); // Calculate the top 2x2 matrix

                    var na = d / det;
                    var nb = -b / det;
                    var nc = -c / det;
                    var nd = a / det; // Apply the inverted matrix to the top right

                    var ne = -(na * e + nc * f);
                    var nf = -(nb * e + nd * f); // Construct the inverted matrix

                    this.a = na;
                    this.b = nb;
                    this.c = nc;
                    this.d = nd;
                    this.e = ne;
                    this.f = nf;
                    return this;
                }
            }, {
                key: "inverse",
                value: function inverse() {
                    return this.clone().inverseO();
                } // Translate matrix

            }, {
                key: "translate",
                value: function translate(x, y) {
                    return this.clone().translateO(x, y);
                }
            }, {
                key: "translateO",
                value: function translateO(x, y) {
                    this.e += x || 0;
                    this.f += y || 0;
                    return this;
                } // Scale matrix

            }, {
                key: "scale",
                value: function scale(x, y, cx, cy) {
                    var _this$clone;

                    return (_this$clone = this.clone()).scaleO.apply(_this$clone, arguments);
                }
            }, {
                key: "scaleO",
                value: function scaleO(x) {
                    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
                    var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                    var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

                    // Support uniform scaling
                    if (arguments.length === 3) {
                        cy = cx;
                        cx = y;
                        y = x;
                    }

                    var a = this.a,
                        b = this.b,
                        c = this.c,
                        d = this.d,
                        e = this.e,
                        f = this.f;
                    this.a = a * x;
                    this.b = b * y;
                    this.c = c * x;
                    this.d = d * y;
                    this.e = e * x - cx * x + cx;
                    this.f = f * y - cy * y + cy;
                    return this;
                } // Rotate matrix

            }, {
                key: "rotate",
                value: function rotate(r, cx, cy) {
                    return this.clone().rotateO(r, cx, cy);
                }
            }, {
                key: "rotateO",
                value: function rotateO(r) {
                    var cx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                    // Convert degrees to radians
                    r = radians(r);
                    var cos = Math.cos(r);
                    var sin = Math.sin(r);
                    var a = this.a,
                        b = this.b,
                        c = this.c,
                        d = this.d,
                        e = this.e,
                        f = this.f;
                    this.a = a * cos - b * sin;
                    this.b = b * cos + a * sin;
                    this.c = c * cos - d * sin;
                    this.d = d * cos + c * sin;
                    this.e = e * cos - f * sin + cy * sin - cx * cos + cx;
                    this.f = f * cos + e * sin - cx * sin - cy * cos + cy;
                    return this;
                } // Flip matrix on x or y, at a given offset

            }, {
                key: "flip",
                value: function flip(axis, around) {
                    return this.clone().flipO(axis, around);
                }
            }, {
                key: "flipO",
                value: function flipO(axis, around) {
                    return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point
                } // Shear matrix

            }, {
                key: "shear",
                value: function shear(a, cx, cy) {
                    return this.clone().shearO(a, cx, cy);
                }
            }, {
                key: "shearO",
                value: function shearO(lx) {
                    var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                    var a = this.a,
                        b = this.b,
                        c = this.c,
                        d = this.d,
                        e = this.e,
                        f = this.f;
                    this.a = a + b * lx;
                    this.c = c + d * lx;
                    this.e = e + f * lx - cy * lx;
                    return this;
                } // Skew Matrix

            }, {
                key: "skew",
                value: function skew(x, y, cx, cy) {
                    var _this$clone2;

                    return (_this$clone2 = this.clone()).skewO.apply(_this$clone2, arguments);
                }
            }, {
                key: "skewO",
                value: function skewO(x) {
                    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
                    var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                    var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

                    // support uniformal skew
                    if (arguments.length === 3) {
                        cy = cx;
                        cx = y;
                        y = x;
                    } // Convert degrees to radians


                    x = radians(x);
                    y = radians(y);
                    var lx = Math.tan(x);
                    var ly = Math.tan(y);
                    var a = this.a,
                        b = this.b,
                        c = this.c,
                        d = this.d,
                        e = this.e,
                        f = this.f;
                    this.a = a + b * lx;
                    this.b = b + a * ly;
                    this.c = c + d * lx;
                    this.d = d + c * ly;
                    this.e = e + f * lx - cy * lx;
                    this.f = f + e * ly - cx * ly;
                    return this;
                } // SkewX

            }, {
                key: "skewX",
                value: function skewX(x, cx, cy) {
                    return this.skew(x, 0, cx, cy);
                }
            }, {
                key: "skewXO",
                value: function skewXO(x, cx, cy) {
                    return this.skewO(x, 0, cx, cy);
                } // SkewY

            }, {
                key: "skewY",
                value: function skewY(y, cx, cy) {
                    return this.skew(0, y, cx, cy);
                }
            }, {
                key: "skewYO",
                value: function skewYO(y, cx, cy) {
                    return this.skewO(0, y, cx, cy);
                } // Transform around a center point

            }, {
                key: "aroundO",
                value: function aroundO(cx, cy, matrix) {
                    var dx = cx || 0;
                    var dy = cy || 0;
                    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);
                }
            }, {
                key: "around",
                value: function around(cx, cy, matrix) {
                    return this.clone().aroundO(cx, cy, matrix);
                } // Check if two matrices are equal

            }, {
                key: "equals",
                value: function equals(other) {
                    var comp = new Matrix(other);
                    return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);
                } // Convert matrix to string

            }, {
                key: "toString",
                value: function toString() {
                    return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';
                }
            }, {
                key: "toArray",
                value: function toArray() {
                    return [this.a, this.b, this.c, this.d, this.e, this.f];
                }
            }, {
                key: "valueOf",
                value: function valueOf() {
                    return {
                        a: this.a,
                        b: this.b,
                        c: this.c,
                        d: this.d,
                        e: this.e,
                        f: this.f
                    };
                }
            }], [{
                key: "fromArray",
                value: function fromArray(a) {
                    return {
                        a: a[0],
                        b: a[1],
                        c: a[2],
                        d: a[3],
                        e: a[4],
                        f: a[5]
                    };
                }
            }, {
                key: "isMatrixLike",
                value: function isMatrixLike(o) {
                    return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;
                }
            }, {
                key: "formatTransforms",
                value: function formatTransforms(o) {
                    // Get all of the parameters required to form the matrix
                    var flipBoth = o.flip === 'both' || o.flip === true;
                    var flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;
                    var flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;
                    var skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;
                    var skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;
                    var scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;
                    var scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;
                    var shear = o.shear || 0;
                    var theta = o.rotate || o.theta || 0;
                    var origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);
                    var ox = origin.x;
                    var oy = origin.y;
                    var position = new Point(o.position || o.px || o.positionX, o.py || o.positionY);
                    var px = position.x;
                    var py = position.y;
                    var translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);
                    var tx = translate.x;
                    var ty = translate.y;
                    var relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);
                    var rx = relative.x;
                    var ry = relative.y; // Populate all of the values

                    return {
                        scaleX: scaleX,
                        scaleY: scaleY,
                        skewX: skewX,
                        skewY: skewY,
                        shear: shear,
                        theta: theta,
                        rx: rx,
                        ry: ry,
                        tx: tx,
                        ty: ty,
                        ox: ox,
                        oy: oy,
                        px: px,
                        py: py
                    };
                } // left matrix, right matrix, target matrix which is overwritten

            }, {
                key: "matrixMultiply",
                value: function matrixMultiply(l, r, o) {
                    // Work out the product directly
                    var a = l.a * r.a + l.c * r.b;
                    var b = l.b * r.a + l.d * r.b;
                    var c = l.a * r.c + l.c * r.d;
                    var d = l.b * r.c + l.d * r.d;
                    var e = l.e + l.a * r.e + l.c * r.f;
                    var f = l.f + l.b * r.e + l.d * r.f; // make sure to use local variables because l/r and o could be the same

                    o.a = a;
                    o.b = b;
                    o.c = c;
                    o.d = d;
                    o.e = e;
                    o.f = f;
                    return o;
                }
            }]);

            return Matrix;
        }();
    function ctm() {
        return new Matrix(this.node.getCTM());
    }
    function screenCTM() {
        /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
           This is needed because FF does not return the transformation matrix
           for the inner coordinate system when getScreenCTM() is called on nested svgs.
           However all other Browsers do that */
        if (typeof this.isRoot === 'function' && !this.isRoot()) {
            var rect = this.rect(1, 1);
            var m = rect.node.getScreenCTM();
            rect.remove();
            return new Matrix(m);
        }

        return new Matrix(this.node.getScreenCTM());
    }
    register(Matrix, 'Matrix');

    function parser() {
        // Reuse cached element if possible
        if (!parser.nodes) {
            var svg = makeInstance().size(2, 0);
            svg.node.style.cssText = ['opacity: 0', 'position: absolute', 'left: -100%', 'top: -100%', 'overflow: hidden'].join(';');
            svg.attr('focusable', 'false');
            svg.attr('aria-hidden', 'true');
            var path = svg.path().node;
            parser.nodes = {
                svg: svg,
                path: path
            };
        }

        if (!parser.nodes.svg.node.parentNode) {
            var b = globals.document.body || globals.document.documentElement;
            parser.nodes.svg.addTo(b);
        }

        return parser.nodes;
    }

    function isNulledBox(box) {
        return !box.width && !box.height && !box.x && !box.y;
    }

    function domContains(node) {
        return node === globals.document || (globals.document.documentElement.contains || function (node) {
            // This is IE - it does not support contains() for top-level SVGs
            while (node.parentNode) {
                node = node.parentNode;
            }

            return node === globals.document;
        }).call(globals.document.documentElement, node);
    }

    var Box =
        /*#__PURE__*/
        function () {
            function Box() {
                _classCallCheck(this, Box);

                this.init.apply(this, arguments);
            }

            _createClass(Box, [{
                key: "init",
                value: function init(source) {
                    var base = [0, 0, 0, 0];
                    source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : _typeof(source) === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;
                    this.x = source[0] || 0;
                    this.y = source[1] || 0;
                    this.width = this.w = source[2] || 0;
                    this.height = this.h = source[3] || 0; // Add more bounding box properties

                    this.x2 = this.x + this.w;
                    this.y2 = this.y + this.h;
                    this.cx = this.x + this.w / 2;
                    this.cy = this.y + this.h / 2;
                    return this;
                } // Merge rect box with another, return a new instance

            }, {
                key: "merge",
                value: function merge(box) {
                    var x = Math.min(this.x, box.x);
                    var y = Math.min(this.y, box.y);
                    var width = Math.max(this.x + this.width, box.x + box.width) - x;
                    var height = Math.max(this.y + this.height, box.y + box.height) - y;
                    return new Box(x, y, width, height);
                }
            }, {
                key: "transform",
                value: function transform(m) {
                    if (!(m instanceof Matrix)) {
                        m = new Matrix(m);
                    }

                    var xMin = Infinity;
                    var xMax = -Infinity;
                    var yMin = Infinity;
                    var yMax = -Infinity;
                    var pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];
                    pts.forEach(function (p) {
                        p = p.transform(m);
                        xMin = Math.min(xMin, p.x);
                        xMax = Math.max(xMax, p.x);
                        yMin = Math.min(yMin, p.y);
                        yMax = Math.max(yMax, p.y);
                    });
                    return new Box(xMin, yMin, xMax - xMin, yMax - yMin);
                }
            }, {
                key: "addOffset",
                value: function addOffset() {
                    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
                    this.x += globals.window.pageXOffset;
                    this.y += globals.window.pageYOffset;
                    // mercator
                    this.x2 += globals.window.pageXOffset;
                    this.y2 += globals.window.pageYOffset;
                    this.cx = this.x + this.w / 2;
                    this.cy = this.y + this.h / 2;
                    return this;
                }
            }, {
                key: "toString",
                value: function toString() {
                    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;
                }
            }, {
                key: "toArray",
                value: function toArray() {
                    return [this.x, this.y, this.width, this.height];
                }
            }, {
                key: "isNulled",
                value: function isNulled() {
                    return isNulledBox(this);
                }
            }]);

            return Box;
        }();

    function getBox(cb, retry) {
        var box;

        try {
            box = cb(this.node);

            if (isNulledBox(box) && !domContains(this.node)) {
                throw new Error('Element not in the dom');
            }
        } catch (e) {
            box = retry(this);
        }

        return box;
    }

    function bbox() {
        return new Box(getBox.call(this, function (node) {
            return node.getBBox();
        }, function (el) {
            try {
                var clone = el.clone().addTo(parser().svg).show();
                var box = clone.node.getBBox();
                clone.remove();
                return box;
            } catch (e) {
                throw new Error('Getting bbox of element "' + el.node.nodeName + '" is not possible. ' + e.toString());
            }
        }));
    }
    function rbox(el) {
        var box = new Box(getBox.call(this, function (node) {
            return node.getBoundingClientRect();
        }, function (el) {
            throw new Error('Getting rbox of element "' + el.node.nodeName + '" is not possible');
        }));
        if (el) return box.transform(el.screenCTM().inverse());
        return box.addOffset();
    }
    registerMethods({
        viewbox: {
            viewbox: function viewbox(x, y, width, height) {
                // act as getter
                if (x == null) return new Box(this.attr('viewBox')); // act as setter

                return this.attr('viewBox', new Box(x, y, width, height));
            },
            zoom: function zoom(level, point) {
                var width = this.node.clientWidth;
                var height = this.node.clientHeight;
                var v = this.viewbox(); // Firefox does not support clientHeight and returns 0
                // https://bugzilla.mozilla.org/show_bug.cgi?id=874811

                if (!width && !height) {
                    var style = window.getComputedStyle(this.node);
                    width = parseFloat(style.getPropertyValue('width'));
                    height = parseFloat(style.getPropertyValue('height'));
                }

                var zoomX = width / v.width;
                var zoomY = height / v.height;
                var zoom = Math.min(zoomX, zoomY);

                if (level == null) {
                    return zoom;
                }

                var zoomAmount = zoom / level;
                if (zoomAmount === Infinity) zoomAmount = Number.MIN_VALUE;
                point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);
                var box = new Box(v).transform(new Matrix({
                    scale: zoomAmount,
                    origin: point
                }));
                return this.viewbox(box);
            }
        }
    });
    register(Box, 'Box');

    /* eslint no-new-func: "off" */
    var subClassArray = function () {
        try {
            // try es6 subclassing
            return Function('name', 'baseClass', '_constructor', ['baseClass = baseClass || Array', 'return {', '  [name]: class extends baseClass {', '    constructor (...args) {', '      super(...args)', '      _constructor && _constructor.apply(this, args)', '    }', '  }', '}[name]'].join('\n'));
        } catch (e) {
            // Use es5 approach
            return function (name) {
                var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Array;

                var _constructor = arguments.length > 2 ? arguments[2] : undefined;

                var Arr = function Arr() {
                    baseClass.apply(this, arguments);
                    _constructor && _constructor.apply(this, arguments);
                };

                Arr.prototype = Object.create(baseClass.prototype);
                Arr.prototype.constructor = Arr;

                Arr.prototype.map = function (fn) {
                    var arr = new Arr();
                    arr.push.apply(arr, Array.prototype.map.call(this, fn));
                    return arr;
                };

                return Arr;
            };
        }
    }();

    var List = subClassArray('List', Array, function () {
        var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        // This catches the case, that native map tries to create an array with new Array(1)
        if (typeof arr === 'number') return this;
        this.length = 0;
        this.push.apply(this, _toConsumableArray(arr));
    });
    extend(List, {
        each: function each(fnOrMethodName) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            if (typeof fnOrMethodName === 'function') {
                return this.map(function (el) {
                    return fnOrMethodName.call(el, el);
                });
            } else {
                return this.map(function (el) {
                    return el[fnOrMethodName].apply(el, args);
                });
            }
        },
        toArray: function toArray() {
            return Array.prototype.concat.apply([], this);
        }
    });
    var reserved = ['toArray', 'constructor', 'each'];

    List.extend = function (methods) {
        methods = methods.reduce(function (obj, name) {
            // Don't overwrite own methods
            if (reserved.includes(name)) return obj; // Don't add private methods

            if (name[0] === '_') return obj; // Relay every call to each()

            obj[name] = function () {
                for (var _len2 = arguments.length, attrs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    attrs[_key2] = arguments[_key2];
                }

                return this.each.apply(this, [name].concat(attrs));
            };

            return obj;
        }, {});
        extend(List, methods);
    };

    function baseFind(query, parent) {
        return new List(map((parent || globals.document).querySelectorAll(query), function (node) {
            return adopt(node);
        }));
    } // Scoped find method

    function find(query) {
        return baseFind(query, this.node);
    }
    function findOne(query) {
        return adopt(this.node.querySelector(query));
    }

    var EventTarget =
        /*#__PURE__*/
        function (_Base) {
            _inherits(EventTarget, _Base);

            function EventTarget() {
                var _this;

                var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    _ref$events = _ref.events,
                    events = _ref$events === void 0 ? {} : _ref$events;

                _classCallCheck(this, EventTarget);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(EventTarget).call(this));
                _this.events = events;
                return _this;
            }

            _createClass(EventTarget, [{
                key: "addEventListener",
                value: function addEventListener() { }
            }, {
                key: "dispatch",
                value: function dispatch$1(event, data) {
                    return dispatch(this, event, data);
                }
            }, {
                key: "dispatchEvent",
                value: function dispatchEvent(event) {
                    var bag = this.getEventHolder().events;
                    if (!bag) return true;
                    var events = bag[event.type];

                    for (var i in events) {
                        for (var j in events[i]) {
                            events[i][j](event);
                        }
                    }

                    return !event.defaultPrevented;
                } // Fire given event

            }, {
                key: "fire",
                value: function fire(event, data) {
                    this.dispatch(event, data);
                    return this;
                }
            }, {
                key: "getEventHolder",
                value: function getEventHolder() {
                    return this;
                }
            }, {
                key: "getEventTarget",
                value: function getEventTarget() {
                    return this;
                } // Unbind event from listener

            }, {
                key: "off",
                value: function off$1(event, listener) {
                    off(this, event, listener);

                    return this;
                } // Bind given event to listener

            }, {
                key: "on",
                value: function on$1(event, listener, binding, options) {
                    on(this, event, listener, binding, options);

                    return this;
                }
            }, {
                key: "removeEventListener",
                value: function removeEventListener() { }
            }]);

            return EventTarget;
        }(Base);
    register(EventTarget, 'EventTarget');

    function noop() { } // Default animation values

    var timeline = {
        duration: 400,
        ease: '>',
        delay: 0
    }; // Default attribute values

    var attrs = {
        // fill and stroke
        'fill-opacity': 1,
        'stroke-opacity': 1,
        'stroke-width': 0,
        'stroke-linejoin': 'miter',
        'stroke-linecap': 'butt',
        fill: '#000000',
        stroke: '#000000',
        opacity: 1,
        // position
        x: 0,
        y: 0,
        cx: 0,
        cy: 0,
        // size
        width: 0,
        height: 0,
        // radius
        r: 0,
        rx: 0,
        ry: 0,
        // gradient
        offset: 0,
        'stop-opacity': 1,
        'stop-color': '#000000',
        // text
        'text-anchor': 'start'
    };

    var defaults = ({
        __proto__: null,
        noop: noop,
        timeline: timeline,
        attrs: attrs
    });

    var SVGArray = subClassArray('SVGArray', Array, function (arr) {
        this.init(arr);
    });
    extend(SVGArray, {
        init: function init(arr) {
            // This catches the case, that native map tries to create an array with new Array(1)
            if (typeof arr === 'number') return this;
            this.length = 0;
            this.push.apply(this, _toConsumableArray(this.parse(arr)));
            return this;
        },
        toArray: function toArray() {
            return Array.prototype.concat.apply([], this);
        },
        toString: function toString() {
            return this.join(' ');
        },
        // Flattens the array if needed
        valueOf: function valueOf() {
            var ret = [];
            ret.push.apply(ret, _toConsumableArray(this));
            return ret;
        },
        // Parse whitespace separated string
        parse: function parse() {
            var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            // If already is an array, no need to parse it
            if (array instanceof Array) return array;
            return array.trim().split(delimiter).map(parseFloat);
        },
        clone: function clone() {
            return new this.constructor(this);
        },
        toSet: function toSet() {
            return new Set(this);
        }
    });

    var SVGNumber =
        /*#__PURE__*/
        function () {
            // Initialize
            function SVGNumber() {
                _classCallCheck(this, SVGNumber);

                this.init.apply(this, arguments);
            }

            _createClass(SVGNumber, [{
                key: "init",
                value: function init(value, unit) {
                    unit = Array.isArray(value) ? value[1] : unit;
                    value = Array.isArray(value) ? value[0] : value; // initialize defaults

                    this.value = 0;
                    this.unit = unit || ''; // parse value

                    if (typeof value === 'number') {
                        // ensure a valid numeric value
                        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;
                    } else if (typeof value === 'string') {
                        unit = value.match(numberAndUnit);

                        if (unit) {
                            // make value numeric
                            this.value = parseFloat(unit[1]); // normalize

                            if (unit[5] === '%') {
                                this.value /= 100;
                            } else if (unit[5] === 's') {
                                this.value *= 1000;
                            } // store unit


                            this.unit = unit[5];
                        }
                    } else {
                        if (value instanceof SVGNumber) {
                            this.value = value.valueOf();
                            this.unit = value.unit;
                        }
                    }

                    return this;
                }
            }, {
                key: "toString",
                value: function toString() {
                    return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;
                }
            }, {
                key: "toJSON",
                value: function toJSON() {
                    return this.toString();
                }
            }, {
                key: "toArray",
                value: function toArray() {
                    return [this.value, this.unit];
                }
            }, {
                key: "valueOf",
                value: function valueOf() {
                    return this.value;
                } // Add number

            }, {
                key: "plus",
                value: function plus(number) {
                    number = new SVGNumber(number);
                    return new SVGNumber(this + number, this.unit || number.unit);
                } // Subtract number

            }, {
                key: "minus",
                value: function minus(number) {
                    number = new SVGNumber(number);
                    return new SVGNumber(this - number, this.unit || number.unit);
                } // Multiply number

            }, {
                key: "times",
                value: function times(number) {
                    number = new SVGNumber(number);
                    return new SVGNumber(this * number, this.unit || number.unit);
                } // Divide number

            }, {
                key: "divide",
                value: function divide(number) {
                    number = new SVGNumber(number);
                    return new SVGNumber(this / number, this.unit || number.unit);
                }
            }, {
                key: "convert",
                value: function convert(unit) {
                    return new SVGNumber(this.value, unit);
                }
            }]);

            return SVGNumber;
        }();

    var hooks = [];
    function registerAttrHook(fn) {
        hooks.push(fn);
    } // Set svg element attribute

    function attr(attr, val, ns) {
        var _this = this;

        // act as full getter
        if (attr == null) {
            // get an object of attributes
            attr = {};
            val = this.node.attributes;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = val[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var node = _step.value;
                    attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return attr;
        } else if (attr instanceof Array) {
            // loop through array and get all values
            return attr.reduce(function (last, curr) {
                last[curr] = _this.attr(curr);
                return last;
            }, {});
        } else if (_typeof(attr) === 'object' && attr.constructor === Object) {
            // apply every attribute individually if an object is passed
            for (val in attr) {
                this.attr(val, attr[val]);
            }
        } else if (val === null) {
            // remove value
            this.node.removeAttribute(attr);
        } else if (val == null) {
            // act as a getter if the first and only argument is not an object
            val = this.node.getAttribute(attr);
            return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;
        } else {
            // Loop through hooks and execute them to convert value
            val = hooks.reduce(function (_val, hook) {
                return hook(attr, _val, _this);
            }, val); // ensure correct numeric values (also accepts NaN and Infinity)

            if (typeof val === 'number') {
                val = new SVGNumber(val);
            } else if (Color.isColor(val)) {
                // ensure full hex color
                val = new Color(val);
            } else if (val.constructor === Array) {
                // Check for plain arrays and parse array values
                val = new SVGArray(val);
            } // if the passed attribute is leading...


            if (attr === 'leading') {
                // ... call the leading method instead
                if (this.leading) {
                    this.leading(val);
                }
            } else {
                // set given attribute on node
                typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());
            } // rebuild if required


            if (this.rebuild && (attr === 'font-size' || attr === 'x')) {
                this.rebuild();
            }
        }

        return this;
    }

    var Dom =
        /*#__PURE__*/
        function (_EventTarget) {
            _inherits(Dom, _EventTarget);

            function Dom(node, attrs) {
                var _this2;

                _classCallCheck(this, Dom);

                _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Dom).call(this, node));
                _this2.node = node;
                _this2.type = node.nodeName;

                if (attrs && node !== attrs) {
                    _this2.attr(attrs);
                }

                return _this2;
            } // Add given element at a position


            _createClass(Dom, [{
                key: "add",
                value: function add(element, i) {
                    element = makeInstance(element);

                    if (i == null) {
                        this.node.appendChild(element.node);
                    } else if (element.node !== this.node.childNodes[i]) {
                        this.node.insertBefore(element.node, this.node.childNodes[i]);
                    }

                    return this;
                } // Add element to given container and return self

            }, {
                key: "addTo",
                value: function addTo(parent) {
                    return makeInstance(parent).put(this);
                } // Returns all child elements

            }, {
                key: "children",
                value: function children() {
                    return new List(map(this.node.children, function (node) {
                        return adopt(node);
                    }));
                } // Remove all elements in this container

            }, {
                key: "clear",
                value: function clear() {
                    // remove children
                    while (this.node.hasChildNodes()) {
                        this.node.removeChild(this.node.lastChild);
                    }

                    return this;
                } // Clone element

            }, {
                key: "clone",
                value: function clone() {
                    // write dom data to the dom so the clone can pickup the data
                    this.writeDataToDom(); // clone element and assign new id

                    return assignNewId(this.node.cloneNode(true));
                } // Iterates over all children and invokes a given block

            }, {
                key: "each",
                value: function each(block, deep) {
                    var children = this.children();
                    var i, il;

                    for (i = 0, il = children.length; i < il; i++) {
                        block.apply(children[i], [i, children]);

                        if (deep) {
                            children[i].each(block, deep);
                        }
                    }

                    return this;
                }
            }, {
                key: "element",
                value: function element(nodeName) {
                    return this.put(new Dom(create(nodeName)));
                } // Get first child

            }, {
                key: "first",
                value: function first() {
                    return adopt(this.node.firstChild);
                } // Get a element at the given index

            }, {
                key: "get",
                value: function get(i) {
                    return adopt(this.node.childNodes[i]);
                }
            }, {
                key: "getEventHolder",
                value: function getEventHolder() {
                    return this.node;
                }
            }, {
                key: "getEventTarget",
                value: function getEventTarget() {
                    return this.node;
                } // Checks if the given element is a child

            }, {
                key: "has",
                value: function has(element) {
                    return this.index(element) >= 0;
                } // Get / set id

            }, {
                key: "id",
                value: function id(_id) {
                    // generate new id if no id set
                    if (typeof _id === 'undefined' && !this.node.id) {
                        this.node.id = eid(this.type);
                    } // dont't set directly width this.node.id to make `null` work correctly


                    return this.attr('id', _id);
                } // Gets index of given element

            }, {
                key: "index",
                value: function index(element) {
                    return [].slice.call(this.node.childNodes).indexOf(element.node);
                } // Get the last child

            }, {
                key: "last",
                value: function last() {
                    return adopt(this.node.lastChild);
                } // matches the element vs a css selector

            }, {
                key: "matches",
                value: function matches(selector) {
                    var el = this.node;
                    return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
                } // Returns the parent element instance

            }, {
                key: "parent",
                value: function parent(type) {
                    var parent = this; // check for parent

                    if (!parent.node.parentNode) return null; // get parent element

                    parent = adopt(parent.node.parentNode);
                    if (!type) return parent; // loop trough ancestors if type is given

                    while (parent) {
                        if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;
                        if (!parent.node.parentNode || parent.node.parentNode.nodeName === '#document' || parent.node.parentNode.nodeName === '#document-fragment') return null; // #759, #720

                        parent = adopt(parent.node.parentNode);
                    }
                } // Basically does the same as `add()` but returns the added element instead

            }, {
                key: "put",
                value: function put(element, i) {
                    this.add(element, i);
                    return element;
                } // Add element to given container and return container

            }, {
                key: "putIn",
                value: function putIn(parent) {
                    return makeInstance(parent).add(this);
                } // Remove element

            }, {
                key: "remove",
                value: function remove() {
                    if (this.parent()) {
                        this.parent().removeElement(this);
                    }

                    return this;
                } // Remove a given child

            }, {
                key: "removeElement",
                value: function removeElement(element) {
                    this.node.removeChild(element.node);
                    return this;
                } // Replace this with element

            }, {
                key: "replace",
                value: function replace(element) {
                    element = makeInstance(element);
                    this.node.parentNode.replaceChild(element.node, this.node);
                    return element;
                }
            }, {
                key: "round",
                value: function round() {
                    var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
                    var map = arguments.length > 1 ? arguments[1] : undefined;
                    var factor = Math.pow(10, precision);
                    var attrs = this.attr(); // If we have no map, build one from attrs

                    if (!map) {
                        map = Object.keys(attrs);
                    } // Holds rounded attributes


                    var newAttrs = {};
                    map.forEach(function (key) {
                        newAttrs[key] = Math.round(attrs[key] * factor) / factor;
                    });
                    this.attr(newAttrs);
                    return this;
                } // Return id on string conversion

            }, {
                key: "toString",
                value: function toString() {
                    return this.id();
                } // Import raw svg

            }, {
                key: "svg",
                value: function svg(svgOrFn, outerHTML) {
                    var well, len, fragment;

                    if (svgOrFn === false) {
                        outerHTML = false;
                        svgOrFn = null;
                    } // act as getter if no svg string is given


                    if (svgOrFn == null || typeof svgOrFn === 'function') {
                        // The default for exports is, that the outerNode is included
                        outerHTML = outerHTML == null ? true : outerHTML; // write svgjs data to the dom

                        this.writeDataToDom();
                        var current = this; // An export modifier was passed

                        if (svgOrFn != null) {
                            current = adopt(current.node.cloneNode(true)); // If the user wants outerHTML we need to process this node, too

                            if (outerHTML) {
                                var result = svgOrFn(current);
                                current = result || current; // The user does not want this node? Well, then he gets nothing

                                if (result === false) return '';
                            } // Deep loop through all children and apply modifier


                            current.each(function () {
                                var result = svgOrFn(this);

                                var _this = result || this; // If modifier returns false, discard node


                                if (result === false) {
                                    this.remove(); // If modifier returns new node, use it
                                } else if (result && this !== _this) {
                                    this.replace(_this);
                                }
                            }, true);
                        } // Return outer or inner content


                        return outerHTML ? current.node.outerHTML : current.node.innerHTML;
                    } // Act as setter if we got a string
                    // The default for import is, that the current node is not replaced


                    outerHTML = outerHTML == null ? false : outerHTML; // Create temporary holder

                    well = globals.document.createElementNS(ns, 'svg');
                    fragment = globals.document.createDocumentFragment(); // Dump raw svg

                    well.innerHTML = svgOrFn; // Transplant nodes into the fragment

                    for (len = well.children.length; len--;) {
                        fragment.appendChild(well.firstElementChild);
                    }

                    var parent = this.parent(); // Add the whole fragment at once

                    return outerHTML ? this.replace(fragment) && parent : this.add(fragment);
                }
            }, {
                key: "words",
                value: function words(text) {
                    // This is faster than removing all children and adding a new one
                    this.node.textContent = text;
                    return this;
                } // write svgjs data to the dom

            }, {
                key: "writeDataToDom",
                value: function writeDataToDom() {
                    // dump variables recursively
                    this.each(function () {
                        this.writeDataToDom();
                    });
                    return this;
                }
            }]);

            return Dom;
        }(EventTarget);
    extend(Dom, {
        attr: attr,
        find: find,
        findOne: findOne
    });
    register(Dom, 'Dom');

    var Element =
        /*#__PURE__*/
        function (_Dom) {
            _inherits(Element, _Dom);

            function Element(node, attrs) {
                var _this;

                _classCallCheck(this, Element);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this, node, attrs)); // initialize data object

                _this.dom = {}; // create circular reference

                _this.node.instance = _assertThisInitialized(_this);

                if (node.hasAttribute('svgjs:data')) {
                    // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
                    _this.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});
                }

                return _this;
            } // Move element by its center


            _createClass(Element, [{
                key: "center",
                value: function center(x, y) {
                    return this.cx(x).cy(y);
                } // Move by center over x-axis

            }, {
                key: "cx",
                value: function cx(x) {
                    return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);
                } // Move by center over y-axis

            }, {
                key: "cy",
                value: function cy(y) {
                    return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);
                } // Get defs

            }, {
                key: "defs",
                value: function defs() {
                    return this.root().defs();
                } // Relative move over x and y axes

            }, {
                key: "dmove",
                value: function dmove(x, y) {
                    return this.dx(x).dy(y);
                } // Relative move over x axis

            }, {
                key: "dx",
                value: function dx() {
                    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    return this.x(new SVGNumber(x).plus(this.x()));
                } // Relative move over y axis

            }, {
                key: "dy",
                value: function dy() {
                    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    return this.y(new SVGNumber(y).plus(this.y()));
                } // Get parent document

            }, {
                key: "root",
                value: function root$1() {
                    var p = this.parent(getClass(root));
                    return p && p.root();
                }
            }, {
                key: "getEventHolder",
                value: function getEventHolder() {
                    return this;
                } // Set height of element

            }, {
                key: "height",
                value: function height(_height) {
                    return this.attr('height', _height);
                } // Checks whether the given point inside the bounding box of the element

            }, {
                key: "inside",
                value: function inside(x, y) {
                    var box = this.bbox();
                    return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;
                } // Move element to given x and y values

            }, {
                key: "move",
                value: function move(x, y) {
                    return this.x(x).y(y);
                } // return array of all ancestors of given type up to the root svg

            }, {
                key: "parents",
                value: function parents() {
                    var until = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : globals.document;
                    until = makeInstance(until);
                    var parents = new List();
                    var parent = this;

                    while ((parent = parent.parent()) && parent.node !== until.node && parent.node !== globals.document) {
                        parents.push(parent);
                    }

                    return parents;
                } // Get referenced element form attribute value

            }, {
                key: "reference",
                value: function reference$1(attr) {
                    attr = this.attr(attr);
                    if (!attr) return null;
                    var m = attr.match(reference);
                    return m ? makeInstance(m[1]) : null;
                } // set given data to the elements data property

            }, {
                key: "setData",
                value: function setData(o) {
                    this.dom = o;
                    return this;
                } // Set element size to given width and height

            }, {
                key: "size",
                value: function size(width, height) {
                    var p = proportionalSize(this, width, height);
                    return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));
                } // Set width of element

            }, {
                key: "width",
                value: function width(_width) {
                    return this.attr('width', _width);
                } // write svgjs data to the dom

            }, {
                key: "writeDataToDom",
                value: function writeDataToDom() {
                    // remove previously set data
                    this.node.removeAttribute('svgjs:data');

                    if (Object.keys(this.dom).length) {
                        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)); // see #428
                    }

                    return _get(_getPrototypeOf(Element.prototype), "writeDataToDom", this).call(this);
                } // Move over x-axis

            }, {
                key: "x",
                value: function x(_x) {
                    return this.attr('x', _x);
                } // Move over y-axis

            }, {
                key: "y",
                value: function y(_y) {
                    return this.attr('y', _y);
                }
            }]);

            return Element;
        }(Dom);
    extend(Element, {
        bbox: bbox,
        rbox: rbox,
        point: point,
        ctm: ctm,
        screenCTM: screenCTM
    });
    register(Element, 'Element');

    var sugar = {
        stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],
        fill: ['color', 'opacity', 'rule'],
        prefix: function prefix(t, a) {
            return a === 'color' ? t : t + '-' + a;
        }
    } // Add sugar for fill and stroke
        ;
    ['fill', 'stroke'].forEach(function (m) {
        var extension = {};
        var i;

        extension[m] = function (o) {
            if (typeof o === 'undefined') {
                return this.attr(m);
            }

            if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) {
                this.attr(m, o);
            } else {
                // set all attributes from sugar.fill and sugar.stroke list
                for (i = sugar[m].length - 1; i >= 0; i--) {
                    if (o[sugar[m][i]] != null) {
                        this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
                    }
                }
            }

            return this;
        };

        registerMethods(['Element', 'Runner'], extension);
    });
    registerMethods(['Element', 'Runner'], {
        // Let the user set the matrix directly
        matrix: function matrix(mat, b, c, d, e, f) {
            // Act as a getter
            if (mat == null) {
                return new Matrix(this);
            } // Act as a setter, the user can pass a matrix or a set of numbers


            return this.attr('transform', new Matrix(mat, b, c, d, e, f));
        },
        // Map rotation to transform
        rotate: function rotate(angle, cx, cy) {
            return this.transform({
                rotate: angle,
                ox: cx,
                oy: cy
            }, true);
        },
        // Map skew to transform
        skew: function skew(x, y, cx, cy) {
            return arguments.length === 1 || arguments.length === 3 ? this.transform({
                skew: x,
                ox: y,
                oy: cx
            }, true) : this.transform({
                skew: [x, y],
                ox: cx,
                oy: cy
            }, true);
        },
        shear: function shear(lam, cx, cy) {
            return this.transform({
                shear: lam,
                ox: cx,
                oy: cy
            }, true);
        },
        // Map scale to transform
        scale: function scale(x, y, cx, cy) {
            return arguments.length === 1 || arguments.length === 3 ? this.transform({
                scale: x,
                ox: y,
                oy: cx
            }, true) : this.transform({
                scale: [x, y],
                ox: cx,
                oy: cy
            }, true);
        },
        // Map translate to transform
        translate: function translate(x, y) {
            return this.transform({
                translate: [x, y]
            }, true);
        },
        // Map relative translations to transform
        relative: function relative(x, y) {
            return this.transform({
                relative: [x, y]
            }, true);
        },
        // Map flip to transform
        flip: function flip(direction, around) {
            var directionString = typeof direction === 'string' ? direction : isFinite(direction) ? 'both' : 'both';
            var origin = direction === 'both' && isFinite(around) ? [around, around] : direction === 'x' ? [around, 0] : direction === 'y' ? [0, around] : isFinite(direction) ? [direction, direction] : [0, 0];
            return this.transform({
                flip: directionString,
                origin: origin
            }, true);
        },
        // Opacity
        opacity: function opacity(value) {
            return this.attr('opacity', value);
        }
    });
    registerMethods('radius', {
        // Add x and y radius
        radius: function radius(x, y) {
            var type = (this._element || this).type;
            return type === 'radialGradient' || type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y == null ? x : y);
        }
    });
    registerMethods('Path', {
        // Get path length
        length: function length() {
            return this.node.getTotalLength();
        },
        // Get point at length
        pointAt: function pointAt(length) {
            return new Point(this.node.getPointAtLength(length));
        }
    });
    registerMethods(['Element', 'Runner'], {
        // Set font
        font: function font(a, v) {
            if (_typeof(a) === 'object') {
                for (v in a) {
                    this.font(v, a[v]);
                }

                return this;
            }

            return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);
        }
    });
    registerMethods('Text', {
        ax: function ax(x) {
            return this.attr('x', x);
        },
        ay: function ay(y) {
            return this.attr('y', y);
        },
        amove: function amove(x, y) {
            return this.ax(x).ay(y);
        }
    }); // Add events to elements

    var methods$1 = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].reduce(function (last, event) {
        // add event to Element
        var fn = function fn(f) {
            if (f === null) {
                off(this, event);
            } else {
                on(this, event, f);
            }

            return this;
        };

        last[event] = fn;
        return last;
    }, {});
    registerMethods('Element', methods$1);

    var nativeReverse = [].reverse;
    var test$1 = [1, 2];

    // `Array.prototype.reverse` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reverse
    // fix for Safari 12.0 bug
    // https://bugs.webkit.org/show_bug.cgi?id=188794
    _export({ target: 'Array', proto: true, forced: String(test$1) === String(test$1.reverse()) }, {
        reverse: function reverse() {
            // eslint-disable-next-line no-self-assign
            if (isArray(this)) this.length = this.length;
            return nativeReverse.call(this);
        }
    });

    // `Object.defineProperties` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperties
    _export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
        defineProperties: objectDefineProperties
    });

    // `Object.defineProperty` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperty
    _export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
        defineProperty: objectDefineProperty.f
    });

    var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;


    var FAILS_ON_PRIMITIVES$2 = fails(function () { nativeGetOwnPropertyDescriptor$2(1); });
    var FORCED$3 = !descriptors || FAILS_ON_PRIMITIVES$2;

    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
    _export({ target: 'Object', stat: true, forced: FORCED$3, sham: !descriptors }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
            return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
        }
    });

    // `Object.getOwnPropertyDescriptors` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
    _export({ target: 'Object', stat: true, sham: !descriptors }, {
        getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
            var O = toIndexedObject(object);
            var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
            var keys = ownKeys(O);
            var result = {};
            var index = 0;
            var key, descriptor;
            while (keys.length > index) {
                descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
                if (descriptor !== undefined) createProperty(result, key, descriptor);
            }
            return result;
        }
    });

    function _defineProperty(obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            obj[key] = value;
        }

        return obj;
    }

    function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function untransform() {
        return this.attr('transform', null);
    } // merge the whole transformation chain into one matrix and returns it

    function matrixify() {
        var matrix = (this.attr('transform') || ''). // split transformations
            split(transforms).slice(0, -1).map(function (str) {
                // generate key => value pairs
                var kv = str.trim().split('(');
                return [kv[0], kv[1].split(delimiter).map(function (str) {
                    return parseFloat(str);
                })];
            }).reverse() // merge every transformation into one matrix
            .reduce(function (matrix, transform) {
                if (transform[0] === 'matrix') {
                    return matrix.lmultiply(Matrix.fromArray(transform[1]));
                }

                return matrix[transform[0]].apply(matrix, transform[1]);
            }, new Matrix());
        return matrix;
    } // add an element to another parent without changing the visual representation on the screen

    function toParent(parent) {
        if (this === parent) return this;
        var ctm = this.screenCTM();
        var pCtm = parent.screenCTM().inverse();
        this.addTo(parent).untransform().transform(pCtm.multiply(ctm));
        return this;
    } // same as above with parent equals root-svg

    function toRoot() {
        return this.toParent(this.root());
    } // Add transformations

    function transform(o, relative) {
        // Act as a getter if no object was passed
        if (o == null || typeof o === 'string') {
            var decomposed = new Matrix(this).decompose();
            return o == null ? decomposed : decomposed[o];
        }

        if (!Matrix.isMatrixLike(o)) {
            // Set the origin according to the defined transform
            o = _objectSpread({}, o, {
                origin: getOrigin(o, this)
            });
        } // The user can pass a boolean, an Element or an Matrix or nothing


        var cleanRelative = relative === true ? this : relative || false;
        var result = new Matrix(cleanRelative).transform(o);
        return this.attr('transform', result);
    }
    registerMethods('Element', {
        untransform: untransform,
        matrixify: matrixify,
        toParent: toParent,
        toRoot: toRoot,
        transform: transform
    });

    function rx(rx) {
        return this.attr('rx', rx);
    } // Radius y value

    function ry(ry) {
        return this.attr('ry', ry);
    } // Move over x-axis

    function x(x) {
        return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());
    } // Move over y-axis

    function y(y) {
        return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());
    } // Move by center over x-axis

    function cx(x) {
        return x == null ? this.attr('cx') : this.attr('cx', x);
    } // Move by center over y-axis

    function cy(y) {
        return y == null ? this.attr('cy') : this.attr('cy', y);
    } // Set width of element

    function width(width) {
        return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));
    } // Set height of element

    function height(height) {
        return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));
    }

    var circled = ({
        __proto__: null,
        rx: rx,
        ry: ry,
        x: x,
        y: y,
        cx: cx,
        cy: cy,
        width: width,
        height: height
    });

    var Shape =
        /*#__PURE__*/
        function (_Element) {
            _inherits(Shape, _Element);

            function Shape() {
                _classCallCheck(this, Shape);

                return _possibleConstructorReturn(this, _getPrototypeOf(Shape).apply(this, arguments));
            }

            return Shape;
        }(Element);
    register(Shape, 'Shape');

    var Circle =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Circle, _Shape);

            function Circle(node) {
                _classCallCheck(this, Circle);

                return _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, nodeOrNew('circle', node), node));
            }

            _createClass(Circle, [{
                key: "radius",
                value: function radius(r) {
                    return this.attr('r', r);
                } // Radius x value

            }, {
                key: "rx",
                value: function rx(_rx) {
                    return this.attr('r', _rx);
                } // Alias radius x value

            }, {
                key: "ry",
                value: function ry(_ry) {
                    return this.rx(_ry);
                }
            }, {
                key: "size",
                value: function size(_size) {
                    return this.radius(new SVGNumber(_size).divide(2));
                }
            }]);

            return Circle;
        }(Shape);
    extend(Circle, {
        x: x,
        y: y,
        cx: cx,
        cy: cy,
        width: width,
        height: height
    });
    registerMethods({
        Container: {
            // Create circle element
            circle: wrapWithAttrCheck(function (size) {
                return this.put(new Circle()).size(size).move(0, 0);
            })
        }
    });
    register(Circle, 'Circle');

    var Container =
        /*#__PURE__*/
        function (_Element) {
            _inherits(Container, _Element);

            function Container() {
                _classCallCheck(this, Container);

                return _possibleConstructorReturn(this, _getPrototypeOf(Container).apply(this, arguments));
            }

            _createClass(Container, [{
                key: "flatten",
                value: function flatten(parent) {
                    this.each(function () {
                        if (this instanceof Container) return this.flatten(parent).ungroup(parent);
                        return this.toParent(parent);
                    }); // we need this so that the root does not get removed

                    this.node.firstElementChild || this.remove();
                    return this;
                }
            }, {
                key: "ungroup",
                value: function ungroup(parent) {
                    parent = parent || this.parent();
                    this.each(function () {
                        return this.toParent(parent);
                    });
                    this.remove();
                    return this;
                }
            }]);

            return Container;
        }(Element);
    register(Container, 'Container');

    var Defs =
        /*#__PURE__*/
        function (_Container) {
            _inherits(Defs, _Container);

            function Defs(node) {
                _classCallCheck(this, Defs);

                return _possibleConstructorReturn(this, _getPrototypeOf(Defs).call(this, nodeOrNew('defs', node), node));
            }

            _createClass(Defs, [{
                key: "flatten",
                value: function flatten() {
                    return this;
                }
            }, {
                key: "ungroup",
                value: function ungroup() {
                    return this;
                }
            }]);

            return Defs;
        }(Container);
    register(Defs, 'Defs');

    var Ellipse =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Ellipse, _Shape);

            function Ellipse(node) {
                _classCallCheck(this, Ellipse);

                return _possibleConstructorReturn(this, _getPrototypeOf(Ellipse).call(this, nodeOrNew('ellipse', node), node));
            }

            _createClass(Ellipse, [{
                key: "size",
                value: function size(width, height) {
                    var p = proportionalSize(this, width, height);
                    return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));
                }
            }]);

            return Ellipse;
        }(Shape);
    extend(Ellipse, circled);
    registerMethods('Container', {
        // Create an ellipse
        ellipse: wrapWithAttrCheck(function () {
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
            return this.put(new Ellipse()).size(width, height).move(0, 0);
        })
    });
    register(Ellipse, 'Ellipse');

    var Stop =
        /*#__PURE__*/
        function (_Element) {
            _inherits(Stop, _Element);

            function Stop(node) {
                _classCallCheck(this, Stop);

                return _possibleConstructorReturn(this, _getPrototypeOf(Stop).call(this, nodeOrNew('stop', node), node));
            } // add color stops


            _createClass(Stop, [{
                key: "update",
                value: function update(o) {
                    if (typeof o === 'number' || o instanceof SVGNumber) {
                        o = {
                            offset: arguments[0],
                            color: arguments[1],
                            opacity: arguments[2]
                        };
                    } // set attributes


                    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
                    if (o.color != null) this.attr('stop-color', o.color);
                    if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));
                    return this;
                }
            }]);

            return Stop;
        }(Element);
    register(Stop, 'Stop');

    function from(x, y) {
        return (this._element || this).type === 'radialGradient' ? this.attr({
            fx: new SVGNumber(x),
            fy: new SVGNumber(y)
        }) : this.attr({
            x1: new SVGNumber(x),
            y1: new SVGNumber(y)
        });
    }
    function to(x, y) {
        return (this._element || this).type === 'radialGradient' ? this.attr({
            cx: new SVGNumber(x),
            cy: new SVGNumber(y)
        }) : this.attr({
            x2: new SVGNumber(x),
            y2: new SVGNumber(y)
        });
    }

    var gradiented = ({
        __proto__: null,
        from: from,
        to: to
    });

    var Gradient =
        /*#__PURE__*/
        function (_Container) {
            _inherits(Gradient, _Container);

            function Gradient(type, attrs) {
                _classCallCheck(this, Gradient);

                return _possibleConstructorReturn(this, _getPrototypeOf(Gradient).call(this, nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs));
            } // Add a color stop


            _createClass(Gradient, [{
                key: "stop",
                value: function stop(offset, color, opacity) {
                    return this.put(new Stop()).update(offset, color, opacity);
                } // Update gradient

            }, {
                key: "update",
                value: function update(block) {
                    // remove all stops
                    this.clear(); // invoke passed block

                    if (typeof block === 'function') {
                        block.call(this, this);
                    }

                    return this;
                } // Return the fill id

            }, {
                key: "url",
                value: function url() {
                    return 'url(#' + this.id() + ')';
                } // Alias string convertion to fill

            }, {
                key: "toString",
                value: function toString() {
                    return this.url();
                } // custom attr to handle transform

            }, {
                key: "attr",
                value: function attr(a, b, c) {
                    if (a === 'transform') a = 'gradientTransform';
                    return _get(_getPrototypeOf(Gradient.prototype), "attr", this).call(this, a, b, c);
                }
            }, {
                key: "targets",
                value: function targets() {
                    return baseFind('svg [fill*="' + this.id() + '"]');
                }
            }, {
                key: "bbox",
                value: function bbox() {
                    return new Box();
                }
            }]);

            return Gradient;
        }(Container);
    extend(Gradient, gradiented);
    registerMethods({
        Container: {
            // Create gradient element in defs
            gradient: wrapWithAttrCheck(function (type, block) {
                return this.defs().gradient(type, block);
            })
        },
        // define gradient
        Defs: {
            gradient: wrapWithAttrCheck(function (type, block) {
                return this.put(new Gradient(type)).update(block);
            })
        }
    });
    register(Gradient, 'Gradient');

    var Pattern =
        /*#__PURE__*/
        function (_Container) {
            _inherits(Pattern, _Container);

            // Initialize node
            function Pattern(node) {
                _classCallCheck(this, Pattern);

                return _possibleConstructorReturn(this, _getPrototypeOf(Pattern).call(this, nodeOrNew('pattern', node), node));
            } // Return the fill id


            _createClass(Pattern, [{
                key: "url",
                value: function url() {
                    return 'url(#' + this.id() + ')';
                } // Update pattern by rebuilding

            }, {
                key: "update",
                value: function update(block) {
                    // remove content
                    this.clear(); // invoke passed block

                    if (typeof block === 'function') {
                        block.call(this, this);
                    }

                    return this;
                } // Alias string convertion to fill

            }, {
                key: "toString",
                value: function toString() {
                    return this.url();
                } // custom attr to handle transform

            }, {
                key: "attr",
                value: function attr(a, b, c) {
                    if (a === 'transform') a = 'patternTransform';
                    return _get(_getPrototypeOf(Pattern.prototype), "attr", this).call(this, a, b, c);
                }
            }, {
                key: "targets",
                value: function targets() {
                    return baseFind('svg [fill*="' + this.id() + '"]');
                }
            }, {
                key: "bbox",
                value: function bbox() {
                    return new Box();
                }
            }]);

            return Pattern;
        }(Container);
    registerMethods({
        Container: {
            // Create pattern element in defs
            pattern: function pattern() {
                var _this$defs;

                return (_this$defs = this.defs()).pattern.apply(_this$defs, arguments);
            }
        },
        Defs: {
            pattern: wrapWithAttrCheck(function (width, height, block) {
                return this.put(new Pattern()).update(block).attr({
                    x: 0,
                    y: 0,
                    width: width,
                    height: height,
                    patternUnits: 'userSpaceOnUse'
                });
            })
        }
    });
    register(Pattern, 'Pattern');

    var Image =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Image, _Shape);

            function Image(node) {
                _classCallCheck(this, Image);

                return _possibleConstructorReturn(this, _getPrototypeOf(Image).call(this, nodeOrNew('image', node), node));
            } // (re)load image


            _createClass(Image, [{
                key: "load",
                value: function load(url, callback) {
                    if (!url) return this;
                    var img = new globals.window.Image();
                    on(img, 'load', function (e) {
                        var p = this.parent(Pattern); // ensure image size

                        if (this.width() === 0 && this.height() === 0) {
                            this.size(img.width, img.height);
                        }

                        if (p instanceof Pattern) {
                            // ensure pattern size if not set
                            if (p.width() === 0 && p.height() === 0) {
                                p.size(this.width(), this.height());
                            }
                        }

                        if (typeof callback === 'function') {
                            callback.call(this, e);
                        }
                    }, this);
                    on(img, 'load error', function () {
                        // dont forget to unbind memory leaking events
                        off(img);
                    });
                    return this.attr('href', img.src = url, xlink);
                }
            }]);

            return Image;
        }(Shape);
    registerAttrHook(function (attr, val, _this) {
        // convert image fill and stroke to patterns
        if (attr === 'fill' || attr === 'stroke') {
            if (isImage.test(val)) {
                val = _this.root().defs().image(val);
            }
        }

        if (val instanceof Image) {
            val = _this.root().defs().pattern(0, 0, function (pattern) {
                pattern.add(val);
            });
        }

        return val;
    });
    registerMethods({
        Container: {
            // create image element, load image and set its size
            image: wrapWithAttrCheck(function (source, callback) {
                return this.put(new Image()).size(0, 0).load(source, callback);
            })
        }
    });
    register(Image, 'Image');

    var PointArray = subClassArray('PointArray', SVGArray);
    extend(PointArray, {
        // Convert array to string
        toString: function toString() {
            // convert to a poly point string
            for (var i = 0, il = this.length, array = []; i < il; i++) {
                array.push(this[i].join(','));
            }

            return array.join(' ');
        },
        // Convert array to line object
        toLine: function toLine() {
            return {
                x1: this[0][0],
                y1: this[0][1],
                x2: this[1][0],
                y2: this[1][1]
            };
        },
        // Get morphed array at given position
        at: function at(pos) {
            // make sure a destination is defined
            if (!this.destination) return this; // generate morphed point string

            for (var i = 0, il = this.length, array = []; i < il; i++) {
                array.push([this[i][0] + (this.destination[i][0] - this[i][0]) * pos, this[i][1] + (this.destination[i][1] - this[i][1]) * pos]);
            }

            return new PointArray(array);
        },
        // Parse point string and flat array
        parse: function parse() {
            var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[0, 0]];
            var points = []; // if it is an array

            if (array instanceof Array) {
                // and it is not flat, there is no need to parse it
                if (array[0] instanceof Array) {
                    return array;
                }
            } else {
                // Else, it is considered as a string
                // parse points
                array = array.trim().split(delimiter).map(parseFloat);
            } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
            // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.


            if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples

            for (var i = 0, len = array.length; i < len; i = i + 2) {
                points.push([array[i], array[i + 1]]);
            }

            return points;
        },
        // transform points with matrix (similar to Point.transform)
        transform: function transform(m) {
            var points = [];

            for (var i = 0; i < this.length; i++) {
                var point = this[i]; // Perform the matrix multiplication

                points.push([m.a * point[0] + m.c * point[1] + m.e, m.b * point[0] + m.d * point[1] + m.f]);
            } // Return the required point


            return new PointArray(points);
        },
        // Move point string
        move: function move(x, y) {
            var box = this.bbox(); // get relative offset

            x -= box.x;
            y -= box.y; // move every point

            if (!isNaN(x) && !isNaN(y)) {
                for (var i = this.length - 1; i >= 0; i--) {
                    this[i] = [this[i][0] + x, this[i][1] + y];
                }
            }

            return this;
        },
        // Resize poly string
        size: function size(width, height) {
            var i;
            var box = this.bbox(); // recalculate position of all points according to new size

            for (i = this.length - 1; i >= 0; i--) {
                if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;
                if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
            }

            return this;
        },
        // Get bounding box of points
        bbox: function bbox() {
            var maxX = -Infinity;
            var maxY = -Infinity;
            var minX = Infinity;
            var minY = Infinity;
            this.forEach(function (el) {
                maxX = Math.max(el[0], maxX);
                maxY = Math.max(el[1], maxY);
                minX = Math.min(el[0], minX);
                minY = Math.min(el[1], minY);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    });

    var MorphArray = PointArray; // Move by left top corner over x-axis

    function x$1(x) {
        return x == null ? this.bbox().x : this.move(x, this.bbox().y);
    } // Move by left top corner over y-axis

    function y$1(y) {
        return y == null ? this.bbox().y : this.move(this.bbox().x, y);
    } // Set width of element

    function width$1(width) {
        var b = this.bbox();
        return width == null ? b.width : this.size(width, b.height);
    } // Set height of element

    function height$1(height) {
        var b = this.bbox();
        return height == null ? b.height : this.size(b.width, height);
    }

    var pointed = ({
        __proto__: null,
        MorphArray: MorphArray,
        x: x$1,
        y: y$1,
        width: width$1,
        height: height$1
    });

    var Line =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Line, _Shape);

            // Initialize node
            function Line(node) {
                _classCallCheck(this, Line);

                return _possibleConstructorReturn(this, _getPrototypeOf(Line).call(this, nodeOrNew('line', node), node));
            } // Get array


            _createClass(Line, [{
                key: "array",
                value: function array() {
                    return new PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);
                } // Overwrite native plot() method

            }, {
                key: "plot",
                value: function plot(x1, y1, x2, y2) {
                    if (x1 == null) {
                        return this.array();
                    } else if (typeof y1 !== 'undefined') {
                        x1 = {
                            x1: x1,
                            y1: y1,
                            x2: x2,
                            y2: y2
                        };
                    } else {
                        x1 = new PointArray(x1).toLine();
                    }

                    return this.attr(x1);
                } // Move by left top corner

            }, {
                key: "move",
                value: function move(x, y) {
                    return this.attr(this.array().move(x, y).toLine());
                } // Set element size to given width and height

            }, {
                key: "size",
                value: function size(width, height) {
                    var p = proportionalSize(this, width, height);
                    return this.attr(this.array().size(p.width, p.height).toLine());
                }
            }]);

            return Line;
        }(Shape);
    extend(Line, pointed);
    registerMethods({
        Container: {
            // Create a line element
            line: wrapWithAttrCheck(function () {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                // make sure plot is called as a setter
                // x1 is not necessarily a number, it can also be an array, a string and a PointArray
                return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);
            })
        }
    });
    register(Line, 'Line');

    var Marker =
        /*#__PURE__*/
        function (_Container) {
            _inherits(Marker, _Container);

            // Initialize node
            function Marker(node) {
                _classCallCheck(this, Marker);

                return _possibleConstructorReturn(this, _getPrototypeOf(Marker).call(this, nodeOrNew('marker', node), node));
            } // Set width of element


            _createClass(Marker, [{
                key: "width",
                value: function width(_width) {
                    return this.attr('markerWidth', _width);
                } // Set height of element

            }, {
                key: "height",
                value: function height(_height) {
                    return this.attr('markerHeight', _height);
                } // Set marker refX and refY

            }, {
                key: "ref",
                value: function ref(x, y) {
                    return this.attr('refX', x).attr('refY', y);
                } // Update marker

            }, {
                key: "update",
                value: function update(block) {
                    // remove all content
                    this.clear(); // invoke passed block

                    if (typeof block === 'function') {
                        block.call(this, this);
                    }

                    return this;
                } // Return the fill id

            }, {
                key: "toString",
                value: function toString() {
                    return 'url(#' + this.id() + ')';
                }
            }]);

            return Marker;
        }(Container);
    registerMethods({
        Container: {
            marker: function marker() {
                var _this$defs;

                // Create marker element in defs
                return (_this$defs = this.defs()).marker.apply(_this$defs, arguments);
            }
        },
        Defs: {
            // Create marker
            marker: wrapWithAttrCheck(function (width, height, block) {
                // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
                return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);
            })
        },
        marker: {
            // Create and attach markers
            marker: function marker(_marker, width, height, block) {
                var attr = ['marker']; // Build attribute name

                if (_marker !== 'all') attr.push(_marker);
                attr = attr.join('-'); // Set marker attribute

                _marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);
                return this.attr(attr, _marker);
            }
        }
    });
    register(Marker, 'Marker');

    var nativeSort = [].sort;
    var test$2 = [1, 2, 3];

    // IE8-
    var FAILS_ON_UNDEFINED = fails(function () {
        test$2.sort(undefined);
    });
    // V8 bug
    var FAILS_ON_NULL = fails(function () {
        test$2.sort(null);
    });
    // Old WebKit
    var SLOPPY_METHOD$2 = sloppyArrayMethod('sort');

    var FORCED$4 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD$2;

    // `Array.prototype.sort` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.sort
    _export({ target: 'Array', proto: true, forced: FORCED$4 }, {
        sort: function sort(comparefn) {
            return comparefn === undefined
                ? nativeSort.call(toObject(this))
                : nativeSort.call(toObject(this), aFunction$1(comparefn));
        }
    });

    /***
    Base Class
    ==========
    The base stepper class that will be
    ***/

    function makeSetterGetter(k, f) {
        return function (v) {
            if (v == null) return this[v];
            this[k] = v;
            if (f) f.call(this);
            return this;
        };
    }

    var easing = {
        '-': function _(pos) {
            return pos;
        },
        '<>': function _(pos) {
            return -Math.cos(pos * Math.PI) / 2 + 0.5;
        },
        '>': function _(pos) {
            return Math.sin(pos * Math.PI / 2);
        },
        '<': function _(pos) {
            return -Math.cos(pos * Math.PI / 2) + 1;
        },
        easeOutQuint: function (pct) {
            return 1 - Math.pow(1 - pct, 5)
        },
        easeOutExpo: function (ptc) {
            return ptc === 1 ? 1 : 1 - Math.pow(2, -10 * ptc)
        },
        bezier: function bezier(x1, y1, x2, y2) {
            // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo
            return function (t) {
                if (t < 0) {
                    if (x1 > 0) {
                        return y1 / x1 * t;
                    } else if (x2 > 0) {
                        return y2 / x2 * t;
                    } else {
                        return 0;
                    }
                } else if (t > 1) {
                    if (x2 < 1) {
                        return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);
                    } else if (x1 < 1) {
                        return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);
                    } else {
                        return 1;
                    }
                } else {
                    return 3 * t * Math.pow(1 - t, 2) * y1 + 3 * Math.pow(t, 2) * (1 - t) * y2 + Math.pow(t, 3);
                }
            };
        },
        // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
        steps: function steps(_steps) {
            var stepPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'end';
            // deal with "jump-" prefix
            stepPosition = stepPosition.split('-').reverse()[0];
            var jumps = _steps;

            if (stepPosition === 'none') {
                --jumps;
            } else if (stepPosition === 'both') {
                ++jumps;
            } // The beforeFlag is essentially useless


            return function (t) {
                var beforeFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                // Step is called currentStep in referenced url
                var step = Math.floor(t * _steps);
                var jumping = t * step % 1 === 0;

                if (stepPosition === 'start' || stepPosition === 'both') {
                    ++step;
                }

                if (beforeFlag && jumping) {
                    --step;
                }

                if (t >= 0 && step < 0) {
                    step = 0;
                }

                if (t <= 1 && step > jumps) {
                    step = jumps;
                }

                return step / jumps;
            };
        }
    };
    var Stepper =
        /*#__PURE__*/
        function () {
            function Stepper() {
                _classCallCheck(this, Stepper);
            }

            _createClass(Stepper, [{
                key: "done",
                value: function done() {
                    return false;
                }
            }]);

            return Stepper;
        }();
    /***
    Easing Functions
    ================
    ***/

    var Ease =
        /*#__PURE__*/
        function (_Stepper) {
            _inherits(Ease, _Stepper);

            function Ease(fn) {
                var _this;

                _classCallCheck(this, Ease);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Ease).call(this));
                _this.ease = easing[fn || timeline.ease] || fn;
                return _this;
            }

            _createClass(Ease, [{
                key: "step",
                value: function step(from, to, pos) {
                    if (typeof from !== 'number') {
                        return pos < 1 ? from : to;
                    }

                    return from + (to - from) * this.ease(pos);
                }
            }]);

            return Ease;
        }(Stepper);
    /***
    Controller Types
    ================
    ***/

    var Controller =
        /*#__PURE__*/
        function (_Stepper2) {
            _inherits(Controller, _Stepper2);

            function Controller(fn) {
                var _this2;

                _classCallCheck(this, Controller);

                _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Controller).call(this));
                _this2.stepper = fn;
                return _this2;
            }

            _createClass(Controller, [{
                key: "step",
                value: function step(current, target, dt, c) {
                    return this.stepper(current, target, dt, c);
                }
            }, {
                key: "done",
                value: function done(c) {
                    return c.done;
                }
            }]);

            return Controller;
        }(Stepper);

    function recalculate() {
        // Apply the default parameters
        var duration = (this._duration || 500) / 1000;
        var overshoot = this._overshoot || 0; // Calculate the PID natural response

        var eps = 1e-10;
        var pi = Math.PI;
        var os = Math.log(overshoot / 100 + eps);
        var zeta = -os / Math.sqrt(pi * pi + os * os);
        var wn = 3.9 / (zeta * duration); // Calculate the Spring values

        this.d = 2 * zeta * wn;
        this.k = wn * wn;
    }

    var Spring =
        /*#__PURE__*/
        function (_Controller) {
            _inherits(Spring, _Controller);

            function Spring(duration, overshoot) {
                var _this3;

                _classCallCheck(this, Spring);

                _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Spring).call(this));

                _this3.duration(duration || 500).overshoot(overshoot || 0);

                return _this3;
            }

            _createClass(Spring, [{
                key: "step",
                value: function step(current, target, dt, c) {
                    if (typeof current === 'string') return current;
                    c.done = dt === Infinity;
                    if (dt === Infinity) return target;
                    if (dt === 0) return current;
                    if (dt > 100) dt = 16;
                    dt /= 1000; // Get the previous velocity

                    var velocity = c.velocity || 0; // Apply the control to get the new position and store it

                    var acceleration = -this.d * velocity - this.k * (current - target);
                    var newPosition = current + velocity * dt + acceleration * dt * dt / 2; // Store the velocity

                    c.velocity = velocity + acceleration * dt; // Figure out if we have converged, and if so, pass the value

                    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;
                    return c.done ? target : newPosition;
                }
            }]);

            return Spring;
        }(Controller);
    extend(Spring, {
        duration: makeSetterGetter('_duration', recalculate),
        overshoot: makeSetterGetter('_overshoot', recalculate)
    });
    var PID =
        /*#__PURE__*/
        function (_Controller2) {
            _inherits(PID, _Controller2);

            function PID(p, i, d, windup) {
                var _this4;

                _classCallCheck(this, PID);

                _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PID).call(this));
                p = p == null ? 0.1 : p;
                i = i == null ? 0.01 : i;
                d = d == null ? 0 : d;
                windup = windup == null ? 1000 : windup;

                _this4.p(p).i(i).d(d).windup(windup);

                return _this4;
            }

            _createClass(PID, [{
                key: "step",
                value: function step(current, target, dt, c) {
                    if (typeof current === 'string') return current;
                    c.done = dt === Infinity;
                    if (dt === Infinity) return target;
                    if (dt === 0) return current;
                    var p = target - current;
                    var i = (c.integral || 0) + p * dt;
                    var d = (p - (c.error || 0)) / dt;
                    var windup = this.windup; // antiwindup

                    if (windup !== false) {
                        i = Math.max(-windup, Math.min(i, windup));
                    }

                    c.error = p;
                    c.integral = i;
                    c.done = Math.abs(p) < 0.001;
                    return c.done ? target : current + (this.P * p + this.I * i + this.D * d);
                }
            }]);

            return PID;
        }(Controller);
    extend(PID, {
        windup: makeSetterGetter('windup'),
        p: makeSetterGetter('P'),
        i: makeSetterGetter('I'),
        d: makeSetterGetter('D')
    });

    var PathArray = subClassArray('PathArray', SVGArray);
    function pathRegReplace(a, b, c, d) {
        return c + d.replace(dots, ' .');
    }

    function arrayToString(a) {
        for (var i = 0, il = a.length, s = ''; i < il; i++) {
            s += a[i][0];

            if (a[i][1] != null) {
                s += a[i][1];

                if (a[i][2] != null) {
                    s += ' ';
                    s += a[i][2];

                    if (a[i][3] != null) {
                        s += ' ';
                        s += a[i][3];
                        s += ' ';
                        s += a[i][4];

                        if (a[i][5] != null) {
                            s += ' ';
                            s += a[i][5];
                            s += ' ';
                            s += a[i][6];

                            if (a[i][7] != null) {
                                s += ' ';
                                s += a[i][7];
                            }
                        }
                    }
                }
            }
        }

        return s + ' ';
    }

    var pathHandlers = {
        M: function M(c, p, p0) {
            p.x = p0.x = c[0];
            p.y = p0.y = c[1];
            return ['M', p.x, p.y];
        },
        L: function L(c, p) {
            p.x = c[0];
            p.y = c[1];
            return ['L', c[0], c[1]];
        },
        H: function H(c, p) {
            p.x = c[0];
            return ['H', c[0]];
        },
        V: function V(c, p) {
            p.y = c[0];
            return ['V', c[0]];
        },
        C: function C(c, p) {
            p.x = c[4];
            p.y = c[5];
            return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];
        },
        S: function S(c, p) {
            p.x = c[2];
            p.y = c[3];
            return ['S', c[0], c[1], c[2], c[3]];
        },
        Q: function Q(c, p) {
            p.x = c[2];
            p.y = c[3];
            return ['Q', c[0], c[1], c[2], c[3]];
        },
        T: function T(c, p) {
            p.x = c[0];
            p.y = c[1];
            return ['T', c[0], c[1]];
        },
        Z: function Z(c, p, p0) {
            p.x = p0.x;
            p.y = p0.y;
            return ['Z'];
        },
        A: function A(c, p) {
            p.x = c[5];
            p.y = c[6];
            return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];
        }
    };
    var mlhvqtcsaz = 'mlhvqtcsaz'.split('');

    for (var i = 0, il = mlhvqtcsaz.length; i < il; ++i) {
        pathHandlers[mlhvqtcsaz[i]] = function (i) {
            return function (c, p, p0) {
                if (i === 'H') c[0] = c[0] + p.x; else if (i === 'V') c[0] = c[0] + p.y; else if (i === 'A') {
                    c[5] = c[5] + p.x;
                    c[6] = c[6] + p.y;
                } else {
                    for (var j = 0, jl = c.length; j < jl; ++j) {
                        c[j] = c[j] + (j % 2 ? p.y : p.x);
                    }
                }
                return pathHandlers[i](c, p, p0);
            };
        }(mlhvqtcsaz[i].toUpperCase());
    }

    extend(PathArray, {
        // Convert array to string
        toString: function toString() {
            return arrayToString(this);
        },
        // Move path string
        move: function move(x, y) {
            // get bounding box of current situation
            var box = this.bbox(); // get relative offset

            x -= box.x;
            y -= box.y;

            if (!isNaN(x) && !isNaN(y)) {
                // move every point
                for (var l, i = this.length - 1; i >= 0; i--) {
                    l = this[i][0];

                    if (l === 'M' || l === 'L' || l === 'T') {
                        this[i][1] += x;
                        this[i][2] += y;
                    } else if (l === 'H') {
                        this[i][1] += x;
                    } else if (l === 'V') {
                        this[i][1] += y;
                    } else if (l === 'C' || l === 'S' || l === 'Q') {
                        this[i][1] += x;
                        this[i][2] += y;
                        this[i][3] += x;
                        this[i][4] += y;

                        if (l === 'C') {
                            this[i][5] += x;
                            this[i][6] += y;
                        }
                    } else if (l === 'A') {
                        this[i][6] += x;
                        this[i][7] += y;
                    }
                }
            }

            return this;
        },
        // Resize path string
        size: function size(width, height) {
            // get bounding box of current situation
            var box = this.bbox();
            var i, l; // If the box width or height is 0 then we ignore
            // transformations on the respective axis

            box.width = box.width === 0 ? 1 : box.width;
            box.height = box.height === 0 ? 1 : box.height; // recalculate position of all points according to new size

            for (i = this.length - 1; i >= 0; i--) {
                l = this[i][0];

                if (l === 'M' || l === 'L' || l === 'T') {
                    this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
                    this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
                } else if (l === 'H') {
                    this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
                } else if (l === 'V') {
                    this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
                } else if (l === 'C' || l === 'S' || l === 'Q') {
                    this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
                    this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
                    this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;
                    this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;

                    if (l === 'C') {
                        this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;
                        this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;
                    }
                } else if (l === 'A') {
                    // resize radii
                    this[i][1] = this[i][1] * width / box.width;
                    this[i][2] = this[i][2] * height / box.height; // move position values

                    this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;
                    this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;
                }
            }

            return this;
        },
        // Test if the passed path array use the same path data commands as this path array
        equalCommands: function equalCommands(pathArray) {
            var i, il, equalCommands;
            pathArray = new PathArray(pathArray);
            equalCommands = this.length === pathArray.length;

            for (i = 0, il = this.length; equalCommands && i < il; i++) {
                equalCommands = this[i][0] === pathArray[i][0];
            }

            return equalCommands;
        },
        // Make path array morphable
        morph: function morph(pathArray) {
            pathArray = new PathArray(pathArray);

            if (this.equalCommands(pathArray)) {
                this.destination = pathArray;
            } else {
                this.destination = null;
            }

            return this;
        },
        // Get morphed path array at given position
        at: function at(pos) {
            // make sure a destination is defined
            if (!this.destination) return this;
            var sourceArray = this;
            var destinationArray = this.destination.value;
            var array = [];
            var pathArray = new PathArray();
            var i, il, j, jl; // Animate has specified in the SVG spec
            // See: https://www.w3.org/TR/SVG11/paths.html#PathElement

            for (i = 0, il = sourceArray.length; i < il; i++) {
                array[i] = [sourceArray[i][0]];

                for (j = 1, jl = sourceArray[i].length; j < jl; j++) {
                    array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;
                } // For the two flags of the elliptical arc command, the SVG spec say:
                // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true
                // Elliptical arc command as an array followed by corresponding indexes:
                // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
                //   0    1   2        3                 4             5      6  7


                if (array[i][0] === 'A') {
                    array[i][4] = +(array[i][4] !== 0);
                    array[i][5] = +(array[i][5] !== 0);
                }
            } // Directly modify the value of a path array, this is done this way for performance


            pathArray.value = array;
            return pathArray;
        },
        // Absolutize and parse path to array
        parse: function parse() {
            var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [['M', 0, 0]];
            // if it's already a patharray, no need to parse it
            if (array instanceof PathArray) return array; // prepare for parsing

            var s;
            var paramCnt = {
                M: 2,
                L: 2,
                H: 1,
                V: 1,
                C: 6,
                S: 4,
                Q: 4,
                T: 2,
                A: 7,
                Z: 0
            };

            if (typeof array === 'string') {
                array = array.replace(numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123
                    .replace(pathLetters, ' $& ') // put some room between letters and numbers
                    .replace(hyphen, '$1 -') // add space before hyphen
                    .trim() // trim
                    .split(delimiter); // split into array
            } else {
                array = array.reduce(function (prev, curr) {
                    return [].concat.call(prev, curr);
                }, []);
            } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]


            var result = [];
            var p = new Point();
            var p0 = new Point();
            var index = 0;
            var len = array.length;

            do {
                // Test if we have a path letter
                if (isPathLetter.test(array[index])) {
                    s = array[index];
                    ++index; // If last letter was a move command and we got no new, it defaults to [L]ine
                } else if (s === 'M') {
                    s = 'L';
                } else if (s === 'm') {
                    s = 'l';
                }

                result.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));
            } while (len > index);

            return result;
        },
        // Get bounding box of path
        bbox: function bbox() {
            parser().path.setAttribute('d', this.toString());
            return parser.nodes.path.getBBox();
        }
    });

    var Morphable =
        /*#__PURE__*/
        function () {
            function Morphable(stepper) {
                _classCallCheck(this, Morphable);

                this._stepper = stepper || new Ease('-');
                this._from = null;
                this._to = null;
                this._type = null;
                this._context = null;
                this._morphObj = null;
            }

            _createClass(Morphable, [{
                key: "from",
                value: function from(val) {
                    if (val == null) {
                        return this._from;
                    }

                    this._from = this._set(val);
                    return this;
                }
            }, {
                key: "to",
                value: function to(val) {
                    if (val == null) {
                        return this._to;
                    }

                    this._to = this._set(val);
                    return this;
                }
            }, {
                key: "type",
                value: function type(_type) {
                    // getter
                    if (_type == null) {
                        return this._type;
                    } // setter


                    this._type = _type;
                    return this;
                }
            }, {
                key: "_set",
                value: function _set(value) {
                    if (!this._type) {
                        var type = _typeof(value);

                        if (type === 'number') {
                            this.type(SVGNumber);
                        } else if (type === 'string') {
                            if (Color.isColor(value)) {
                                this.type(Color);
                            } else if (delimiter.test(value)) {
                                this.type(pathLetters.test(value) ? PathArray : SVGArray);
                            } else if (numberAndUnit.test(value)) {
                                this.type(SVGNumber);
                            } else {
                                this.type(NonMorphable);
                            }
                        } else if (morphableTypes.indexOf(value.constructor) > -1) {
                            this.type(value.constructor);
                        } else if (Array.isArray(value)) {
                            this.type(SVGArray);
                        } else if (type === 'object') {
                            this.type(ObjectBag);
                        } else {
                            this.type(NonMorphable);
                        }
                    }

                    var result = new this._type(value);

                    if (this._type === Color) {
                        result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;
                    }

                    result = result.toArray();
                    this._morphObj = this._morphObj || new this._type();
                    this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {
                        o.done = true;
                        return o;
                    });
                    return result;
                }
            }, {
                key: "stepper",
                value: function stepper(_stepper) {
                    if (_stepper == null) return this._stepper;
                    this._stepper = _stepper;
                    return this;
                }
            }, {
                key: "done",
                value: function done() {
                    var complete = this._context.map(this._stepper.done).reduce(function (last, curr) {
                        return last && curr;
                    }, true);

                    return complete;
                }
            }, {
                key: "at",
                value: function at(pos) {
                    var _this = this;

                    return this._morphObj.fromArray(this._from.map(function (i, index) {
                        return _this._stepper.step(i, _this._to[index], pos, _this._context[index], _this._context);
                    }));
                }
            }]);

            return Morphable;
        }();
    var NonMorphable =
        /*#__PURE__*/
        function () {
            function NonMorphable() {
                _classCallCheck(this, NonMorphable);

                this.init.apply(this, arguments);
            }

            _createClass(NonMorphable, [{
                key: "init",
                value: function init(val) {
                    val = Array.isArray(val) ? val[0] : val;
                    this.value = val;
                    return this;
                }
            }, {
                key: "valueOf",
                value: function valueOf() {
                    return this.value;
                }
            }, {
                key: "toArray",
                value: function toArray() {
                    return [this.value];
                }
            }]);

            return NonMorphable;
        }();
    var TransformBag =
        /*#__PURE__*/
        function () {
            function TransformBag() {
                _classCallCheck(this, TransformBag);

                this.init.apply(this, arguments);
            }

            _createClass(TransformBag, [{
                key: "init",
                value: function init(obj) {
                    if (Array.isArray(obj)) {
                        obj = {
                            scaleX: obj[0],
                            scaleY: obj[1],
                            shear: obj[2],
                            rotate: obj[3],
                            translateX: obj[4],
                            translateY: obj[5],
                            originX: obj[6],
                            originY: obj[7]
                        };
                    }

                    Object.assign(this, TransformBag.defaults, obj);
                    return this;
                }
            }, {
                key: "toArray",
                value: function toArray() {
                    var v = this;
                    return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];
                }
            }]);

            return TransformBag;
        }();
    TransformBag.defaults = {
        scaleX: 1,
        scaleY: 1,
        shear: 0,
        rotate: 0,
        translateX: 0,
        translateY: 0,
        originX: 0,
        originY: 0
    };
    var ObjectBag =
        /*#__PURE__*/
        function () {
            function ObjectBag() {
                _classCallCheck(this, ObjectBag);

                this.init.apply(this, arguments);
            }

            _createClass(ObjectBag, [{
                key: "init",
                value: function init(objOrArr) {
                    this.values = [];

                    if (Array.isArray(objOrArr)) {
                        this.values = objOrArr;
                        return;
                    }

                    objOrArr = objOrArr || {};
                    var entries = [];

                    for (var i in objOrArr) {
                        entries.push([i, objOrArr[i]]);
                    }

                    entries.sort(function (a, b) {
                        return a[0] - b[0];
                    });
                    this.values = entries.reduce(function (last, curr) {
                        return last.concat(curr);
                    }, []);
                    return this;
                }
            }, {
                key: "valueOf",
                value: function valueOf() {
                    var obj = {};
                    var arr = this.values;

                    for (var i = 0, len = arr.length; i < len; i += 2) {
                        obj[arr[i]] = arr[i + 1];
                    }

                    return obj;
                }
            }, {
                key: "toArray",
                value: function toArray() {
                    return this.values;
                }
            }]);

            return ObjectBag;
        }();
    var morphableTypes = [NonMorphable, TransformBag, ObjectBag];
    function registerMorphableType() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        morphableTypes.push.apply(morphableTypes, _toConsumableArray([].concat(type)));
    }
    function makeMorphable() {
        extend(morphableTypes, {
            to: function to(val) {
                return new Morphable().type(this.constructor).from(this.valueOf()).to(val);
            },
            fromArray: function fromArray(arr) {
                this.init(arr);
                return this;
            }
        });
    }

    var Path =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Path, _Shape);

            // Initialize node
            function Path(node) {
                _classCallCheck(this, Path);

                return _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, nodeOrNew('path', node), node));
            } // Get array


            _createClass(Path, [{
                key: "array",
                value: function array() {
                    return this._array || (this._array = new PathArray(this.attr('d')));
                } // Plot new path

            }, {
                key: "plot",
                value: function plot(d) {
                    return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));
                } // Clear array cache

            }, {
                key: "clear",
                value: function clear() {
                    delete this._array;
                    return this;
                } // Move by left top corner

            }, {
                key: "move",
                value: function move(x, y) {
                    return this.attr('d', this.array().move(x, y));
                } // Move by left top corner over x-axis

            }, {
                key: "x",
                value: function x(_x) {
                    return _x == null ? this.bbox().x : this.move(_x, this.bbox().y);
                } // Move by left top corner over y-axis

            }, {
                key: "y",
                value: function y(_y) {
                    return _y == null ? this.bbox().y : this.move(this.bbox().x, _y);
                } // Set element size to given width and height

            }, {
                key: "size",
                value: function size(width, height) {
                    var p = proportionalSize(this, width, height);
                    return this.attr('d', this.array().size(p.width, p.height));
                } // Set width of element

            }, {
                key: "width",
                value: function width(_width) {
                    return _width == null ? this.bbox().width : this.size(_width, this.bbox().height);
                } // Set height of element

            }, {
                key: "height",
                value: function height(_height) {
                    return _height == null ? this.bbox().height : this.size(this.bbox().width, _height);
                }
            }, {
                key: "targets",
                value: function targets() {
                    return baseFind('svg textpath [href*="' + this.id() + '"]');
                }
            }]);

            return Path;
        }(Shape); // Define morphable array
    Path.prototype.MorphArray = PathArray; // Add parent method

    registerMethods({
        Container: {
            // Create a wrapped path element
            path: wrapWithAttrCheck(function (d) {
                // make sure plot is called as a setter
                return this.put(new Path()).plot(d || new PathArray());
            })
        }
    });
    register(Path, 'Path');

    function array() {
        return this._array || (this._array = new PointArray(this.attr('points')));
    } // Plot new path

    function plot(p) {
        return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));
    } // Clear array cache

    function clear() {
        delete this._array;
        return this;
    } // Move by left top corner

    function move(x, y) {
        return this.attr('points', this.array().move(x, y));
    } // Set element size to given width and height

    function size(width, height) {
        var p = proportionalSize(this, width, height);
        return this.attr('points', this.array().size(p.width, p.height));
    }

    var poly = ({
        __proto__: null,
        array: array,
        plot: plot,
        clear: clear,
        move: move,
        size: size
    });

    var Polygon =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Polygon, _Shape);

            // Initialize node
            function Polygon(node) {
                _classCallCheck(this, Polygon);

                return _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this, nodeOrNew('polygon', node), node));
            }

            return Polygon;
        }(Shape);
    registerMethods({
        Container: {
            // Create a wrapped polygon element
            polygon: wrapWithAttrCheck(function (p) {
                // make sure plot is called as a setter
                return this.put(new Polygon()).plot(p || new PointArray());
            })
        }
    });
    extend(Polygon, pointed);
    extend(Polygon, poly);
    register(Polygon, 'Polygon');

    var Polyline =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Polyline, _Shape);

            // Initialize node
            function Polyline(node) {
                _classCallCheck(this, Polyline);

                return _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this, nodeOrNew('polyline', node), node));
            }

            return Polyline;
        }(Shape);
    registerMethods({
        Container: {
            // Create a wrapped polygon element
            polyline: wrapWithAttrCheck(function (p) {
                // make sure plot is called as a setter
                return this.put(new Polyline()).plot(p || new PointArray());
            })
        }
    });
    extend(Polyline, pointed);
    extend(Polyline, poly);
    register(Polyline, 'Polyline');

    var Rect =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Rect, _Shape);

            // Initialize node
            function Rect(node) {
                _classCallCheck(this, Rect);

                return _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, nodeOrNew('rect', node), node));
            }

            return Rect;
        }(Shape);
    extend(Rect, {
        rx: rx,
        ry: ry
    });
    registerMethods({
        Container: {
            // Create a rect element
            rect: wrapWithAttrCheck(function (width, height) {
                return this.put(new Rect()).size(width, height);
            })
        }
    });
    register(Rect, 'Rect');

    var max$3 = Math.max;
    var min$4 = Math.min;
    var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
    var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

    // `Array.prototype.splice` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.splice
    // with adding support of @@species
    _export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('splice') }, {
        splice: function splice(start, deleteCount /* , ...items */) {
            var O = toObject(this);
            var len = toLength(O.length);
            var actualStart = toAbsoluteIndex(start, len);
            var argumentsLength = arguments.length;
            var insertCount, actualDeleteCount, A, k, from, to;
            if (argumentsLength === 0) {
                insertCount = actualDeleteCount = 0;
            } else if (argumentsLength === 1) {
                insertCount = 0;
                actualDeleteCount = len - actualStart;
            } else {
                insertCount = argumentsLength - 2;
                actualDeleteCount = min$4(max$3(toInteger(deleteCount), 0), len - actualStart);
            }
            if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
                throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
            }
            A = arraySpeciesCreate(O, actualDeleteCount);
            for (k = 0; k < actualDeleteCount; k++) {
                from = actualStart + k;
                if (from in O) createProperty(A, k, O[from]);
            }
            A.length = actualDeleteCount;
            if (insertCount < actualDeleteCount) {
                for (k = actualStart; k < len - actualDeleteCount; k++) {
                    from = k + actualDeleteCount;
                    to = k + insertCount;
                    if (from in O) O[to] = O[from];
                    else delete O[to];
                }
                for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
            } else if (insertCount > actualDeleteCount) {
                for (k = len - actualDeleteCount; k > actualStart; k--) {
                    from = k + actualDeleteCount - 1;
                    to = k + insertCount - 1;
                    if (from in O) O[to] = O[from];
                    else delete O[to];
                }
            }
            for (k = 0; k < insertCount; k++) {
                O[k + actualStart] = arguments[k + 2];
            }
            O.length = len - actualDeleteCount + insertCount;
            return A;
        }
    });

    var Queue =
        /*#__PURE__*/
        function () {
            function Queue() {
                _classCallCheck(this, Queue);

                this._first = null;
                this._last = null;
            }

            _createClass(Queue, [{
                key: "push",
                value: function push(value) {
                    // An item stores an id and the provided value
                    var item = value.next ? value : {
                        value: value,
                        next: null,
                        prev: null
                    }; // Deal with the queue being empty or populated

                    if (this._last) {
                        item.prev = this._last;
                        this._last.next = item;
                        this._last = item;
                    } else {
                        this._last = item;
                        this._first = item;
                    } // Return the current item


                    return item;
                }
            }, {
                key: "shift",
                value: function shift() {
                    // Check if we have a value
                    var remove = this._first;
                    if (!remove) return null; // If we do, remove it and relink things

                    this._first = remove.next;
                    if (this._first) this._first.prev = null;
                    this._last = this._first ? this._last : null;
                    return remove.value;
                } // Shows us the first item in the list

            }, {
                key: "first",
                value: function first() {
                    return this._first && this._first.value;
                } // Shows us the last item in the list

            }, {
                key: "last",
                value: function last() {
                    return this._last && this._last.value;
                } // Removes the item that was returned from the push

            }, {
                key: "remove",
                value: function remove(item) {
                    // Relink the previous item
                    if (item.prev) item.prev.next = item.next;
                    if (item.next) item.next.prev = item.prev;
                    if (item === this._last) this._last = item.prev;
                    if (item === this._first) this._first = item.next; // Invalidate item

                    item.prev = null;
                    item.next = null;
                }
            }]);

            return Queue;
        }();

    var Animator = {
        nextDraw: null,
        frames: new Queue(),
        timeouts: new Queue(),
        immediates: new Queue(),
        timer: function timer() {
            return globals.window.performance || globals.window.Date;
        },
        transforms: [],
        frame: function frame(fn) {
            // Store the node
            var node = Animator.frames.push({
                run: fn
            }); // Request an animation frame if we don't have one

            if (Animator.nextDraw === null) {
                Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
            } // Return the node so we can remove it easily


            return node;
        },
        timeout: function timeout(fn, delay) {
            delay = delay || 0; // Work out when the event should fire

            var time = Animator.timer().now() + delay; // Add the timeout to the end of the queue

            var node = Animator.timeouts.push({
                run: fn,
                time: time
            }); // Request another animation frame if we need one

            if (Animator.nextDraw === null) {
                Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
            }

            return node;
        },
        immediate: function immediate(fn) {
            // Add the immediate fn to the end of the queue
            var node = Animator.immediates.push(fn); // Request another animation frame if we need one

            if (Animator.nextDraw === null) {
                Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
            }

            return node;
        },
        cancelFrame: function cancelFrame(node) {
            node != null && Animator.frames.remove(node);
        },
        clearTimeout: function clearTimeout(node) {
            node != null && Animator.timeouts.remove(node);
        },
        cancelImmediate: function cancelImmediate(node) {
            node != null && Animator.immediates.remove(node);
        },
        _draw: function _draw(now) {
            // Run all the timeouts we can run, if they are not ready yet, add them
            // to the end of the queue immediately! (bad timeouts!!! [sarcasm])
            var nextTimeout = null;
            var lastTimeout = Animator.timeouts.last();

            while (nextTimeout = Animator.timeouts.shift()) {
                // Run the timeout if its time, or push it to the end
                if (now >= nextTimeout.time) {
                    nextTimeout.run();
                } else {
                    Animator.timeouts.push(nextTimeout);
                } // If we hit the last item, we should stop shifting out more items


                if (nextTimeout === lastTimeout) break;
            } // Run all of the animation frames


            var nextFrame = null;
            var lastFrame = Animator.frames.last();

            while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {
                nextFrame.run(now);
            }

            var nextImmediate = null;

            while (nextImmediate = Animator.immediates.shift()) {
                nextImmediate();
            } // If we have remaining timeouts or frames, draw until we don't anymore


            Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;
        }
    };

    var makeSchedule = function makeSchedule(runnerInfo) {
        var start = runnerInfo.start;
        var duration = runnerInfo.runner.duration();
        var end = start + duration;
        return {
            start: start,
            duration: duration,
            end: end,
            runner: runnerInfo.runner
        };
    };

    var defaultSource = function defaultSource() {
        var w = globals.window;
        return (w.performance || w.Date).now();
    };

    var Timeline =
        /*#__PURE__*/
        function (_EventTarget) {
            _inherits(Timeline, _EventTarget);

            // Construct a new timeline on the given element
            function Timeline() {
                var _this;

                var timeSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSource;

                _classCallCheck(this, Timeline);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Timeline).call(this));
                _this._timeSource = timeSource; // Store the timing variables

                _this._startTime = 0;
                _this._speed = 1.0; // Determines how long a runner is hold in memory. Can be a dt or true/false

                _this._persist = 0; // Keep track of the running animations and their starting parameters

                _this._nextFrame = null;
                _this._paused = true;
                _this._runners = [];
                _this._runnerIds = [];
                _this._lastRunnerId = -1;
                _this._time = 0;
                _this._lastSourceTime = 0;
                _this._lastStepTime = 0; // Make sure that step is always called in class context

                _this._step = _this._stepFn.bind(_assertThisInitialized(_this), false);
                _this._stepImmediate = _this._stepFn.bind(_assertThisInitialized(_this), true);
                return _this;
            } // schedules a runner on the timeline


            _createClass(Timeline, [{
                key: "schedule",
                value: function schedule(runner, delay, when) {
                    if (runner == null) {
                        return this._runners.map(makeSchedule);
                    } // The start time for the next animation can either be given explicitly,
                    // derived from the current timeline time or it can be relative to the
                    // last start time to chain animations direclty


                    var absoluteStartTime = 0;
                    var endTime = this.getEndTime();
                    delay = delay || 0; // Work out when to start the animation

                    if (when == null || when === 'last' || when === 'after') {
                        // Take the last time and increment
                        absoluteStartTime = endTime;
                    } else if (when === 'absolute' || when === 'start') {
                        absoluteStartTime = delay;
                        delay = 0;
                    } else if (when === 'now') {
                        absoluteStartTime = this._time;
                    } else if (when === 'relative') {
                        var _runnerInfo = this._runners[runner.id];

                        if (_runnerInfo) {
                            absoluteStartTime = _runnerInfo.start + delay;
                            delay = 0;
                        }
                    } else {
                        throw new Error('Invalid value for the "when" parameter');
                    } // Manage runner


                    runner.unschedule();
                    runner.timeline(this);
                    var persist = runner.persist();
                    var runnerInfo = {
                        persist: persist === null ? this._persist : persist,
                        start: absoluteStartTime + delay,
                        runner: runner
                    };
                    this._lastRunnerId = runner.id;

                    this._runners.push(runnerInfo);

                    this._runners.sort(function (a, b) {
                        return a.start - b.start;
                    });

                    this._runnerIds = this._runners.map(function (info) {
                        return info.runner.id;
                    });

                    this.updateTime()._continue();

                    return this;
                } // Remove the runner from this timeline

            }, {
                key: "unschedule",
                value: function unschedule(runner) {
                    var index = this._runnerIds.indexOf(runner.id);

                    if (index < 0) return this;

                    this._runners.splice(index, 1);

                    this._runnerIds.splice(index, 1);

                    runner.timeline(null);
                    return this;
                } // Calculates the end of the timeline

            }, {
                key: "getEndTime",
                value: function getEndTime() {
                    var lastRunnerInfo = this._runners[this._runnerIds.indexOf(this._lastRunnerId)];

                    var lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
                    var lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : 0;
                    return lastStartTime + lastDuration;
                }
            }, {
                key: "getEndTimeOfTimeline",
                value: function getEndTimeOfTimeline() {
                    var lastEndTime = 0;

                    for (var i = 0; i < this._runners.length; i++) {
                        var runnerInfo = this._runners[i];
                        var duration = runnerInfo ? runnerInfo.runner.duration() : 0;
                        var startTime = runnerInfo ? runnerInfo.start : 0;
                        var endTime = startTime + duration;

                        if (endTime > lastEndTime) {
                            lastEndTime = endTime;
                        }
                    }

                    return lastEndTime;
                } // Makes sure, that after pausing the time doesn't jump

            }, {
                key: "updateTime",
                value: function updateTime() {
                    if (!this.active()) {
                        this._lastSourceTime = this._timeSource();
                    }

                    return this;
                }
            }, {
                key: "play",
                value: function play() {
                    // Now make sure we are not paused and continue the animation
                    this._paused = false;
                    return this.updateTime()._continue();
                }
            }, {
                key: "pause",
                value: function pause() {
                    this._paused = true;
                    return this._continue();
                }
            }, {
                key: "stop",
                value: function stop() {
                    // Go to start and pause
                    this.time(0);
                    return this.pause();
                }
            }, {
                key: "finish",
                value: function finish() {
                    // Go to end and pause
                    this.time(this.getEndTimeOfTimeline() + 1);
                    return this.pause();
                }
            }, {
                key: "speed",
                value: function speed(_speed) {
                    if (_speed == null) return this._speed;
                    this._speed = _speed;
                    return this;
                }
            }, {
                key: "reverse",
                value: function reverse(yes) {
                    var currentSpeed = this.speed();
                    if (yes == null) return this.speed(-currentSpeed);
                    var positive = Math.abs(currentSpeed);
                    return this.speed(yes ? positive : -positive);
                }
            }, {
                key: "seek",
                value: function seek(dt) {
                    return this.time(this._time + dt);
                }
            }, {
                key: "time",
                value: function time(_time) {
                    if (_time == null) return this._time;
                    this._time = _time;
                    return this._continue(true);
                }
            }, {
                key: "persist",
                value: function persist(dtOrForever) {
                    if (dtOrForever == null) return this._persist;
                    this._persist = dtOrForever;
                    return this;
                }
            }, {
                key: "source",
                value: function source(fn) {
                    if (fn == null) return this._timeSource;
                    this._timeSource = fn;
                    return this;
                }
            }, {
                key: "_stepFn",
                value: function _stepFn() {
                    var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                    // Get the time delta from the last time and update the time
                    var time = this._timeSource();

                    var dtSource = time - this._lastSourceTime;
                    if (immediateStep) dtSource = 0;
                    var dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
                    this._lastSourceTime = time; // Only update the time if we use the timeSource.
                    // Otherwise use the current time

                    if (!immediateStep) {
                        // Update the time
                        this._time += dtTime;
                        this._time = this._time < 0 ? 0 : this._time;
                    }

                    this._lastStepTime = this._time;
                    this.fire('time', this._time); // This is for the case that the timeline was seeked so that the time
                    // is now before the startTime of the runner. Thats why we need to set
                    // the runner to position 0
                    // FIXME:
                    // However, reseting in insertion order leads to bugs. Considering the case,
                    // where 2 runners change the same attriute but in different times,
                    // reseting both of them will lead to the case where the later defined
                    // runner always wins the reset even if the other runner started earlier
                    // and therefore should win the attribute battle
                    // this can be solved by reseting them backwards

                    for (var k = this._runners.length; k--;) {
                        // Get and run the current runner and ignore it if its inactive
                        var runnerInfo = this._runners[k];
                        var runner = runnerInfo.runner; // Make sure that we give the actual difference
                        // between runner start time and now

                        var dtToStart = this._time - runnerInfo.start; // Dont run runner if not started yet
                        // and try to reset it

                        if (dtToStart <= 0) {
                            runner.reset();
                        }
                    } // Run all of the runners directly


                    var runnersLeft = false;

                    for (var i = 0, len = this._runners.length; i < len; i++) {
                        // Get and run the current runner and ignore it if its inactive
                        var _runnerInfo2 = this._runners[i];
                        var _runner = _runnerInfo2.runner;
                        var dt = dtTime; // Make sure that we give the actual difference
                        // between runner start time and now

                        var _dtToStart = this._time - _runnerInfo2.start; // Dont run runner if not started yet


                        if (_dtToStart <= 0) {
                            runnersLeft = true;
                            continue;
                        } else if (_dtToStart < dt) {
                            // Adjust dt to make sure that animation is on point
                            dt = _dtToStart;
                        }

                        if (!_runner.active()) continue; // If this runner is still going, signal that we need another animation
                        // frame, otherwise, remove the completed runner

                        var finished = _runner.step(dt).done;

                        if (!finished) {
                            runnersLeft = true; // continue
                        } else if (_runnerInfo2.persist !== true) {
                            // runner is finished. And runner might get removed
                            var endTime = _runner.duration() - _runner.time() + this._time;

                            if (endTime + _runnerInfo2.persist < this._time) {
                                // Delete runner and correct index
                                _runner.unschedule();

                                --i;
                                --len;
                            }
                        }
                    } // Basically: we continue when there are runners right from us in time
                    // when -->, and when runners are left from us when <--


                    if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {
                        this._continue();
                    } else {
                        this.pause();
                        this.fire('finished');
                    }

                    return this;
                } // Checks if we are running and continues the animation

            }, {
                key: "_continue",
                value: function _continue() {
                    var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                    Animator.cancelFrame(this._nextFrame);
                    this._nextFrame = null;
                    if (immediateStep) return this._stepImmediate();
                    if (this._paused) return this;
                    this._nextFrame = Animator.frame(this._step);
                    return this;
                }
            }, {
                key: "active",
                value: function active() {
                    return !!this._nextFrame;
                }
            }]);

            return Timeline;
        }(EventTarget);
    registerMethods({
        Element: {
            timeline: function timeline(_timeline) {
                if (_timeline == null) {
                    this._timeline = this._timeline || new Timeline();
                    return this._timeline;
                } else {
                    this._timeline = _timeline;
                    return this;
                }
            }
        }
    });

    function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    var Runner =
        /*#__PURE__*/
        function (_EventTarget) {
            _inherits(Runner, _EventTarget);

            function Runner(options) {
                var _this;

                _classCallCheck(this, Runner);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Runner).call(this)); // Store a unique id on the runner, so that we can identify it later

                _this.id = Runner.id++; // Ensure a default value

                options = options == null ? timeline.duration : options; // Ensure that we get a controller

                options = typeof options === 'function' ? new Controller(options) : options; // Declare all of the variables
                _this._element = null;
                _this._timeline = null;
                _this.done = false;
                _this._queue = []; // Work out the stepper and the duration

                _this._duration = typeof options === 'number' && options;
                _this._isDeclarative = options instanceof Controller;
                _this._stepper = _this._isDeclarative ? options : new Ease(); // We copy the current values from the timeline because they can change

                _this._history = {}; // Store the state of the runner

                _this.enabled = true;
                _this._time = 0;
                _this._lastTime = 0; // At creation, the runner is in reseted state

                _this._reseted = true; // Save transforms applied to this runner

                _this.transforms = new Matrix();
                _this.transformId = 1; // Looping variables

                _this._haveReversed = false;
                _this._reverse = false;
                _this._loopsDone = 0;
                _this._swing = false;
                _this._wait = 0;
                _this._times = 1;
                _this._frameId = null; // Stores how long a runner is stored after beeing done

                _this._persist = _this._isDeclarative ? true : null;
                return _this;
            }
            /*
            Runner Definitions
            ==================
            These methods help us define the runtime behaviour of the Runner or they
            help us make new runners from the current runner
            */


            _createClass(Runner, [{
                key: "element",
                value: function element(_element) {
                    if (_element == null) return this._element;
                    this._element = _element;

                    _element._prepareRunner();

                    return this;
                }
            }, {
                key: "timeline",
                value: function timeline(_timeline) {
                    // check explicitly for undefined so we can set the timeline to null
                    if (typeof _timeline === 'undefined') return this._timeline;
                    this._timeline = _timeline;
                    return this;
                }
            }, {
                key: "animate",
                value: function animate(duration, delay, when) {
                    var o = Runner.sanitise(duration, delay, when);
                    var runner = new Runner(o.duration);
                    if (this._timeline) runner.timeline(this._timeline);
                    if (this._element) runner.element(this._element);
                    return runner.loop(o).schedule(o.delay, o.when);
                }
            }, {
                key: "schedule",
                value: function schedule(timeline, delay, when) {
                    // The user doesn't need to pass a timeline if we already have one
                    if (!(timeline instanceof Timeline)) {
                        when = delay;
                        delay = timeline;
                        timeline = this.timeline();
                    } // If there is no timeline, yell at the user...


                    if (!timeline) {
                        throw Error('Runner cannot be scheduled without timeline');
                    } // Schedule the runner on the timeline provided


                    timeline.schedule(this, delay, when);
                    return this;
                }
            }, {
                key: "unschedule",
                value: function unschedule() {
                    var timeline = this.timeline();
                    timeline && timeline.unschedule(this);
                    return this;
                }
            }, {
                key: "loop",
                value: function loop(times, swing, wait) {
                    // Deal with the user passing in an object
                    if (_typeof(times) === 'object') {
                        swing = times.swing;
                        wait = times.wait;
                        times = times.times;
                    } // Sanitise the values and store them


                    this._times = times || Infinity;
                    this._swing = swing || false;
                    this._wait = wait || 0; // Allow true to be passed

                    if (this._times === true) {
                        this._times = Infinity;
                    }

                    return this;
                }
            }, {
                key: "delay",
                value: function delay(_delay) {
                    return this.animate(0, _delay);
                }
                /*
                Basic Functionality
                ===================
                These methods allow us to attach basic functions to the runner directly
                */

            }, {
                key: "queue",
                value: function queue(initFn, runFn, retargetFn, isTransform) {
                    this._queue.push({
                        initialiser: initFn || noop,
                        runner: runFn || noop,
                        retarget: retargetFn,
                        isTransform: isTransform,
                        initialised: false,
                        finished: false
                    });

                    var timeline = this.timeline();
                    timeline && this.timeline()._continue();
                    return this;
                }
            }, {
                key: "during",
                value: function during(fn) {
                    return this.queue(null, fn);
                }
            }, {
                key: "after",
                value: function after(fn) {
                    return this.on('finished', fn);
                }
                /*
                Runner animation methods
                ========================
                Control how the animation plays
                */

            }, {
                key: "time",
                value: function time(_time) {
                    if (_time == null) {
                        return this._time;
                    }

                    var dt = _time - this._time;
                    this.step(dt);
                    return this;
                }
            }, {
                key: "duration",
                value: function duration() {
                    return this._times * (this._wait + this._duration) - this._wait;
                }
            }, {
                key: "loops",
                value: function loops(p) {
                    var loopDuration = this._duration + this._wait;

                    if (p == null) {
                        var loopsDone = Math.floor(this._time / loopDuration);
                        var relativeTime = this._time - loopsDone * loopDuration;
                        var position = relativeTime / this._duration;
                        return Math.min(loopsDone + position, this._times);
                    }

                    var whole = Math.floor(p);
                    var partial = p % 1;
                    var time = loopDuration * whole + this._duration * partial;
                    return this.time(time);
                }
            }, {
                key: "persist",
                value: function persist(dtOrForever) {
                    if (dtOrForever == null) return this._persist;
                    this._persist = dtOrForever;
                    return this;
                }
            }, {
                key: "position",
                value: function position(p) {
                    // Get all of the variables we need
                    var x = this._time;
                    var d = this._duration;
                    var w = this._wait;
                    var t = this._times;
                    var s = this._swing;
                    var r = this._reverse;
                    var position;

                    if (p == null) {
                        /*
                        This function converts a time to a position in the range [0, 1]
                        The full explanation can be found in this desmos demonstration
                          https://www.desmos.com/calculator/u4fbavgche
                        The logic is slightly simplified here because we can use booleans
                        */
                        // Figure out the value without thinking about the start or end time
                        var f = function f(x) {
                            var swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));
                            var backwards = swinging && !r || !swinging && r;
                            var uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;
                            var clipped = Math.max(Math.min(uncliped, 1), 0);
                            return clipped;
                        }; // Figure out the value by incorporating the start time


                        var endTime = t * (w + d) - w;
                        position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));
                        return position;
                    } // Work out the loops done and add the position to the loops done


                    var loopsDone = Math.floor(this.loops());
                    var swingForward = s && loopsDone % 2 === 0;
                    var forwards = swingForward && !r || r && swingForward;
                    position = loopsDone + (forwards ? p : 1 - p);
                    return this.loops(position);
                }
            }, {
                key: "progress",
                value: function progress(p) {
                    if (p == null) {
                        return Math.min(1, this._time / this.duration());
                    }

                    return this.time(p * this.duration());
                }
            }, {
                key: "step",
                value: function step(dt) {
                    // If we are inactive, this stepper just gets skipped
                    if (!this.enabled) return this; // Update the time and get the new position

                    dt = dt == null ? 16 : dt;
                    this._time += dt;
                    var position = this.position(); // Figure out if we need to run the stepper in this frame

                    var running = this._lastPosition !== position && this._time >= 0;
                    this._lastPosition = position; // Figure out if we just started

                    var duration = this.duration();
                    var justStarted = this._lastTime <= 0 && this._time > 0;
                    var justFinished = this._lastTime < duration && this._time >= duration;
                    this._lastTime = this._time;

                    if (justStarted) {
                        this.fire('start', this);
                    } // Work out if the runner is finished set the done flag here so animations
                    // know, that they are running in the last step (this is good for
                    // transformations which can be merged)


                    var declarative = this._isDeclarative;
                    this.done = !declarative && !justFinished && this._time >= duration; // Runner is running. So its not in reseted state anymore

                    this._reseted = false; // Call initialise and the run function

                    if (running || declarative) {
                        this._initialise(running); // clear the transforms on this runner so they dont get added again and again


                        this.transforms = new Matrix();

                        var converged = this._run(declarative ? dt : position);

                        this.fire('step', this);
                    } // correct the done flag here
                    // declaritive animations itself know when they converged


                    this.done = this.done || converged && declarative;

                    if (justFinished) {
                        this.fire('finished', this);
                    }

                    return this;
                }
            }, {
                key: "reset",
                value: function reset() {
                    if (this._reseted) return this;
                    this.time(0);
                    this._reseted = true;
                    return this;
                }
            }, {
                key: "finish",
                value: function finish() {
                    return this.step(Infinity);
                }
            }, {
                key: "reverse",
                value: function reverse(_reverse) {
                    this._reverse = _reverse == null ? !this._reverse : _reverse;
                    return this;
                }
            }, {
                key: "ease",
                value: function ease(fn) {
                    this._stepper = new Ease(fn);
                    return this;
                }
            }, {
                key: "active",
                value: function active(enabled) {
                    if (enabled == null) return this.enabled;
                    this.enabled = enabled;
                    return this;
                }
                /*
                Private Methods
                ===============
                Methods that shouldn't be used externally
                */
                // Save a morpher to the morpher list so that we can retarget it later

            }, {
                key: "_rememberMorpher",
                value: function _rememberMorpher(method, morpher) {
                    this._history[method] = {
                        morpher: morpher,
                        caller: this._queue[this._queue.length - 1]
                    }; // We have to resume the timeline in case a controller
                    // is already done without beeing ever run
                    // This can happen when e.g. this is done:
                    //    anim = el.animate(new SVG.Spring)
                    // and later
                    //    anim.move(...)

                    if (this._isDeclarative) {
                        var timeline = this.timeline();
                        timeline && timeline.play();
                    }
                } // Try to set the target for a morpher if the morpher exists, otherwise
                // do nothing and return false

            }, {
                key: "_tryRetarget",
                value: function _tryRetarget(method, target, extra) {
                    if (this._history[method]) {
                        // if the last method wasnt even initialised, throw it away
                        if (!this._history[method].caller.initialised) {
                            var index = this._queue.indexOf(this._history[method].caller);

                            this._queue.splice(index, 1);

                            return false;
                        } // for the case of transformations, we use the special retarget function
                        // which has access to the outer scope


                        if (this._history[method].caller.retarget) {
                            this._history[method].caller.retarget(target, extra); // for everything else a simple morpher change is sufficient

                        } else {
                            this._history[method].morpher.to(target);
                        }

                        this._history[method].caller.finished = false;
                        var timeline = this.timeline();
                        timeline && timeline.play();
                        return true;
                    }

                    return false;
                } // Run each initialise function in the runner if required

            }, {
                key: "_initialise",
                value: function _initialise(running) {
                    // If we aren't running, we shouldn't initialise when not declarative
                    if (!running && !this._isDeclarative) return; // Loop through all of the initialisers

                    for (var i = 0, len = this._queue.length; i < len; ++i) {
                        // Get the current initialiser
                        var current = this._queue[i]; // Determine whether we need to initialise

                        var needsIt = this._isDeclarative || !current.initialised && running;
                        running = !current.finished; // Call the initialiser if we need to

                        if (needsIt && running) {
                            current.initialiser.call(this);
                            current.initialised = true;
                        }
                    }
                } // Run each run function for the position or dt given

            }, {
                key: "_run",
                value: function _run(positionOrDt) {
                    // Run all of the _queue directly
                    var allfinished = true;

                    for (var i = 0, len = this._queue.length; i < len; ++i) {
                        // Get the current function to run
                        var current = this._queue[i]; // Run the function if its not finished, we keep track of the finished
                        // flag for the sake of declarative _queue

                        var converged = current.runner.call(this, positionOrDt);
                        current.finished = current.finished || converged === true;
                        allfinished = allfinished && current.finished;
                    } // We report when all of the constructors are finished


                    return allfinished;
                }
            }, {
                key: "addTransform",
                value: function addTransform(transform, index) {
                    this.transforms.lmultiplyO(transform);
                    return this;
                }
            }, {
                key: "clearTransform",
                value: function clearTransform() {
                    this.transforms = new Matrix();
                    return this;
                } // TODO: Keep track of all transformations so that deletion is faster

            }, {
                key: "clearTransformsFromQueue",
                value: function clearTransformsFromQueue() {
                    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {
                        this._queue = this._queue.filter(function (item) {
                            return !item.isTransform;
                        });
                    }
                }
            }], [{
                key: "sanitise",
                value: function sanitise(duration, delay, when) {
                    // Initialise the default parameters
                    var times = 1;
                    var swing = false;
                    var wait = 0;
                    duration = duration || timeline.duration;
                    delay = delay || timeline.delay;
                    when = when || 'last'; // If we have an object, unpack the values

                    if (_typeof(duration) === 'object' && !(duration instanceof Stepper)) {
                        delay = duration.delay || delay;
                        when = duration.when || when;
                        swing = duration.swing || swing;
                        times = duration.times || times;
                        wait = duration.wait || wait;
                        duration = duration.duration || timeline.duration;
                    }

                    return {
                        duration: duration,
                        delay: delay,
                        swing: swing,
                        times: times,
                        wait: wait,
                        when: when
                    };
                }
            }]);

            return Runner;
        }(EventTarget);
    Runner.id = 0;

    var FakeRunner =
        /*#__PURE__*/
        function () {
            function FakeRunner() {
                var transforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();
                var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
                var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

                _classCallCheck(this, FakeRunner);

                this.transforms = transforms;
                this.id = id;
                this.done = done;
            }

            _createClass(FakeRunner, [{
                key: "clearTransformsFromQueue",
                value: function clearTransformsFromQueue() { }
            }]);

            return FakeRunner;
        }();

    extend([Runner, FakeRunner], {
        mergeWith: function mergeWith(runner) {
            return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);
        }
    }); // FakeRunner.emptyRunner = new FakeRunner()

    var lmultiply = function lmultiply(last, curr) {
        return last.lmultiplyO(curr);
    };

    var getRunnerTransform = function getRunnerTransform(runner) {
        return runner.transforms;
    };

    function mergeTransforms() {
        // Find the matrix to apply to the element and apply it
        var runners = this._transformationRunners.runners;
        var netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());
        this.transform(netTransform);

        this._transformationRunners.merge();

        if (this._transformationRunners.length() === 1) {
            this._frameId = null;
        }
    }

    var RunnerArray =
        /*#__PURE__*/
        function () {
            function RunnerArray() {
                _classCallCheck(this, RunnerArray);

                this.runners = [];
                this.ids = [];
            }

            _createClass(RunnerArray, [{
                key: "add",
                value: function add(runner) {
                    if (this.runners.includes(runner)) return;
                    var id = runner.id + 1;
                    this.runners.push(runner);
                    this.ids.push(id);
                    return this;
                }
            }, {
                key: "getByID",
                value: function getByID(id) {
                    return this.runners[this.ids.indexOf(id + 1)];
                }
            }, {
                key: "remove",
                value: function remove(id) {
                    var index = this.ids.indexOf(id + 1);
                    this.ids.splice(index, 1);
                    this.runners.splice(index, 1);
                    return this;
                }
            }, {
                key: "merge",
                value: function merge() {
                    var _this2 = this;

                    var lastRunner = null;
                    this.runners.forEach(function (runner, i) {
                        var condition = lastRunner && runner.done && lastRunner.done // don't merge runner when persisted on timeline
                            && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));

                        if (condition) {
                            // the +1 happens in the function
                            _this2.remove(runner.id);

                            _this2.edit(lastRunner.id, runner.mergeWith(lastRunner));
                        }

                        lastRunner = runner;
                    });
                    return this;
                }
            }, {
                key: "edit",
                value: function edit(id, newRunner) {
                    var index = this.ids.indexOf(id + 1);
                    this.ids.splice(index, 1, id + 1);
                    this.runners.splice(index, 1, newRunner);
                    return this;
                }
            }, {
                key: "length",
                value: function length() {
                    return this.ids.length;
                }
            }, {
                key: "clearBefore",
                value: function clearBefore(id) {
                    var deleteCnt = this.ids.indexOf(id + 1) || 1;
                    this.ids.splice(0, deleteCnt, 0);
                    this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(function (r) {
                        return r.clearTransformsFromQueue();
                    });
                    return this;
                }
            }]);

            return RunnerArray;
        }();

    registerMethods({
        Element: {
            animate: function animate(duration, delay, when, ease = undefined) {
                var o = Runner.sanitise(duration, delay, when);
                var timeline = this.timeline();
                if (ease === undefined) {
                    ease = 'easeOutQuint'
                }
                return new Runner(o.duration).ease(ease).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);
            },
            delay: function delay(by, when) {
                return this.animate(0, by, when);
            },
            // this function searches for all runners on the element and deletes the ones
            // which run before the current one. This is because absolute transformations
            // overwfrite anything anyway so there is no need to waste time computing
            // other runners
            _clearTransformRunnersBefore: function _clearTransformRunnersBefore(currentRunner) {
                this._transformationRunners.clearBefore(currentRunner.id);
            },
            _currentTransform: function _currentTransform(current) {
                return this._transformationRunners.runners // we need the equal sign here to make sure, that also transformations
                    // on the same runner which execute before the current transformation are
                    // taken into account
                    .filter(function (runner) {
                        return runner.id <= current.id;
                    }).map(getRunnerTransform).reduce(lmultiply, new Matrix());
            },
            _addRunner: function _addRunner(runner) {
                this._transformationRunners.add(runner); // Make sure that the runner merge is executed at the very end of
                // all Animator functions. Thats why we use immediate here to execute
                // the merge right after all frames are run


                Animator.cancelImmediate(this._frameId);
                this._frameId = Animator.immediate(mergeTransforms.bind(this));
            },
            _prepareRunner: function _prepareRunner() {
                if (this._frameId == null) {
                    this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));
                }
            }
        }
    });
    extend(Runner, {
        attr: function attr(a, v) {
            return this.styleAttr('attr', a, v);
        },
        // Add animatable styles
        css: function css(s, v) {
            return this.styleAttr('css', s, v);
        },
        styleAttr: function styleAttr(type, name, val) {
            // apply attributes individually
            if (_typeof(name) === 'object') {
                for (var key in name) {
                    this.styleAttr(type, key, name[key]);
                }

                return this;
            }

            var morpher = new Morphable(this._stepper).to(val);
            this.queue(function () {
                morpher = morpher.from(this.element()[type](name));
            }, function (pos) {
                this.element()[type](name, morpher.at(pos));
                return morpher.done();
            });
            return this;
        },
        zoom: function zoom(level, point) {
            if (this._tryRetarget('zoom', to, point)) return this;
            var morpher = new Morphable(this._stepper).to(new SVGNumber(level));
            this.queue(function () {
                morpher = morpher.from(this.element().zoom());
            }, function (pos) {
                this.element().zoom(morpher.at(pos), point);
                return morpher.done();
            }, function (newLevel, newPoint) {
                point = newPoint;
                morpher.to(newLevel);
            });

            this._rememberMorpher('zoom', morpher);

            return this;
        },

        /**
         ** absolute transformations
         **/
        //
        // M v -----|-----(D M v = F v)------|----->  T v
        //
        // 1. define the final state (T) and decompose it (once)
        //    t = [tx, ty, the, lam, sy, sx]
        // 2. on every frame: pull the current state of all previous transforms
        //    (M - m can change)
        //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
        // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
        //   - Note F(0) = M
        //   - Note F(1) = T
        // 4. Now you get the delta matrix as a result: D = F * inv(M)
        transform: function transform(transforms, relative, affine) {
            // If we have a declarative function, we should retarget it if possible
            relative = transforms.relative || relative;

            if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {
                return this;
            } // Parse the parameters


            var isMatrix = Matrix.isMatrixLike(transforms);
            affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix; // Create a morepher and set its type

            var morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);
            var origin;
            var element;
            var current;
            var currentAngle;
            var startTransform;

            function setup() {
                // make sure element and origin is defined
                element = element || this.element();
                origin = origin || getOrigin(transforms, element);
                startTransform = new Matrix(relative ? undefined : element); // add the runner to the element so it can merge transformations

                element._addRunner(this); // Deactivate all transforms that have run so far if we are absolute


                if (!relative) {
                    element._clearTransformRunnersBefore(this);
                }
            }

            function run(pos) {
                // clear all other transforms before this in case something is saved
                // on this runner. We are absolute. We dont need these!
                if (!relative) this.clearTransform();

                var _transform = new Point(origin).transform(element._currentTransform(this)),
                    x = _transform.x,
                    y = _transform.y;

                var target = new Matrix(_objectSpread$1({}, transforms, {
                    origin: [x, y]
                }));
                var start = this._isDeclarative && current ? current : startTransform;

                if (affine) {
                    target = target.decompose(x, y);
                    start = start.decompose(x, y); // Get the current and target angle as it was set

                    var rTarget = target.rotate;
                    var rCurrent = start.rotate; // Figure out the shortest path to rotate directly

                    var possibilities = [rTarget - 360, rTarget, rTarget + 360];
                    var distances = possibilities.map(function (a) {
                        return Math.abs(a - rCurrent);
                    });
                    var shortest = Math.min.apply(Math, _toConsumableArray(distances));
                    var index = distances.indexOf(shortest);
                    target.rotate = possibilities[index];
                }

                if (relative) {
                    // we have to be careful here not to overwrite the rotation
                    // with the rotate method of Matrix
                    if (!isMatrix) {
                        target.rotate = transforms.rotate || 0;
                    }

                    if (this._isDeclarative && currentAngle) {
                        start.rotate = currentAngle;
                    }
                }

                morpher.from(start);
                morpher.to(target);
                var affineParameters = morpher.at(pos);
                currentAngle = affineParameters.rotate;
                current = new Matrix(affineParameters);
                this.addTransform(current);

                element._addRunner(this);

                return morpher.done();
            }

            function retarget(newTransforms) {
                // only get a new origin if it changed since the last call
                if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {
                    origin = getOrigin(transforms, element);
                } // overwrite the old transformations with the new ones


                transforms = _objectSpread$1({}, newTransforms, {
                    origin: origin
                });
            }

            this.queue(setup, run, retarget, true);
            this._isDeclarative && this._rememberMorpher('transform', morpher);
            return this;
        },
        // Animatable x-axis
        x: function x(_x, relative) {
            return this._queueNumber('x', _x);
        },
        // Animatable y-axis
        y: function y(_y) {
            return this._queueNumber('y', _y);
        },
        dx: function dx() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            return this._queueNumberDelta('x', x);
        },
        dy: function dy() {
            var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            return this._queueNumberDelta('y', y);
        },
        dmove: function dmove(x, y) {
            return this.dx(x).dy(y);
        },
        _queueNumberDelta: function _queueNumberDelta(method, to) {
            to = new SVGNumber(to); // Try to change the target if we have this method already registerd

            if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation

            var morpher = new Morphable(this._stepper).to(to);
            var from = null;
            this.queue(function () {
                from = this.element()[method]();
                morpher.from(from);
                morpher.to(from + to);
            }, function (pos) {
                this.element()[method](morpher.at(pos));
                return morpher.done();
            }, function (newTo) {
                morpher.to(from + new SVGNumber(newTo));
            }); // Register the morpher so that if it is changed again, we can retarget it

            this._rememberMorpher(method, morpher);

            return this;
        },
        _queueObject: function _queueObject(method, to) {
            // Try to change the target if we have this method already registerd
            if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation

            var morpher = new Morphable(this._stepper).to(to);
            this.queue(function () {
                morpher.from(this.element()[method]());
            }, function (pos) {
                this.element()[method](morpher.at(pos));
                return morpher.done();
            }); // Register the morpher so that if it is changed again, we can retarget it

            this._rememberMorpher(method, morpher);

            return this;
        },
        _queueNumber: function _queueNumber(method, value) {
            return this._queueObject(method, new SVGNumber(value));
        },
        // Animatable center x-axis
        cx: function cx(x) {
            return this._queueNumber('cx', x);
        },
        // Animatable center y-axis
        cy: function cy(y) {
            return this._queueNumber('cy', y);
        },
        // Add animatable move
        move: function move(x, y) {
            return this.x(x).y(y);
        },
        // Add animatable center
        center: function center(x, y) {
            return this.cx(x).cy(y);
        },
        // Add animatable size
        size: function size(width, height) {
            // animate bbox based size for all other elements
            var box;

            if (!width || !height) {
                box = this._element.bbox();
            }

            if (!width) {
                width = box.width / box.height * height;
            }

            if (!height) {
                height = box.height / box.width * width;
            }

            return this.width(width).height(height);
        },
        // Add animatable width
        width: function width(_width) {
            return this._queueNumber('width', _width);
        },
        // Add animatable height
        height: function height(_height) {
            return this._queueNumber('height', _height);
        },
        // Add animatable plot
        plot: function plot(a, b, c, d) {
            // Lines can be plotted with 4 arguments
            if (arguments.length === 4) {
                return this.plot([a, b, c, d]);
            }

            if (this._tryRetarget('plot', a)) return this;
            var morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);
            this.queue(function () {
                morpher.from(this._element.array());
            }, function (pos) {
                this._element.plot(morpher.at(pos));

                return morpher.done();
            });

            this._rememberMorpher('plot', morpher);

            return this;
        },
        // Add leading method
        leading: function leading(value) {
            return this._queueNumber('leading', value);
        },
        // Add animatable viewbox
        viewbox: function viewbox(x, y, width, height) {
            return this._queueObject('viewbox', new Box(x, y, width, height));
        },
        update: function update(o) {
            if (_typeof(o) !== 'object') {
                return this.update({
                    offset: arguments[0],
                    color: arguments[1],
                    opacity: arguments[2]
                });
            }

            if (o.opacity != null) this.attr('stop-opacity', o.opacity);
            if (o.color != null) this.attr('stop-color', o.color);
            if (o.offset != null) this.attr('offset', o.offset);
            return this;
        }
    });
    extend(Runner, {
        rx: rx,
        ry: ry,
        from: from,
        to: to
    });
    register(Runner, 'Runner');

    var Svg =
        /*#__PURE__*/
        function (_Container) {
            _inherits(Svg, _Container);

            function Svg(node) {
                var _this;

                _classCallCheck(this, Svg);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Svg).call(this, nodeOrNew('svg', node), node));

                _this.namespace();

                return _this;
            }

            _createClass(Svg, [{
                key: "isRoot",
                value: function isRoot() {
                    return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) || this.node.parentNode.nodeName === '#document';
                } // Check if this is a root svg
                // If not, call docs from this element

            }, {
                key: "root",
                value: function root() {
                    if (this.isRoot()) return this;
                    return _get(_getPrototypeOf(Svg.prototype), "root", this).call(this);
                } // Add namespaces

            }, {
                key: "namespace",
                value: function namespace() {
                    if (!this.isRoot()) return this.root().namespace();
                    return this.attr({
                        xmlns: ns,
                        version: '1.1'
                    }).attr('xmlns:xlink', xlink, xmlns).attr('xmlns:svgjs', svgjs, xmlns);
                } // Creates and returns defs element

            }, {
                key: "defs",
                value: function defs() {
                    if (!this.isRoot()) return this.root().defs();
                    return adopt(this.node.querySelector('defs')) || this.put(new Defs());
                } // custom parent method

            }, {
                key: "parent",
                value: function parent(type) {
                    if (this.isRoot()) {
                        return this.node.parentNode.nodeName === '#document' ? null : adopt(this.node.parentNode);
                    }

                    return _get(_getPrototypeOf(Svg.prototype), "parent", this).call(this, type);
                }
            }, {
                key: "clear",
                value: function clear() {
                    // remove children
                    while (this.node.hasChildNodes()) {
                        this.node.removeChild(this.node.lastChild);
                    } // remove defs reference


                    delete this._defs;
                    return this;
                }
            }]);

            return Svg;
        }(Container);
    registerMethods({
        Container: {
            // Create nested svg document
            nested: wrapWithAttrCheck(function () {
                return this.put(new Svg());
            })
        }
    });
    register(Svg, 'Svg', true);

    var _Symbol =
        /*#__PURE__*/
        function (_Container) {
            _inherits(_Symbol, _Container);

            // Initialize node
            function _Symbol(node) {
                _classCallCheck(this, _Symbol);

                return _possibleConstructorReturn(this, _getPrototypeOf(_Symbol).call(this, nodeOrNew('symbol', node), node));
            }

            return _Symbol;
        }(Container);
    registerMethods({
        Container: {
            symbol: wrapWithAttrCheck(function () {
                return this.put(new _Symbol());
            })
        }
    });
    register(_Symbol, 'Symbol');

    function plain(text) {
        // clear if build mode is disabled
        if (this._build === false) {
            this.clear();
        } // create text node


        this.node.appendChild(globals.document.createTextNode(text));
        return this;
    } // Get length of text element

    function length() {
        return this.node.getComputedTextLength();
    }

    var textable = ({
        __proto__: null,
        plain: plain,
        length: length
    });

    var Text =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Text, _Shape);

            // Initialize node
            function Text(node) {
                var _this;

                _classCallCheck(this, Text);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, nodeOrNew('text', node), node));
                _this.dom.leading = new SVGNumber(1.3); // store leading value for rebuilding

                _this._rebuild = true; // enable automatic updating of dy values

                _this._build = false; // disable build mode for adding multiple lines

                return _this;
            } // Move over x-axis
            // Text is moved its bounding box
            // text-anchor does NOT matter


            _createClass(Text, [{
                key: "x",
                value: function x(_x) {
                    var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

                    if (_x == null) {
                        return box.x;
                    }

                    return this.attr('x', this.attr('x') + _x - box.x);
                } // Move over y-axis

            }, {
                key: "y",
                value: function y(_y) {
                    var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

                    if (_y == null) {
                        return box.y;
                    }

                    return this.attr('y', this.attr('y') + _y - box.y);
                }
            }, {
                key: "move",
                value: function move(x, y) {
                    var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
                    return this.x(x, box).y(y, box);
                } // Move center over x-axis

            }, {
                key: "cx",
                value: function cx(x) {
                    var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

                    if (x == null) {
                        return box.cx;
                    }

                    return this.attr('x', this.attr('x') + x - box.cx);
                } // Move center over y-axis

            }, {
                key: "cy",
                value: function cy(y) {
                    var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

                    if (y == null) {
                        return box.cy;
                    }

                    return this.attr('y', this.attr('y') + y - box.cy);
                }
            }, {
                key: "center",
                value: function center(x, y) {
                    var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
                    return this.cx(x, box).cy(y, box);
                } // Set the text content

            }, {
                key: "text",
                value: function text(_text) {
                    // act as getter
                    if (_text === undefined) {
                        var children = this.node.childNodes;
                        var firstLine = 0;
                        _text = '';

                        for (var i = 0, len = children.length; i < len; ++i) {
                            // skip textPaths - they are no lines
                            if (children[i].nodeName === 'textPath') {
                                if (i === 0) firstLine = 1;
                                continue;
                            } // add newline if its not the first child and newLined is set to true


                            if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {
                                _text += '\n';
                            } // add content of this node


                            _text += children[i].textContent;
                        }

                        return _text;
                    } // remove existing content


                    this.clear().build(true);

                    if (typeof _text === 'function') {
                        // call block
                        _text.call(this, this);
                    } else {
                        // store text and make sure text is not blank
                        _text = _text.split('\n'); // build new lines

                        for (var j = 0, jl = _text.length; j < jl; j++) {
                            this.tspan(_text[j]).newLine();
                        }
                    } // disable build mode and rebuild lines


                    return this.build(false).rebuild();
                } // Set / get leading

            }, {
                key: "leading",
                value: function leading(value) {
                    // act as getter
                    if (value == null) {
                        return this.dom.leading;
                    } // act as setter


                    this.dom.leading = new SVGNumber(value);
                    return this.rebuild();
                } // Rebuild appearance type

            }, {
                key: "rebuild",
                value: function rebuild(_rebuild) {
                    // store new rebuild flag if given
                    if (typeof _rebuild === 'boolean') {
                        this._rebuild = _rebuild;
                    } // define position of all lines


                    if (this._rebuild) {
                        var self = this;
                        var blankLineOffset = 0;
                        var leading = this.dom.leading;
                        this.each(function () {
                            var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
                            var dy = leading * new SVGNumber(fontSize);

                            if (this.dom.newLined) {
                                this.attr('x', self.attr('x'));

                                if (this.text() === '\n') {
                                    blankLineOffset += dy;
                                } else {
                                    this.attr('dy', dy + blankLineOffset);
                                    blankLineOffset = 0;
                                }
                            }
                        });
                        this.fire('rebuild');
                    }

                    return this;
                } // Enable / disable build mode

            }, {
                key: "build",
                value: function build(_build) {
                    this._build = !!_build;
                    return this;
                } // overwrite method from parent to set data properly

            }, {
                key: "setData",
                value: function setData(o) {
                    this.dom = o;
                    this.dom.leading = new SVGNumber(o.leading || 1.3);
                    return this;
                }
            }]);

            return Text;
        }(Shape);
    extend(Text, textable);
    registerMethods({
        Container: {
            // Create text element
            text: wrapWithAttrCheck(function (text) {
                return this.put(new Text()).text(text);
            }),
            // Create plain text element
            plain: wrapWithAttrCheck(function (text) {
                return this.put(new Text()).plain(text);
            })
        }
    });
    register(Text, 'Text');

    var Tspan =
        /*#__PURE__*/
        function (_Text) {
            _inherits(Tspan, _Text);

            // Initialize node
            function Tspan(node) {
                _classCallCheck(this, Tspan);

                return _possibleConstructorReturn(this, _getPrototypeOf(Tspan).call(this, nodeOrNew('tspan', node), node));
            } // Set text content


            _createClass(Tspan, [{
                key: "text",
                value: function text(_text) {
                    if (_text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '');
                    typeof _text === 'function' ? _text.call(this, this) : this.plain(_text);
                    return this;
                } // Shortcut dx

            }, {
                key: "dx",
                value: function dx(_dx) {
                    return this.attr('dx', _dx);
                } // Shortcut dy

            }, {
                key: "dy",
                value: function dy(_dy) {
                    return this.attr('dy', _dy);
                }
            }, {
                key: "x",
                value: function x(_x) {
                    return this.attr('x', _x);
                }
            }, {
                key: "y",
                value: function y(_y) {
                    return this.attr('x', _y);
                }
            }, {
                key: "move",
                value: function move(x, y) {
                    return this.x(x).y(y);
                } // Create new line

            }, {
                key: "newLine",
                value: function newLine() {
                    // fetch text parent
                    var t = this.parent(Text); // mark new line

                    this.dom.newLined = true;
                    var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
                    var dy = t.dom.leading * new SVGNumber(fontSize); // apply new position

                    return this.dy(dy).attr('x', t.x());
                }
            }]);

            return Tspan;
        }(Text);
    extend(Tspan, textable);
    registerMethods({
        Tspan: {
            tspan: wrapWithAttrCheck(function (text) {
                var tspan = new Tspan(); // clear if build mode is disabled

                if (!this._build) {
                    this.clear();
                } // add new tspan


                this.node.appendChild(tspan.node);
                return tspan.text(text);
            })
        }
    });
    register(Tspan, 'Tspan');

    var ClipPath =
        /*#__PURE__*/
        function (_Container) {
            _inherits(ClipPath, _Container);

            function ClipPath(node) {
                _classCallCheck(this, ClipPath);

                return _possibleConstructorReturn(this, _getPrototypeOf(ClipPath).call(this, nodeOrNew('clipPath', node), node));
            } // Unclip all clipped elements and remove itself


            _createClass(ClipPath, [{
                key: "remove",
                value: function remove() {
                    // unclip all targets
                    this.targets().forEach(function (el) {
                        el.unclip();
                    }); // remove clipPath from parent

                    return _get(_getPrototypeOf(ClipPath.prototype), "remove", this).call(this);
                }
            }, {
                key: "targets",
                value: function targets() {
                    return baseFind('svg [clip-path*="' + this.id() + '"]');
                }
            }]);

            return ClipPath;
        }(Container);
    registerMethods({
        Container: {
            // Create clipping element
            clip: wrapWithAttrCheck(function () {
                return this.defs().put(new ClipPath());
            })
        },
        Element: {
            // Distribute clipPath to svg element
            clipWith: function clipWith(element) {
                // use given clip or create a new one
                var clipper = element instanceof ClipPath ? element : this.parent().clip().add(element); // apply mask

                return this.attr('clip-path', 'url("#' + clipper.id() + '")');
            },
            // Unclip element
            unclip: function unclip() {
                return this.attr('clip-path', null);
            },
            clipper: function clipper() {
                return this.reference('clip-path');
            }
        }
    });
    register(ClipPath, 'ClipPath');

    var ForeignObject =
        /*#__PURE__*/
        function (_Element) {
            _inherits(ForeignObject, _Element);

            function ForeignObject(node) {
                _classCallCheck(this, ForeignObject);

                return _possibleConstructorReturn(this, _getPrototypeOf(ForeignObject).call(this, nodeOrNew('foreignObject', node), node));
            }

            return ForeignObject;
        }(Element);
    registerMethods({
        Container: {
            foreignObject: wrapWithAttrCheck(function (width, height) {
                return this.put(new ForeignObject()).size(width, height);
            })
        }
    });
    register(ForeignObject, 'ForeignObject');

    var G =
        /*#__PURE__*/
        function (_Container) {
            _inherits(G, _Container);

            function G(node) {
                _classCallCheck(this, G);

                return _possibleConstructorReturn(this, _getPrototypeOf(G).call(this, nodeOrNew('g', node), node));
            }

            _createClass(G, [{
                key: "x",
                value: function x(_x) {
                    var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
                    if (_x == null) return box.x;
                    return this.move(_x, box.y, box);
                }
            }, {
                key: "y",
                value: function y(_y) {
                    var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
                    if (_y == null) return box.y;
                    return this.move(box.x, _y, box);
                }
            }, {
                key: "move",
                value: function move() {
                    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
                    var dx = x - box.x;
                    var dy = y - box.y;
                    return this.dmove(dx, dy);
                }
            }, {
                key: "dx",
                value: function dx(_dx) {
                    return this.dmove(_dx, 0);
                }
            }, {
                key: "dy",
                value: function dy(_dy) {
                    return this.dmove(0, _dy);
                }
            }, {
                key: "dmove",
                value: function dmove(dx, dy) {
                    this.children().forEach(function (child, i) {
                        // Get the childs bbox
                        var bbox = child.bbox(); // Get childs matrix

                        var m = new Matrix(child); // Translate childs matrix by amount and
                        // transform it back into parents space

                        var matrix = m.translate(dx, dy).transform(m.inverse()); // Calculate new x and y from old box

                        var p = new Point(bbox.x, bbox.y).transform(matrix); // Move element

                        child.move(p.x, p.y);
                    });
                    return this;
                }
            }, {
                key: "width",
                value: function width(_width) {
                    var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
                    if (_width == null) return box.width;
                    return this.size(_width, box.height, box);
                }
            }, {
                key: "height",
                value: function height(_height) {
                    var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
                    if (_height == null) return box.height;
                    return this.size(box.width, _height, box);
                }
            }, {
                key: "size",
                value: function size(width, height) {
                    var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
                    var p = proportionalSize(this, width, height, box);
                    var scaleX = p.width / box.width;
                    var scaleY = p.height / box.height;
                    this.children().forEach(function (child, i) {
                        var o = new Point(box).transform(new Matrix(child).inverse());
                        child.scale(scaleX, scaleY, o.x, o.y);
                    });
                    return this;
                }
            }]);

            return G;
        }(Container);
    registerMethods({
        Container: {
            // Create a group element
            group: wrapWithAttrCheck(function () {
                return this.put(new G());
            })
        }
    });
    register(G, 'G');

    var A =
        /*#__PURE__*/
        function (_Container) {
            _inherits(A, _Container);

            function A(node) {
                _classCallCheck(this, A);

                return _possibleConstructorReturn(this, _getPrototypeOf(A).call(this, nodeOrNew('a', node), node));
            } // Link url


            _createClass(A, [{
                key: "to",
                value: function to(url) {
                    return this.attr('href', url, xlink);
                } // Link target attribute

            }, {
                key: "target",
                value: function target(_target) {
                    return this.attr('target', _target);
                }
            }]);

            return A;
        }(Container);
    registerMethods({
        Container: {
            // Create a hyperlink element
            link: wrapWithAttrCheck(function (url) {
                return this.put(new A()).to(url);
            })
        },
        Element: {
            // Create a hyperlink element
            linkTo: function linkTo(url) {
                var link = new A();

                if (typeof url === 'function') {
                    url.call(link, link);
                } else {
                    link.to(url);
                }

                return this.parent().put(link).put(this);
            }
        }
    });
    register(A, 'A');

    var Mask =
        /*#__PURE__*/
        function (_Container) {
            _inherits(Mask, _Container);

            // Initialize node
            function Mask(node) {
                _classCallCheck(this, Mask);

                return _possibleConstructorReturn(this, _getPrototypeOf(Mask).call(this, nodeOrNew('mask', node), node));
            } // Unmask all masked elements and remove itself


            _createClass(Mask, [{
                key: "remove",
                value: function remove() {
                    // unmask all targets
                    this.targets().forEach(function (el) {
                        el.unmask();
                    }); // remove mask from parent

                    return _get(_getPrototypeOf(Mask.prototype), "remove", this).call(this);
                }
            }, {
                key: "targets",
                value: function targets() {
                    return baseFind('svg [mask*="' + this.id() + '"]');
                }
            }]);

            return Mask;
        }(Container);
    registerMethods({
        Container: {
            mask: wrapWithAttrCheck(function () {
                return this.defs().put(new Mask());
            })
        },
        Element: {
            // Distribute mask to svg element
            maskWith: function maskWith(element) {
                // use given mask or create a new one
                var masker = element instanceof Mask ? element : this.parent().mask().add(element); // apply mask

                return this.attr('mask', 'url("#' + masker.id() + '")');
            },
            // Unmask element
            unmask: function unmask() {
                return this.attr('mask', null);
            },
            masker: function masker() {
                return this.reference('mask');
            }
        }
    });
    register(Mask, 'Mask');

    function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function cssRule(selector, rule) {
        if (!selector) return '';
        if (!rule) return selector;
        var ret = selector + '{';

        for (var i in rule) {
            ret += unCamelCase(i) + ':' + rule[i] + ';';
        }

        ret += '}';
        return ret;
    }

    var Style =
        /*#__PURE__*/
        function (_Element) {
            _inherits(Style, _Element);

            function Style(node) {
                _classCallCheck(this, Style);

                return _possibleConstructorReturn(this, _getPrototypeOf(Style).call(this, nodeOrNew('style', node), node));
            }

            _createClass(Style, [{
                key: "addText",
                value: function addText() {
                    var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
                    this.node.textContent += w;
                    return this;
                }
            }, {
                key: "font",
                value: function font(name, src) {
                    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    return this.rule('@font-face', _objectSpread$2({
                        fontFamily: name,
                        src: src
                    }, params));
                }
            }, {
                key: "rule",
                value: function rule(selector, obj) {
                    return this.addText(cssRule(selector, obj));
                }
            }]);

            return Style;
        }(Element);
    registerMethods('Dom', {
        style: wrapWithAttrCheck(function (selector, obj) {
            return this.put(new Style()).rule(selector, obj);
        }),
        fontface: wrapWithAttrCheck(function (name, src, params) {
            return this.put(new Style()).font(name, src, params);
        })
    });
    register(Style, 'Style');

    var TextPath =
        /*#__PURE__*/
        function (_Text) {
            _inherits(TextPath, _Text);

            // Initialize node
            function TextPath(node) {
                _classCallCheck(this, TextPath);

                return _possibleConstructorReturn(this, _getPrototypeOf(TextPath).call(this, nodeOrNew('textPath', node), node));
            } // return the array of the path track element


            _createClass(TextPath, [{
                key: "array",
                value: function array() {
                    var track = this.track();
                    return track ? track.array() : null;
                } // Plot path if any

            }, {
                key: "plot",
                value: function plot(d) {
                    var track = this.track();
                    var pathArray = null;

                    if (track) {
                        pathArray = track.plot(d);
                    }

                    return d == null ? pathArray : this;
                } // Get the path element

            }, {
                key: "track",
                value: function track() {
                    return this.reference('href');
                }
            }]);

            return TextPath;
        }(Text);
    registerMethods({
        Container: {
            textPath: wrapWithAttrCheck(function (text, path) {
                // Convert text to instance if needed
                if (!(text instanceof Text)) {
                    text = this.text(text);
                }

                return text.path(path);
            })
        },
        Text: {
            // Create path for text to run on
            path: wrapWithAttrCheck(function (track) {
                var importNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                var textPath = new TextPath(); // if track is a path, reuse it

                if (!(track instanceof Path)) {
                    // create path element
                    track = this.defs().path(track);
                } // link textPath to path and add content


                textPath.attr('href', '#' + track, xlink); // Transplant all nodes from text to textPath

                var node;

                if (importNodes) {
                    while (node = this.node.firstChild) {
                        textPath.node.appendChild(node);
                    }
                } // add textPath element as child node and return textPath


                return this.put(textPath);
            }),
            // Get the textPath children
            textPath: function textPath() {
                return this.findOne('textPath');
            }
        },
        Path: {
            // creates a textPath from this path
            text: wrapWithAttrCheck(function (text) {
                // Convert text to instance if needed
                if (!(text instanceof Text)) {
                    text = new Text().addTo(this.parent()).text(text);
                } // Create textPath from text and path and return


                return text.path(this);
            }),
            targets: function targets() {
                return baseFind('svg [href*="' + this.id() + '"]');
            }
        }
    });
    TextPath.prototype.MorphArray = PathArray;
    register(TextPath, 'TextPath');

    var Use =
        /*#__PURE__*/
        function (_Shape) {
            _inherits(Use, _Shape);

            function Use(node) {
                _classCallCheck(this, Use);

                return _possibleConstructorReturn(this, _getPrototypeOf(Use).call(this, nodeOrNew('use', node), node));
            } // Use element as a reference


            _createClass(Use, [{
                key: "element",
                value: function element(_element, file) {
                    // Set lined element
                    return this.attr('href', (file || '') + '#' + _element, xlink);
                }
            }]);

            return Use;
        }(Shape);
    registerMethods({
        Container: {
            // Create a use element
            use: wrapWithAttrCheck(function (element, file) {
                return this.put(new Use()).element(element, file);
            })
        }
    });
    register(Use, 'Use');

    /* Optional Modules */
    var SVG = makeInstance;
    extend([Svg, _Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'));
    extend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));
    extend(Text, getMethodsFor('Text'));
    extend(Path, getMethodsFor('Path'));
    extend(Defs, getMethodsFor('Defs'));
    extend([Text, Tspan], getMethodsFor('Tspan'));
    extend([Rect, Ellipse, Circle, Gradient], getMethodsFor('radius'));
    extend(EventTarget, getMethodsFor('EventTarget'));
    extend(Dom, getMethodsFor('Dom'));
    extend(Element, getMethodsFor('Element'));
    extend(Shape, getMethodsFor('Shape')); // extend(Element, getConstructor('Memory'))

    extend(Container, getMethodsFor('Container'));
    extend(Runner, getMethodsFor('Runner'));
    List.extend(getMethodNames());
    registerMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray]);
    makeMorphable();

    var svgMembers = ({
        __proto__: null,
        Morphable: Morphable,
        registerMorphableType: registerMorphableType,
        makeMorphable: makeMorphable,
        TransformBag: TransformBag,
        ObjectBag: ObjectBag,
        NonMorphable: NonMorphable,
        defaults: defaults,
        utils: utils,
        namespaces: namespaces,
        regex: regex,
        SVG: SVG,
        parser: parser,
        find: baseFind,
        registerWindow: registerWindow,
        Animator: Animator,
        Controller: Controller,
        Ease: Ease,
        PID: PID,
        Spring: Spring,
        easing: easing,
        Queue: Queue,
        Runner: Runner,
        Timeline: Timeline,
        Array: SVGArray,
        Box: Box,
        Color: Color,
        EventTarget: EventTarget,
        Matrix: Matrix,
        Number: SVGNumber,
        PathArray: PathArray,
        Point: Point,
        PointArray: PointArray,
        List: List,
        Circle: Circle,
        ClipPath: ClipPath,
        Container: Container,
        Defs: Defs,
        Dom: Dom,
        Element: Element,
        Ellipse: Ellipse,
        ForeignObject: ForeignObject,
        Gradient: Gradient,
        G: G,
        A: A,
        Image: Image,
        Line: Line,
        Marker: Marker,
        Mask: Mask,
        Path: Path,
        Pattern: Pattern,
        Polygon: Polygon,
        Polyline: Polyline,
        Rect: Rect,
        Shape: Shape,
        Stop: Stop,
        Style: Style,
        Svg: Svg,
        Symbol: _Symbol,
        Text: Text,
        TextPath: TextPath,
        Tspan: Tspan,
        Use: Use,
        on: on,
        off: off,
        dispatch: dispatch,
        root: root,
        create: create,
        makeInstance: makeInstance,
        nodeOrNew: nodeOrNew,
        adopt: adopt,
        mockAdopt: mockAdopt,
        register: register,
        getClass: getClass,
        eid: eid,
        assignNewId: assignNewId,
        extend: extend,
        wrapWithAttrCheck: wrapWithAttrCheck,
        invent: invent
    });

    function SVG$1(element) {
        return makeInstance(element);
    }
    Object.assign(SVG$1, svgMembers);

    return SVG$1;

}());
//# sourceMappingURL=svg.js.map


/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));
})(this, (function (exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    /* eslint-disable space-unary-ops */

    /* Public constants ==========================================================*/
    /* ===========================================================================*/


    //const Z_FILTERED          = 1;
    //const Z_HUFFMAN_ONLY      = 2;
    //const Z_RLE               = 3;
    const Z_FIXED$1 = 4;
    //const Z_DEFAULT_STRATEGY  = 0;

    /* Possible values of the data_type field (though see inflate()) */
    const Z_BINARY = 0;
    const Z_TEXT = 1;
    //const Z_ASCII             = 1; // = Z_TEXT
    const Z_UNKNOWN$1 = 2;

    /*============================================================================*/


    function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

    // From zutil.h

    const STORED_BLOCK = 0;
    const STATIC_TREES = 1;
    const DYN_TREES = 2;
    /* The three kinds of block type */

    const MIN_MATCH$1 = 3;
    const MAX_MATCH$1 = 258;
    /* The minimum and maximum match lengths */

    // From deflate.h
    /* ===========================================================================
   * Internal compression state.
   */

    const LENGTH_CODES$1 = 29;
    /* number of length codes, not counting the special END_BLOCK code */

    const LITERALS$1 = 256;
    /* number of literal bytes 0..255 */

    const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    /* number of Literal or Length codes, including the END_BLOCK code */

    const D_CODES$1 = 30;
    /* number of distance codes */

    const BL_CODES$1 = 19;
    /* number of codes used to transfer the bit lengths */

    const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    /* maximum heap size */

    const MAX_BITS$1 = 15;
    /* All codes must not exceed MAX_BITS bits */

    const Buf_size = 16;
    /* size of bit buffer in bi_buf */


    /* ===========================================================================
   * Constants
   */

    const MAX_BL_BITS = 7;
    /* Bit length codes must not exceed MAX_BL_BITS bits */

    const END_BLOCK = 256;
    /* end of block literal code */

    const REP_3_6 = 16;
    /* repeat previous bit length 3-6 times (2 bits of repeat count) */

    const REPZ_3_10 = 17;
    /* repeat a zero length 3-10 times  (3 bits of repeat count) */

    const REPZ_11_138 = 18;
    /* repeat a zero length 11-138 times  (7 bits of repeat count) */

    /* eslint-disable comma-spacing,array-bracket-spacing */
    const extra_lbits =   /* extra bits for each length code */
        new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);

    const extra_dbits =   /* extra bits for each distance code */
        new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);

    const extra_blbits =  /* extra bits for each bit length code */
        new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);

    const bl_order =
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    /* eslint-enable comma-spacing,array-bracket-spacing */

    /* The lengths of the bit length codes are sent in order of decreasing
   * probability, to avoid transmitting the lengths for unused bit length codes.
   */

    /* ===========================================================================
   * Local data. These are initialized only once.
   */

    // We pre-fill arrays with 0 to avoid uninitialized gaps

    const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
    const static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    /* The static literal tree. Since the bit lengths are imposed, there is no
   * need for the L_CODES extra codes used during heap construction. However
   * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
   * below).
   */

    const static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    /* The static distance tree. (Actually a trivial tree since all codes use
   * 5 bits.)
   */

    const _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    /* Distance codes. The first 256 values correspond to the distances
   * 3 .. 258, the last 256 values correspond to the top 8 bits of
   * the 15 bit distances.
   */

    const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    /* length code for each normalized match length (0 == MIN_MATCH) */

    const base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    /* First normalized length for each code (0 = MIN_MATCH) */

    const base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    /* First normalized distance for each code (0 = distance of 1) */


    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

        this.static_tree = static_tree;  /* static tree or NULL */
        this.extra_bits = extra_bits;   /* extra bits for each code or NULL */
        this.extra_base = extra_base;   /* base index for extra_bits */
        this.elems = elems;        /* max number of elements in the tree */
        this.max_length = max_length;   /* max bit length for the codes */

        // show if `static_tree` has data or dummy - needed for monomorphic objects
        this.has_stree = static_tree && static_tree.length;
    }


    let static_l_desc;
    let static_d_desc;
    let static_bl_desc;


    function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;     /* the dynamic tree */
        this.max_code = 0;            /* largest code with non zero frequency */
        this.stat_desc = stat_desc;   /* the corresponding static tree */
    }



    const d_code = (dist) => {

        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };


    /* ===========================================================================
   * Output a short LSB first on the stream.
   * IN assertion: there is enough room in pendingBuf.
   */
    const put_short = (s, w) => {
        //    put_byte(s, (uch)((w) & 0xff));
        //    put_byte(s, (uch)((ush)(w) >> 8));
        s.pending_buf[s.pending++] = (w) & 0xff;
        s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    };


    /* ===========================================================================
   * Send a value on a given number of bits.
   * IN assertion: length <= 16 and value fits in length bits.
   */
    const send_bits = (s, value, length) => {

        if (s.bi_valid > (Buf_size - length)) {
            s.bi_buf |= (value << s.bi_valid) & 0xffff;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> (Buf_size - s.bi_valid);
            s.bi_valid += length - Buf_size;
        } else {
            s.bi_buf |= (value << s.bi_valid) & 0xffff;
            s.bi_valid += length;
        }
    };


    const send_code = (s, c, tree) => {

        send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
    };


    /* ===========================================================================
   * Reverse the first len bits of a code, using straightforward code (a faster
   * method would use a table)
   * IN assertion: 1 <= len <= 15
   */
    const bi_reverse = (code, len) => {

        let res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        } while (--len > 0);
        return res >>> 1;
    };


    /* ===========================================================================
   * Flush the bit buffer, keeping at most 7 bits in it.
   */
    const bi_flush = (s) => {

        if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;

        } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 0xff;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
        }
    };


    /* ===========================================================================
   * Compute the optimal bit lengths for a tree and update the total bit length
   * for the current block.
   * IN assertion: the fields freq and dad are set, heap[heap_max] and
   *    above are the tree nodes sorted by increasing frequency.
   * OUT assertions: the field len is set to the optimal bit length, the
   *     array bl_count contains the frequencies for each bit length.
   *     The length opt_len is updated; static_len is also updated if stree is
   *     not null.
   */
    const gen_bitlen = (s, desc) => {
        //    deflate_state *s;
        //    tree_desc *desc;    /* the tree descriptor */

        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h;              /* heap index */
        let n, m;           /* iterate over the tree elements */
        let bits;           /* bit length */
        let xbits;          /* extra bits */
        let f;              /* frequency */
        let overflow = 0;   /* number of elements with bit length too large */

        for (bits = 0; bits <= MAX_BITS$1; bits++) {
            s.bl_count[bits] = 0;
        }

        /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
        tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

        for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n * 2 + 1]/*.Len*/ = bits;
            /* We overwrite tree[n].Dad which is no longer needed */

            if (n > max_code) { continue; } /* not a leaf node */

            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
                xbits = extra[n - base];
            }
            f = tree[n * 2]/*.Freq*/;
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
            }
        }
        if (overflow === 0) { return; }

        // Tracev((stderr,"\nbit length overflow\n"));
        /* This happens for example on obj2 and pic of the Calgary corpus */

        /* Find the first bit length which could increase: */
        do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) { bits--; }
            s.bl_count[bits]--;      /* move one leaf down the tree */
            s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
            s.bl_count[max_length]--;
            /* The brother of the overflow item also moves one step up,
       * but this does not affect bl_count[max_length]
       */
            overflow -= 2;
        } while (overflow > 0);

        /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
        for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
                m = s.heap[--h];
                if (m > max_code) { continue; }
                if (tree[m * 2 + 1]/*.Len*/ !== bits) {
                    // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                    s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
                    tree[m * 2 + 1]/*.Len*/ = bits;
                }
                n--;
            }
        }
    };


    /* ===========================================================================
   * Generate the codes for a given tree and bit counts (which need not be
   * optimal).
   * IN assertion: the array bl_count contains the bit length statistics for
   * the given tree and the field len is set for all tree elements.
   * OUT assertion: the field code is set for all tree elements of non
   *     zero code length.
   */
    const gen_codes = (tree, max_code, bl_count) => {
        //    ct_data *tree;             /* the tree to decorate */
        //    int max_code;              /* largest code with non zero frequency */
        //    ushf *bl_count;            /* number of codes at each bit length */

        const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
        let code = 0;              /* running code value */
        let bits;                  /* bit index */
        let n;                     /* code index */

        /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
        for (bits = 1; bits <= MAX_BITS$1; bits++) {
            code = (code + bl_count[bits - 1]) << 1;
            next_code[bits] = code;
        }
        /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
        //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
        //        "inconsistent bit counts");
        //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

        for (n = 0; n <= max_code; n++) {
            let len = tree[n * 2 + 1]/*.Len*/;
            if (len === 0) { continue; }
            /* Now reverse the bits */
            tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

            //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
            //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
        }
    };


    /* ===========================================================================
   * Initialize the various 'constant' tables.
   */
    const tr_static_init = () => {

        let n;        /* iterates over tree elements */
        let bits;     /* bit counter */
        let length;   /* length value */
        let code;     /* code value */
        let dist;     /* distance index */
        const bl_count = new Array(MAX_BITS$1 + 1);
        /* number of codes at each bit length for an optimal tree */

        // do check in _tr_init()
        //if (static_init_done) return;

        /* For some embedded targets, global variables are not initialized: */
        /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

        /* Initialize the mapping length (0..255) -> length code (0..28) */
        length = 0;
        for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < (1 << extra_lbits[code]); n++) {
                _length_code[length++] = code;
            }
        }
        //Assert (length == 256, "tr_static_init: length != 256");
        /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
        _length_code[length - 1] = code;

        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
        dist = 0;
        for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < (1 << extra_dbits[code]); n++) {
                _dist_code[dist++] = code;
            }
        }
        //Assert (dist == 256, "tr_static_init: dist != 256");
        dist >>= 7; /* from now on, all distances are divided by 128 */
        for (; code < D_CODES$1; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
                _dist_code[256 + dist++] = code;
            }
        }
        //Assert (dist == 256, "tr_static_init: 256+dist != 512");

        /* Construct the codes of the static literal tree */
        for (bits = 0; bits <= MAX_BITS$1; bits++) {
            bl_count[bits] = 0;
        }

        n = 0;
        while (n <= 143) {
            static_ltree[n * 2 + 1]/*.Len*/ = 8;
            n++;
            bl_count[8]++;
        }
        while (n <= 255) {
            static_ltree[n * 2 + 1]/*.Len*/ = 9;
            n++;
            bl_count[9]++;
        }
        while (n <= 279) {
            static_ltree[n * 2 + 1]/*.Len*/ = 7;
            n++;
            bl_count[7]++;
        }
        while (n <= 287) {
            static_ltree[n * 2 + 1]/*.Len*/ = 8;
            n++;
            bl_count[8]++;
        }
        /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
        gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

        /* The static distance tree is trivial: */
        for (n = 0; n < D_CODES$1; n++) {
            static_dtree[n * 2 + 1]/*.Len*/ = 5;
            static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
        }

        // Now data ready and we can init static trees
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);

        //static_init_done = true;
    };


    /* ===========================================================================
   * Initialize a new block.
   */
    const init_block = (s) => {

        let n; /* iterates over tree elements */

        /* Initialize the trees. */
        for (n = 0; n < L_CODES$1; n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
        for (n = 0; n < D_CODES$1; n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
        for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

        s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
        s.opt_len = s.static_len = 0;
        s.sym_next = s.matches = 0;
    };


    /* ===========================================================================
   * Flush the bit buffer and align the output on a byte boundary
   */
    const bi_windup = (s) => {
        if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
            //put_byte(s, (Byte)s->bi_buf);
            s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
    };

    /* ===========================================================================
   * Compares to subtrees, using the tree depth as tie breaker when
   * the subtrees have equal frequency. This minimizes the worst case length.
   */
    const smaller = (tree, n, m, depth) => {

        const _n2 = n * 2;
        const _m2 = m * 2;
        return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
            (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
    };

    /* ===========================================================================
   * Restore the heap property by moving down the tree starting at node k,
   * exchanging a node with the smallest of its two sons if necessary, stopping
   * when the heap property is re-established (each father smaller than its
   * two sons).
   */
    const pqdownheap = (s, tree, k) => {
        //    deflate_state *s;
        //    ct_data *tree;  /* the tree to restore */
        //    int k;               /* node to move down */

        const v = s.heap[k];
        let j = k << 1;  /* left son of k */
        while (j <= s.heap_len) {
            /* Set j to the smallest of the two sons: */
            if (j < s.heap_len &&
                smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++;
            }
            /* Exit if v is smaller than both sons */
            if (smaller(tree, v, s.heap[j], s.depth)) { break; }

            /* Exchange v with the smallest son */
            s.heap[k] = s.heap[j];
            k = j;

            /* And continue down the tree, setting j to the left son of k */
            j <<= 1;
        }
        s.heap[k] = v;
    };


    // inlined manually
    // const SMALLEST = 1;

    /* ===========================================================================
   * Send the block data compressed using the given Huffman trees
   */
    const compress_block = (s, ltree, dtree) => {
        //    deflate_state *s;
        //    const ct_data *ltree; /* literal tree */
        //    const ct_data *dtree; /* distance tree */

        let dist;           /* distance of matched string */
        let lc;             /* match length or unmatched char (if dist == 0) */
        let sx = 0;         /* running index in sym_buf */
        let code;           /* the code to send */
        let extra;          /* number of extra bits to send */

        if (s.sym_next !== 0) {
            do {
                dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
                dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
                lc = s.pending_buf[s.sym_buf + sx++];
                if (dist === 0) {
                    send_code(s, lc, ltree); /* send a literal byte */
                    //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                } else {
                    /* Here, lc is the match length - MIN_MATCH */
                    code = _length_code[lc];
                    send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
                    extra = extra_lbits[code];
                    if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);       /* send the extra length bits */
                    }
                    dist--; /* dist is now the match distance - 1 */
                    code = d_code(dist);
                    //Assert (code < D_CODES, "bad d_code");

                    send_code(s, code, dtree);       /* send the distance code */
                    extra = extra_dbits[code];
                    if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);   /* send the extra distance bits */
                    }
                } /* literal or match pair ? */

                /* Check that the overlay between pending_buf and sym_buf is ok: */
                //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

            } while (sx < s.sym_next);
        }

        send_code(s, END_BLOCK, ltree);
    };


    /* ===========================================================================
   * Construct one Huffman tree and assigns the code bit strings and lengths.
   * Update the total bit length for the current block.
   * IN assertion: the field freq is set for all tree elements.
   * OUT assertions: the fields len and code are set to the optimal bit length
   *     and corresponding code. The length opt_len is updated; static_len is
   *     also updated if stree is not null. The field max_code is set.
   */
    const build_tree = (s, desc) => {
        //    deflate_state *s;
        //    tree_desc *desc; /* the tree descriptor */

        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;          /* iterate over heap elements */
        let max_code = -1; /* largest code with non zero frequency */
        let node;          /* new node being created */

        /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE$1;

        for (n = 0; n < elems; n++) {
            if (tree[n * 2]/*.Freq*/ !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;

            } else {
                tree[n * 2 + 1]/*.Len*/ = 0;
            }
        }

        /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
        while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
            tree[node * 2]/*.Freq*/ = 1;
            s.depth[node] = 0;
            s.opt_len--;

            if (has_stree) {
                s.static_len -= stree[node * 2 + 1]/*.Len*/;
            }
            /* node is 0 or 1 so it does not have extra bits */
        }
        desc.max_code = max_code;

        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
        for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

        /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
        node = elems;              /* next internal node of the tree */
        do {
            //pqremove(s, tree, n);  /* n = node of least frequency */
            /*** pqremove ***/
            n = s.heap[1/*SMALLEST*/];
            s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1/*SMALLEST*/);
            /***/

            m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

            s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
            s.heap[--s.heap_max] = m;

            /* Create a new node father of n and m */
            tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

            /* and insert the new node in the heap */
            s.heap[1/*SMALLEST*/] = node++;
            pqdownheap(s, tree, 1/*SMALLEST*/);

        } while (s.heap_len >= 2);

        s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

        /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
        gen_bitlen(s, desc);

        /* The field len is now set, we can generate the bit codes */
        gen_codes(tree, max_code, s.bl_count);
    };


    /* ===========================================================================
   * Scan a literal or distance tree to determine the frequencies of the codes
   * in the bit length tree.
   */
    const scan_tree = (s, tree, max_code) => {
        //    deflate_state *s;
        //    ct_data *tree;   /* the tree to be scanned */
        //    int max_code;    /* and its largest code of non zero frequency */

        let n;                     /* iterates over all tree elements */
        let prevlen = -1;          /* last emitted length */
        let curlen;                /* length of current code */

        let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

        let count = 0;             /* repeat count of the current code */
        let max_count = 7;         /* max repeat count */
        let min_count = 4;         /* min repeat count */

        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

            if (++count < max_count && curlen === nextlen) {
                continue;

            } else if (count < min_count) {
                s.bl_tree[curlen * 2]/*.Freq*/ += count;

            } else if (curlen !== 0) {

                if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
                s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

            } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

            } else {
                s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
            }

            count = 0;
            prevlen = curlen;

            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;

            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;

            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    };


    /* ===========================================================================
   * Send a literal or distance tree in compressed form, using the codes in
   * bl_tree.
   */
    const send_tree = (s, tree, max_code) => {
        //    deflate_state *s;
        //    ct_data *tree; /* the tree to be scanned */
        //    int max_code;       /* and its largest code of non zero frequency */

        let n;                     /* iterates over all tree elements */
        let prevlen = -1;          /* last emitted length */
        let curlen;                /* length of current code */

        let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

        let count = 0;             /* repeat count of the current code */
        let max_count = 7;         /* max repeat count */
        let min_count = 4;         /* min repeat count */

        /* tree[max_code+1].Len = -1; */  /* guard already set */
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }

        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

            if (++count < max_count && curlen === nextlen) {
                continue;

            } else if (count < min_count) {
                do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    send_code(s, curlen, s.bl_tree);
                    count--;
                }
                //Assert(count >= 3 && count <= 6, " 3_6?");
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count - 3, 2);

            } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count - 3, 3);

            } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count - 11, 7);
            }

            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;

            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;

            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    };


    /* ===========================================================================
   * Construct the Huffman tree for the bit lengths and return the index in
   * bl_order of the last bit length code to send.
   */
    const build_bl_tree = (s) => {

        let max_blindex;  /* index of last bit length code of non zero freq */

        /* Determine the bit length frequencies for literal and distance trees */
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

        /* Build the bit length tree: */
        build_tree(s, s.bl_desc);
        /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

        /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
        for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
                break;
            }
        }
        /* Update opt_len to include the bit length tree and counts */
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
        //        s->opt_len, s->static_len));

        return max_blindex;
    };


    /* ===========================================================================
   * Send the header for a block using dynamic Huffman trees: the counts, the
   * lengths of the bit length codes, the literal tree and the distance tree.
   * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
   */
    const send_all_trees = (s, lcodes, dcodes, blcodes) => {
        //    deflate_state *s;
        //    int lcodes, dcodes, blcodes; /* number of codes for each tree */

        let rank;                    /* index in bl_order */

        //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
        //        "too many codes");
        //Tracev((stderr, "\nbl counts: "));
        send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
        for (rank = 0; rank < blcodes; rank++) {
            //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
        }
        //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

        send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
        //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

        send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
        //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
    };


    /* ===========================================================================
   * Check if the data type is TEXT or BINARY, using the following algorithm:
   * - TEXT if the two conditions below are satisfied:
   *    a) There are no non-portable control characters belonging to the
   *       "block list" (0..6, 14..25, 28..31).
   *    b) There is at least one printable character belonging to the
   *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
   * - BINARY otherwise.
   * - The following partially-portable control characters form a
   *   "gray list" that is ignored in this detection algorithm:
   *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
   * IN assertion: the fields Freq of dyn_ltree are set.
   */
    const detect_data_type = (s) => {
        /* block_mask is the bit mask of block-listed bytes
     * set bits 0..6, 14..25, and 28..31
     * 0xf3ffc07f = binary 11110011111111111100000001111111
     */
        let block_mask = 0xf3ffc07f;
        let n;

        /* Check for non-textual ("block-listed") bytes. */
        for (n = 0; n <= 31; n++, block_mask >>>= 1) {
            if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
                return Z_BINARY;
            }
        }

        /* Check for textual ("allow-listed") bytes. */
        if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
            s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
            return Z_TEXT;
        }
        for (n = 32; n < LITERALS$1; n++) {
            if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
                return Z_TEXT;
            }
        }

        /* There are no "block-listed" or "allow-listed" bytes:
     * this stream either is empty or has tolerated ("gray-listed") bytes only.
     */
        return Z_BINARY;
    };


    let static_init_done = false;

    /* ===========================================================================
   * Initialize the tree data structures for a new zlib stream.
   */
    const _tr_init$1 = (s) => {

        if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
        }

        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

        s.bi_buf = 0;
        s.bi_valid = 0;

        /* Initialize the first block of the first file: */
        init_block(s);
    };


    /* ===========================================================================
   * Send a stored block
   */
    const _tr_stored_block$1 = (s, buf, stored_len, last) => {
        //DeflateState *s;
        //charf *buf;       /* input block */
        //ulg stored_len;   /* length of input block */
        //int last;         /* one if this is the last block for a file */

        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
        bi_windup(s);        /* align on byte boundary */
        put_short(s, stored_len);
        put_short(s, ~stored_len);
        if (stored_len) {
            s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
        }
        s.pending += stored_len;
    };


    /* ===========================================================================
   * Send one empty static block to give enough lookahead for inflate.
   * This takes 10 bits, of which 7 may remain in the bit buffer.
   */
    const _tr_align$1 = (s) => {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
    };


    /* ===========================================================================
   * Determine the best encoding for the current block: dynamic trees, static
   * trees or store, and write out the encoded block.
   */
    const _tr_flush_block$1 = (s, buf, stored_len, last) => {
        //DeflateState *s;
        //charf *buf;       /* input block, or NULL if too old */
        //ulg stored_len;   /* length of input block */
        //int last;         /* one if this is the last block for a file */

        let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
        let max_blindex = 0;        /* index of last bit length code of non zero freq */

        /* Build the Huffman trees unless a stored block is forced */
        if (s.level > 0) {

            /* Check if the file is binary or text */
            if (s.strm.data_type === Z_UNKNOWN$1) {
                s.strm.data_type = detect_data_type(s);
            }

            /* Construct the literal and distance trees */
            build_tree(s, s.l_desc);
            // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
            //        s->static_len));

            build_tree(s, s.d_desc);
            // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
            //        s->static_len));
            /* At this point, opt_len and static_len are the total bit lengths of
       * the compressed block data, excluding the tree representations.
       */

            /* Build the bit length tree for the above two trees, and get the index
       * in bl_order of the last bit length code to send.
       */
            max_blindex = build_bl_tree(s);

            /* Determine the best encoding. Compute the block lengths in bytes. */
            opt_lenb = (s.opt_len + 3 + 7) >>> 3;
            static_lenb = (s.static_len + 3 + 7) >>> 3;

            // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
            //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
            //        s->sym_next / 3));

            if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

        } else {
            // Assert(buf != (char*)0, "lost buf");
            opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
        }

        if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
            /* 4: two words for the lengths */

            /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
       * Otherwise we can't have processed more than WSIZE input bytes since
       * the last block flush, because compression would have been
       * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
       * transform a block into a stored block.
       */
            _tr_stored_block$1(s, buf, stored_len, last);

        } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);

        } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
        /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
        init_block(s);

        if (last) {
            bi_windup(s);
        }
        // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
        //       s->compressed_len-7*last));
    };

    /* ===========================================================================
   * Save the match info and tally the frequency counts. Return true if
   * the current block must be flushed.
   */
    const _tr_tally$1 = (s, dist, lc) => {
        //    deflate_state *s;
        //    unsigned dist;  /* distance of matched string */
        //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

        s.pending_buf[s.sym_buf + s.sym_next++] = dist;
        s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
        s.pending_buf[s.sym_buf + s.sym_next++] = lc;
        if (dist === 0) {
            /* lc is the unmatched char */
            s.dyn_ltree[lc * 2]/*.Freq*/++;
        } else {
            s.matches++;
            /* Here, lc is the match length - MIN_MATCH */
            dist--;             /* dist = match distance - 1 */
            //Assert((ush)dist < (ush)MAX_DIST(s) &&
            //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
            //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

            s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
            s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
        }

        return (s.sym_next === s.sym_end);
    };

    var _tr_init_1 = _tr_init$1;
    var _tr_stored_block_1 = _tr_stored_block$1;
    var _tr_flush_block_1 = _tr_flush_block$1;
    var _tr_tally_1 = _tr_tally$1;
    var _tr_align_1 = _tr_align$1;

    var trees = {
        _tr_init: _tr_init_1,
        _tr_stored_block: _tr_stored_block_1,
        _tr_flush_block: _tr_flush_block_1,
        _tr_tally: _tr_tally_1,
        _tr_align: _tr_align_1
    };

    // Note: adler32 takes 12% for level 0 and 2% for level 6.
    // It isn't worth it to make additional optimizations as in original.
    // Small size is preferable.

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    const adler32 = (adler, buf, len, pos) => {
        let s1 = (adler & 0xffff) | 0,
            s2 = ((adler >>> 16) & 0xffff) | 0,
            n = 0;

        while (len !== 0) {
            // Set limit ~ twice less than 5552, to keep
            // s2 in 31-bits, because we force signed ints.
            // in other case %= will fail.
            n = len > 2000 ? 2000 : len;
            len -= n;

            do {
                s1 = (s1 + buf[pos++]) | 0;
                s2 = (s2 + s1) | 0;
            } while (--n);

            s1 %= 65521;
            s2 %= 65521;
        }

        return (s1 | (s2 << 16)) | 0;
    };


    var adler32_1 = adler32;

    // Note: we can't get significant speed boost here.
    // So write code to minimize size - no pregenerated tables
    // and array tools dependencies.

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    // Use ordinary array, since untyped makes no boost here
    const makeTable = () => {
        let c, table = [];

        for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
                c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
            }
            table[n] = c;
        }

        return table;
    };

    // Create table on load. Just 255 signed longs. Not a problem.
    const crcTable = new Uint32Array(makeTable());


    const crc32 = (crc, buf, len, pos) => {
        const t = crcTable;
        const end = pos + len;

        crc ^= -1;

        for (let i = pos; i < end; i++) {
            crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
        }

        return (crc ^ (-1)); // >>> 0;
    };


    var crc32_1 = crc32;

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    var messages = {
        2: 'need dictionary',     /* Z_NEED_DICT       2  */
        1: 'stream end',          /* Z_STREAM_END      1  */
        0: '',                    /* Z_OK              0  */
        '-1': 'file error',          /* Z_ERRNO         (-1) */
        '-2': 'stream error',        /* Z_STREAM_ERROR  (-2) */
        '-3': 'data error',          /* Z_DATA_ERROR    (-3) */
        '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
        '-5': 'buffer error',        /* Z_BUF_ERROR     (-5) */
        '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    var constants$2 = {

        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,

        /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,

        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,


        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,

        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,

        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    const {
        Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
        Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
        Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
        Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
        Z_UNKNOWN,
        Z_DEFLATED: Z_DEFLATED$2
    } = constants$2;

    /*============================================================================*/


    const MAX_MEM_LEVEL = 9;
    /* Maximum value for memLevel in deflateInit2 */
    const MAX_WBITS$1 = 15;
    /* 32K LZ77 window */
    const DEF_MEM_LEVEL = 8;


    const LENGTH_CODES = 29;
    /* number of length codes, not counting the special END_BLOCK code */
    const LITERALS = 256;
    /* number of literal bytes 0..255 */
    const L_CODES = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */
    const D_CODES = 30;
    /* number of distance codes */
    const BL_CODES = 19;
    /* number of codes used to transfer the bit lengths */
    const HEAP_SIZE = 2 * L_CODES + 1;
    /* maximum heap size */
    const MAX_BITS = 15;
    /* All codes must not exceed MAX_BITS bits */

    const MIN_MATCH = 3;
    const MAX_MATCH = 258;
    const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

    const PRESET_DICT = 0x20;

    const INIT_STATE = 42;    /* zlib header -> BUSY_STATE */
    //#ifdef GZIP
    const GZIP_STATE = 57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
    //#endif
    const EXTRA_STATE = 69;    /* gzip extra block -> NAME_STATE */
    const NAME_STATE = 73;    /* gzip file name -> COMMENT_STATE */
    const COMMENT_STATE = 91;    /* gzip comment -> HCRC_STATE */
    const HCRC_STATE = 103;    /* gzip header CRC -> BUSY_STATE */
    const BUSY_STATE = 113;    /* deflate -> FINISH_STATE */
    const FINISH_STATE = 666;    /* stream complete */

    const BS_NEED_MORE = 1; /* block not completed, need more input or more output */
    const BS_BLOCK_DONE = 2; /* block flush performed */
    const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
    const BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

    const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

    const err = (strm, errorCode) => {
        strm.msg = messages[errorCode];
        return errorCode;
    };

    const rank = (f) => {
        return ((f) * 2) - ((f) > 4 ? 9 : 0);
    };

    const zero = (buf) => {
        let len = buf.length; while (--len >= 0) { buf[len] = 0; }
    };

    /* ===========================================================================
   * Slide the hash table when sliding the window down (could be avoided with 32
   * bit values at the expense of memory usage). We slide even when level == 0 to
   * keep the hash table consistent if we switch back to level > 0 later.
   */
    const slide_hash = (s) => {
        let n, m;
        let p;
        let wsize = s.w_size;

        n = s.hash_size;
        p = n;
        do {
            m = s.head[--p];
            s.head[p] = (m >= wsize ? m - wsize : 0);
        } while (--n);
        n = wsize;
        //#ifndef FASTEST
        p = n;
        do {
            m = s.prev[--p];
            s.prev[p] = (m >= wsize ? m - wsize : 0);
            /* If n is not on any hash chain, prev[n] is garbage but
       * its value will never be used.
       */
        } while (--n);
        //#endif
    };

    /* eslint-disable new-cap */
    let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
    // This hash causes less collisions, https://github.com/nodeca/pako/issues/135
    // But breaks binary compatibility
    //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
    let HASH = HASH_ZLIB;


    /* =========================================================================
   * Flush as much pending output as possible. All deflate() output, except for
   * some deflate_stored() output, goes through this function so some
   * applications may wish to modify it to avoid allocating a large
   * strm->next_out buffer and copying into it. (See also read_buf()).
   */
    const flush_pending = (strm) => {
        const s = strm.state;

        //_tr_flush_bits(s);
        let len = s.pending;
        if (len > strm.avail_out) {
            len = strm.avail_out;
        }
        if (len === 0) { return; }

        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
            s.pending_out = 0;
        }
    };


    const flush_block_only = (s, last) => {
        _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
    };


    const put_byte = (s, b) => {
        s.pending_buf[s.pending++] = b;
    };


    /* =========================================================================
   * Put a short in the pending buffer. The 16-bit value is put in MSB order.
   * IN assertion: the stream state is correct and there is enough room in
   * pending_buf.
   */
    const putShortMSB = (s, b) => {

        //  put_byte(s, (Byte)(b >> 8));
        //  put_byte(s, (Byte)(b & 0xff));
        s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
        s.pending_buf[s.pending++] = b & 0xff;
    };


    /* ===========================================================================
   * Read a new buffer from the current input stream, update the adler32
   * and total number of bytes read.  All deflate() input goes through
   * this function so some applications may wish to modify it to avoid
   * allocating a large strm->input buffer and copying from it.
   * (See also flush_pending()).
   */
    const read_buf = (strm, buf, start, size) => {

        let len = strm.avail_in;

        if (len > size) { len = size; }
        if (len === 0) { return 0; }

        strm.avail_in -= len;

        // zmemcpy(buf, strm->next_in, len);
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
        if (strm.state.wrap === 1) {
            strm.adler = adler32_1(strm.adler, buf, len, start);
        }

        else if (strm.state.wrap === 2) {
            strm.adler = crc32_1(strm.adler, buf, len, start);
        }

        strm.next_in += len;
        strm.total_in += len;

        return len;
    };


    /* ===========================================================================
   * Set match_start to the longest match starting at the given string and
   * return its length. Matches shorter or equal to prev_length are discarded,
   * in which case the result is equal to prev_length and match_start is
   * garbage.
   * IN assertions: cur_match is the head of the hash chain for the current
   *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
   * OUT assertion: the match length is not greater than s->lookahead.
   */
    const longest_match = (s, cur_match) => {

        let chain_length = s.max_chain_length;      /* max hash chain length */
        let scan = s.strstart; /* current string */
        let match;                       /* matched string */
        let len;                           /* length of current match */
        let best_len = s.prev_length;              /* best match length so far */
        let nice_match = s.nice_match;             /* stop if match long enough */
        const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
            s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

        const _win = s.window; // shortcut

        const wmask = s.w_mask;
        const prev = s.prev;

        /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */

        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];

        /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
        // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

        /* Do not waste too much time if we already have a good match: */
        if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
        }
        /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
        if (nice_match > s.lookahead) { nice_match = s.lookahead; }

        // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

        do {
            // Assert(cur_match < s->strstart, "no future");
            match = cur_match;

            /* Skip to next match if the match length cannot increase
       * or if the match length is less than 2.  Note that the checks below
       * for insufficient lookahead only occur occasionally for performance
       * reasons.  Therefore uninitialized memory will be accessed, and
       * conditional jumps will be made that depend on those values.
       * However the length of the match is limited to the lookahead, so
       * the output of deflate is not affected by the uninitialized values.
       */

            if (_win[match + best_len] !== scan_end ||
                _win[match + best_len - 1] !== scan_end1 ||
                _win[match] !== _win[scan] ||
                _win[++match] !== _win[scan + 1]) {
                continue;
            }

            /* The check at best_len-1 can be removed because it will be made
       * again later. (This heuristic is not always a win.)
       * It is not necessary to compare scan[2] and match[2] since they
       * are always equal when the other bytes match, given that
       * the hash keys are equal and that HASH_BITS >= 8.
       */
            scan += 2;
            match++;
            // Assert(*scan == *match, "match[2]?");

            /* We check for insufficient lookahead only every 8th comparison;
       * the 256th check will be made at strstart+258.
       */
            do {
                /*jshint noempty:false*/
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                scan < strend);

            // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;

            if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                    break;
                }
                scan_end1 = _win[scan + best_len - 1];
                scan_end = _win[scan + best_len];
            }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

        if (best_len <= s.lookahead) {
            return best_len;
        }
        return s.lookahead;
    };


    /* ===========================================================================
   * Fill the window when the lookahead becomes insufficient.
   * Updates strstart and lookahead.
   *
   * IN assertion: lookahead < MIN_LOOKAHEAD
   * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
   *    At least one byte has been read, or avail_in == 0; reads are
   *    performed for at least two bytes (required for the zip translate_eol
   *    option -- not supported here).
   */
    const fill_window = (s) => {

        const _w_size = s.w_size;
        let n, more, str;

        //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

        do {
            more = s.window_size - s.lookahead - s.strstart;

            // JS ints have 32 bit, block below not needed
            /* Deal with !@#$% 64K limit: */
            //if (sizeof(int) <= 2) {
            //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
            //        more = wsize;
            //
            //  } else if (more == (unsigned)(-1)) {
            //        /* Very unlikely, but possible on 16 bit machine if
            //         * strstart == 0 && lookahead == 1 (input done a byte at time)
            //         */
            //        more--;
            //    }
            //}


            /* If the window is almost full and there is insufficient lookahead,
       * move the upper half to the lower one to make room in the upper half.
       */
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

                s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                /* we now have strstart >= MAX_DIST */
                s.block_start -= _w_size;
                if (s.insert > s.strstart) {
                    s.insert = s.strstart;
                }
                slide_hash(s);
                more += _w_size;
            }
            if (s.strm.avail_in === 0) {
                break;
            }

            /* If there was no sliding:
       *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
       *    more == window_size - lookahead - strstart
       * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
       * => more >= window_size - 2*WSIZE + 2
       * In the BIG_MEM or MMAP case (not yet supported),
       *   window_size == input_size + MIN_LOOKAHEAD  &&
       *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
       * Otherwise, window_size == 2*WSIZE so more >= 2.
       * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
       */
            //Assert(more >= 2, "more < 2");
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;

            /* Initialize the hash value now that we have some input: */
            if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];

                /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
                s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
                //#if MIN_MATCH != 3
                //        Call update_hash() MIN_MATCH-3 more times
                //#endif
                while (s.insert) {
                    /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                    s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                    s.insert--;
                    if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                    }
                }
            }
            /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
       * but this is not important since only literal bytes will be emitted.
       */

        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

        /* If the WIN_INIT bytes after the end of the current data have never been
     * written, then zero those bytes in order to avoid memory check reports of
     * the use of uninitialized (or uninitialised as Julian writes) bytes by
     * the longest match routines.  Update the high water mark for the next
     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
     */
        //  if (s.high_water < s.window_size) {
        //    const curr = s.strstart + s.lookahead;
        //    let init = 0;
        //
        //    if (s.high_water < curr) {
        //      /* Previous high water mark below current data -- zero WIN_INIT
        //       * bytes or up to end of window, whichever is less.
        //       */
        //      init = s.window_size - curr;
        //      if (init > WIN_INIT)
        //        init = WIN_INIT;
        //      zmemzero(s->window + curr, (unsigned)init);
        //      s->high_water = curr + init;
        //    }
        //    else if (s->high_water < (ulg)curr + WIN_INIT) {
        //      /* High water mark at or above current data, but below current data
        //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
        //       * to end of window, whichever is less.
        //       */
        //      init = (ulg)curr + WIN_INIT - s->high_water;
        //      if (init > s->window_size - s->high_water)
        //        init = s->window_size - s->high_water;
        //      zmemzero(s->window + s->high_water, (unsigned)init);
        //      s->high_water += init;
        //    }
        //  }
        //
        //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
        //    "not enough room for search");
    };

    /* ===========================================================================
   * Copy without compression as much as possible from the input stream, return
   * the current block state.
   *
   * In case deflateParams() is used to later switch to a non-zero compression
   * level, s->matches (otherwise unused when storing) keeps track of the number
   * of hash table slides to perform. If s->matches is 1, then one hash table
   * slide will be done when switching. If s->matches is 2, the maximum value
   * allowed here, then the hash table will be cleared, since two or more slides
   * is the same as a clear.
   *
   * deflate_stored() is written to minimize the number of times an input byte is
   * copied. It is most efficient with large input and output buffers, which
   * maximizes the opportunites to have a single copy from next_in to next_out.
   */
    const deflate_stored = (s, flush) => {

        /* Smallest worthy block size when not flushing or finishing. By default
     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
     * large input and output buffers, the stored block size will be larger.
     */
        let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

        /* Copy as many min_block or larger stored blocks directly to next_out as
     * possible. If flushing, copy the remaining available input to next_out as
     * stored blocks, if there is enough space.
     */
        let len, left, have, last = 0;
        let used = s.strm.avail_in;
        do {
            /* Set len to the maximum size block that we can copy directly with the
       * available input data and output space. Set left to how much of that
       * would be copied from what's left in the window.
       */
            len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
            have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
            if (s.strm.avail_out < have) {         /* need room for header */
                break;
            }
            /* maximum stored block length that will fit in avail_out: */
            have = s.strm.avail_out - have;
            left = s.strstart - s.block_start;  /* bytes left in window */
            if (len > left + s.strm.avail_in) {
                len = left + s.strm.avail_in;   /* limit len to the input */
            }
            if (len > have) {
                len = have;             /* limit len to the output */
            }

            /* If the stored block would be less than min_block in length, or if
       * unable to copy all of the available input when flushing, then try
       * copying to the window and the pending buffer instead. Also don't
       * write an empty block when flushing -- deflate() does that.
       */
            if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||
                flush === Z_NO_FLUSH$2 ||
                len !== left + s.strm.avail_in)) {
                break;
            }

            /* Make a dummy stored block in pending to get the header bytes,
       * including any pending bits. This also updates the debugging counts.
       */
            last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
            _tr_stored_block(s, 0, 0, last);

            /* Replace the lengths in the dummy stored block with len. */
            s.pending_buf[s.pending - 4] = len;
            s.pending_buf[s.pending - 3] = len >> 8;
            s.pending_buf[s.pending - 2] = ~len;
            s.pending_buf[s.pending - 1] = ~len >> 8;

            /* Write the stored block header bytes. */
            flush_pending(s.strm);

            //#ifdef ZLIB_DEBUG
            //    /* Update debugging counts for the data about to be copied. */
            //    s->compressed_len += len << 3;
            //    s->bits_sent += len << 3;
            //#endif

            /* Copy uncompressed bytes from the window to next_out. */
            if (left) {
                if (left > len) {
                    left = len;
                }
                //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
                s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
                s.strm.next_out += left;
                s.strm.avail_out -= left;
                s.strm.total_out += left;
                s.block_start += left;
                len -= left;
            }

            /* Copy uncompressed bytes directly from next_in to next_out, updating
       * the check value.
       */
            if (len) {
                read_buf(s.strm, s.strm.output, s.strm.next_out, len);
                s.strm.next_out += len;
                s.strm.avail_out -= len;
                s.strm.total_out += len;
            }
        } while (last === 0);

        /* Update the sliding window with the last s->w_size bytes of the copied
     * data, or append all of the copied data to the existing window if less
     * than s->w_size bytes were copied. Also update the number of bytes to
     * insert in the hash tables, in the event that deflateParams() switches to
     * a non-zero compression level.
     */
        used -= s.strm.avail_in;    /* number of input bytes directly copied */
        if (used) {
            /* If any input was used, then no unused input remains in the window,
       * therefore s->block_start == s->strstart.
       */
            if (used >= s.w_size) {  /* supplant the previous history */
                s.matches = 2;     /* clear hash */
                //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
                s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
                s.strstart = s.w_size;
                s.insert = s.strstart;
            }
            else {
                if (s.window_size - s.strstart <= used) {
                    /* Slide the window down. */
                    s.strstart -= s.w_size;
                    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
                    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
                    if (s.matches < 2) {
                        s.matches++;   /* add a pending slide_hash() */
                    }
                    if (s.insert > s.strstart) {
                        s.insert = s.strstart;
                    }
                }
                //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
                s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
                s.strstart += used;
                s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
            }
            s.block_start = s.strstart;
        }
        if (s.high_water < s.strstart) {
            s.high_water = s.strstart;
        }

        /* If the last block was written to next_out, then done. */
        if (last) {
            return BS_FINISH_DONE;
        }

        /* If flushing and all input has been consumed, then done. */
        if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&
            s.strm.avail_in === 0 && s.strstart === s.block_start) {
            return BS_BLOCK_DONE;
        }

        /* Fill the window with any remaining input. */
        have = s.window_size - s.strstart;
        if (s.strm.avail_in > have && s.block_start >= s.w_size) {
            /* Slide the window down. */
            s.block_start -= s.w_size;
            s.strstart -= s.w_size;
            //zmemcpy(s->window, s->window + s->w_size, s->strstart);
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
                s.matches++;       /* add a pending slide_hash() */
            }
            have += s.w_size;      /* more space now */
            if (s.insert > s.strstart) {
                s.insert = s.strstart;
            }
        }
        if (have > s.strm.avail_in) {
            have = s.strm.avail_in;
        }
        if (have) {
            read_buf(s.strm, s.window, s.strstart, have);
            s.strstart += have;
            s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
        }
        if (s.high_water < s.strstart) {
            s.high_water = s.strstart;
        }

        /* There was not enough avail_out to write a complete worthy or flushed
     * stored block to next_out. Write a stored block to pending instead, if we
     * have enough input for a worthy block, or if flushing and there is enough
     * room for the remaining input as a stored block in the pending buffer.
     */
        have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
        /* maximum stored block length that will fit in pending: */
        have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
        min_block = have > s.w_size ? s.w_size : have;
        left = s.strstart - s.block_start;
        if (left >= min_block ||
            ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&
                s.strm.avail_in === 0 && left <= have)) {
            len = left > have ? have : left;
            last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&
                len === left ? 1 : 0;
            _tr_stored_block(s, s.block_start, len, last);
            s.block_start += len;
            flush_pending(s.strm);
        }

        /* We've done all we can with the available input and output. */
        return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };


    /* ===========================================================================
   * Compress as much as possible from the input stream, return the current
   * block state.
   * This function does not perform lazy evaluation of matches and inserts
   * new strings in the dictionary only for unmatched strings or for short
   * matches. It is used only for the fast compression options.
   */
    const deflate_fast = (s, flush) => {

        let hash_head;        /* head of the hash chain */
        let bflush;           /* set if current block must be flushed */

        for (; ;) {
            /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the next match, plus MIN_MATCH bytes to insert the
       * string following the next match.
       */
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break; /* flush the current block */
                }
            }

            /* Insert the string window[strstart .. strstart+2] in the
       * dictionary, and set hash_head to the head of the hash chain:
       */
            hash_head = 0/*NIL*/;
            if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
            }

            /* Find the longest match, discarding those <= prev_length.
       * At this point we have always match_length < MIN_MATCH
       */
            if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
                /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
                s.match_length = longest_match(s, hash_head);
                /* longest_match() sets match_start */
            }
            if (s.match_length >= MIN_MATCH) {
                // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

                /*** _tr_tally_dist(s, s.strstart - s.match_start,
                 s.match_length - MIN_MATCH, bflush); ***/
                bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

                s.lookahead -= s.match_length;

                /* Insert new strings in the hash table only if the match length
         * is not too large. This saves time but degrades compression.
         */
                if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
                    s.match_length--; /* string at strstart already in table */
                    do {
                        s.strstart++;
                        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                        /***/
                        /* strstart never exceeds WSIZE-MAX_MATCH, so there are
             * always MIN_MATCH bytes ahead.
             */
                    } while (--s.match_length !== 0);
                    s.strstart++;
                } else {
                    s.strstart += s.match_length;
                    s.match_length = 0;
                    s.ins_h = s.window[s.strstart];
                    /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

                    //#if MIN_MATCH != 3
                    //                Call UPDATE_HASH() MIN_MATCH-3 more times
                    //#endif
                    /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
           * matter since it will be recomputed at next deflate call.
           */
                }
            } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s.window[s.strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = _tr_tally(s, 0, s.window[s.strstart]);

                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
        if (flush === Z_FINISH$3) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    };

    /* ===========================================================================
   * Same as above, but achieves better compression. We use a lazy
   * evaluation for matches: a match is finally adopted only if there is
   * no better match at the next window position.
   */
    const deflate_slow = (s, flush) => {

        let hash_head;          /* head of hash chain */
        let bflush;              /* set if current block must be flushed */

        let max_insert;

        /* Process the input block. */
        for (; ;) {
            /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the next match, plus MIN_MATCH bytes to insert the
       * string following the next match.
       */
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) { break; } /* flush the current block */
            }

            /* Insert the string window[strstart .. strstart+2] in the
       * dictionary, and set hash_head to the head of the hash chain:
       */
            hash_head = 0/*NIL*/;
            if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
            }

            /* Find the longest match, discarding those <= prev_length.
       */
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;

            if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
                s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
                /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
                s.match_length = longest_match(s, hash_head);
                /* longest_match() sets match_start */

                if (s.match_length <= 5 &&
                    (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

                    /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
                    s.match_length = MIN_MATCH - 1;
                }
            }
            /* If there was a match at the previous step and the current
       * match is not better, output the previous match:
       */
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                /* Do not insert strings in hash table beyond this. */

                //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

                /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                 s.prev_length - MIN_MATCH, bflush);***/
                bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                /* Insert in hash table all strings up to the end of the match.
         * strstart-1 and strstart are already inserted. If there is not
         * enough lookahead, the last two strings are not inserted in
         * the hash table.
         */
                s.lookahead -= s.prev_length - 1;
                s.prev_length -= 2;
                do {
                    if (++s.strstart <= max_insert) {
                        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                        /***/
                    }
                } while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH - 1;
                s.strstart++;

                if (bflush) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }

            } else if (s.match_available) {
                /* If there was no match at the previous position, output a
         * single literal. If there was a match but the current match
         * is longer, truncate the previous match to a single literal.
         */
                //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

                if (bflush) {
                    /*** FLUSH_BLOCK_ONLY(s, 0) ***/
                    flush_block_only(s, false);
                    /***/
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            } else {
                /* There is no previous match to compare with, wait for
         * the next step to decide.
         */
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
            }
        }
        //Assert (flush != Z_NO_FLUSH, "no flush?");
        if (s.match_available) {
            //Tracevv((stderr,"%c", s->window[s->strstart-1]));
            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

            s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }

        return BS_BLOCK_DONE;
    };


    /* ===========================================================================
   * For Z_RLE, simply look for runs of bytes, generate matches only of distance
   * one.  Do not maintain a hash table.  (It will be regenerated if this run of
   * deflate switches away from Z_RLE.)
   */
    const deflate_rle = (s, flush) => {

        let bflush;            /* set if current block must be flushed */
        let prev;              /* byte at distance one to match */
        let scan, strend;      /* scan goes up to strend for length of run */

        const _win = s.window;

        for (; ;) {
            /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the longest run, plus one for the unrolled loop.
       */
            if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) { break; } /* flush the current block */
            }

            /* See how many times the previous byte repeats */
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                    strend = s.strstart + MAX_MATCH;
                    do {
                        /*jshint noempty:false*/
                    } while (prev === _win[++scan] && prev === _win[++scan] &&
                    prev === _win[++scan] && prev === _win[++scan] &&
                    prev === _win[++scan] && prev === _win[++scan] &&
                    prev === _win[++scan] && prev === _win[++scan] &&
                        scan < strend);
                    s.match_length = MAX_MATCH - (strend - scan);
                    if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                    }
                }
                //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
            }

            /* Emit match if have run of MIN_MATCH or longer, else emit literal */
            if (s.match_length >= MIN_MATCH) {
                //check_match(s, s.strstart, s.strstart - 1, s.match_length);

                /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
                bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
            } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s->window[s->strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = _tr_tally(s, 0, s.window[s.strstart]);

                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    };

    /* ===========================================================================
   * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
   * (It will be regenerated if this run of deflate switches away from Huffman.)
   */
    const deflate_huff = (s, flush) => {

        let bflush;             /* set if current block must be flushed */

        for (; ;) {
            /* Make sure that we have a literal to write. */
            if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                    if (flush === Z_NO_FLUSH$2) {
                        return BS_NEED_MORE;
                    }
                    break;      /* flush the current block */
                }
            }

            /* Output a literal byte */
            s.match_length = 0;
            //Tracevv((stderr,"%c", s->window[s->strstart]));
            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    };

    /* Values for max_lazy_match, good_match and max_chain_length, depending on
   * the desired pack level (0..9). The values given below have been tuned to
   * exclude worst case performance for pathological files. Better values may be
   * found for specific files.
   */
    function Config(good_length, max_lazy, nice_length, max_chain, func) {

        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
    }

    const configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

        new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
    ];


    /* ===========================================================================
   * Initialize the "longest match" routines for a new zlib stream
   */
    const lm_init = (s) => {

        s.window_size = 2 * s.w_size;

        /*** CLEAR_HASH(s); ***/
        zero(s.head); // Fill with NIL (= 0);

        /* Set the default configuration parameters:
     */
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;

        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
    };


    function DeflateState() {
        this.strm = null;            /* pointer back to this zlib stream */
        this.status = 0;            /* as the name implies */
        this.pending_buf = null;      /* output still pending */
        this.pending_buf_size = 0;  /* size of pending_buf */
        this.pending_out = 0;       /* next pending byte to output to the stream */
        this.pending = 0;           /* nb of bytes in the pending buffer */
        this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
        this.gzhead = null;         /* gzip header information to write */
        this.gzindex = 0;           /* where in extra, name, or comment */
        this.method = Z_DEFLATED$2; /* can only be DEFLATED */
        this.last_flush = -1;   /* value of flush param for previous deflate call */

        this.w_size = 0;  /* LZ77 window size (32K by default) */
        this.w_bits = 0;  /* log2(w_size)  (8..16) */
        this.w_mask = 0;  /* w_size - 1 */

        this.window = null;
        /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size.
     */

        this.window_size = 0;
        /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

        this.prev = null;
        /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

        this.head = null;   /* Heads of the hash chains or NIL. */

        this.ins_h = 0;       /* hash index of string to be inserted */
        this.hash_size = 0;   /* number of elements in hash table */
        this.hash_bits = 0;   /* log2(hash_size) */
        this.hash_mask = 0;   /* hash_size-1 */

        this.hash_shift = 0;
        /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

        this.block_start = 0;
        /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

        this.match_length = 0;      /* length of best match */
        this.prev_match = 0;        /* previous match */
        this.match_available = 0;   /* set if previous match exists */
        this.strstart = 0;          /* start of string to insert */
        this.match_start = 0;       /* start of matching string */
        this.lookahead = 0;         /* number of valid bytes ahead in window */

        this.prev_length = 0;
        /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

        this.max_chain_length = 0;
        /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

        this.max_lazy_match = 0;
        /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
        // That's alias to max_lazy_match, don't use directly
        //this.max_insert_length = 0;
        /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

        this.level = 0;     /* compression level (1..9) */
        this.strategy = 0;  /* favor or force Huffman coding*/

        this.good_match = 0;
        /* Use a faster search when the previous match is longer than this */

        this.nice_match = 0; /* Stop searching when current match exceeds this */

        /* used by trees.c: */

        /* Didn't use ct_data typedef below to suppress compiler warning */

        // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
        // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
        // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

        // Use flat array of DOUBLE size, with interleaved fata,
        // because JS does not support effective
        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);

        this.l_desc = null;         /* desc. for literal tree */
        this.d_desc = null;         /* desc. for distance tree */
        this.bl_desc = null;         /* desc. for bit length tree */

        //ush bl_count[MAX_BITS+1];
        this.bl_count = new Uint16Array(MAX_BITS + 1);
        /* number of codes at each bit length for an optimal tree */

        //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
        this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
        zero(this.heap);

        this.heap_len = 0;               /* number of elements in the heap */
        this.heap_max = 0;               /* element of largest frequency */
        /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

        this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
        zero(this.depth);
        /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

        this.sym_buf = 0;        /* buffer for distances and literals/lengths */

        this.lit_bufsize = 0;
        /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

        this.sym_next = 0;      /* running index in sym_buf */
        this.sym_end = 0;       /* symbol table full when sym_next reaches this */

        this.opt_len = 0;       /* bit length of current block with optimal trees */
        this.static_len = 0;    /* bit length of current block with static trees */
        this.matches = 0;       /* number of string matches in current block */
        this.insert = 0;        /* bytes at end of window left to insert */


        this.bi_buf = 0;
        /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
        this.bi_valid = 0;
        /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

        // Used for window memory init. We safely ignore it for JS. That makes
        // sense only for pointers and memory check tools.
        //this.high_water = 0;
        /* High water mark offset in window for initialized bytes -- bytes above
     * this are set to zero in order to avoid memory check warnings when
     * longest match routines access bytes past the input.  This is then
     * updated to the new high water mark.
     */
    }


    /* =========================================================================
   * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
   */
    const deflateStateCheck = (strm) => {

        if (!strm) {
            return 1;
        }
        const s = strm.state;
        if (!s || s.strm !== strm || (s.status !== INIT_STATE &&
            //#ifdef GZIP
            s.status !== GZIP_STATE &&
            //#endif
            s.status !== EXTRA_STATE &&
            s.status !== NAME_STATE &&
            s.status !== COMMENT_STATE &&
            s.status !== HCRC_STATE &&
            s.status !== BUSY_STATE &&
            s.status !== FINISH_STATE)) {
            return 1;
        }
        return 0;
    };


    const deflateResetKeep = (strm) => {

        if (deflateStateCheck(strm)) {
            return err(strm, Z_STREAM_ERROR$2);
        }

        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;

        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;

        if (s.wrap < 0) {
            s.wrap = -s.wrap;
            /* was made negative by deflate(..., Z_FINISH); */
        }
        s.status =
            //#ifdef GZIP
            s.wrap === 2 ? GZIP_STATE :
                //#endif
                s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = (s.wrap === 2) ?
            0  // crc32(0, Z_NULL, 0)
            :
            1; // adler32(0, Z_NULL, 0)
        s.last_flush = -2;
        _tr_init(s);
        return Z_OK$3;
    };


    const deflateReset = (strm) => {

        const ret = deflateResetKeep(strm);
        if (ret === Z_OK$3) {
            lm_init(strm.state);
        }
        return ret;
    };


    const deflateSetHeader = (strm, head) => {

        if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
            return Z_STREAM_ERROR$2;
        }
        strm.state.gzhead = head;
        return Z_OK$3;
    };


    const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

        if (!strm) { // === Z_NULL
            return Z_STREAM_ERROR$2;
        }
        let wrap = 1;

        if (level === Z_DEFAULT_COMPRESSION$1) {
            level = 6;
        }

        if (windowBits < 0) { /* suppress zlib wrapper */
            wrap = 0;
            windowBits = -windowBits;
        }

        else if (windowBits > 15) {
            wrap = 2;           /* write gzip wrapper instead */
            windowBits -= 16;
        }


        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
            windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
            strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
            return err(strm, Z_STREAM_ERROR$2);
        }


        if (windowBits === 8) {
            windowBits = 9;
        }
        /* until 256-byte window bug fixed */

        const s = new DeflateState();

        strm.state = s;
        s.strm = strm;
        s.status = INIT_STATE;     /* to pass state test in deflateReset() */

        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;

        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);

        // Don't need mem init magic for JS.
        //s.high_water = 0;  /* nothing written to s->window yet */

        s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

        /* We overlay pending_buf and sym_buf. This works since the average size
     * for length/distance pairs over any compressed block is assured to be 31
     * bits or less.
     *
     * Analysis: The longest fixed codes are a length code of 8 bits plus 5
     * extra bits, for lengths 131 to 257. The longest fixed distance codes are
     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
     * possible fixed-codes length/distance pair is then 31 bits total.
     *
     * sym_buf starts one-fourth of the way into pending_buf. So there are
     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
     * in sym_buf is three bytes -- two for the distance and one for the
     * literal/length. As each symbol is consumed, the pointer to the next
     * sym_buf value to read moves forward three bytes. From that symbol, up to
     * 31 bits are written to pending_buf. The closest the written pending_buf
     * bits gets to the next sym_buf symbol to read is just before the last
     * code is written. At that time, 31*(n-2) bits have been written, just
     * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
     * symbols are written.) The closest the writing gets to what is unread is
     * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
     * can range from 128 to 32768.
     *
     * Therefore, at a minimum, there are 142 bits of space between what is
     * written and what is read in the overlain buffers, so the symbols cannot
     * be overwritten by the compressed data. That space is actually 139 bits,
     * due to the three-bit fixed-code block header.
     *
     * That covers the case where either Z_FIXED is specified, forcing fixed
     * codes, or when the use of fixed codes is chosen, because that choice
     * results in a smaller compressed block than dynamic codes. That latter
     * condition then assures that the above analysis also covers all dynamic
     * blocks. A dynamic-code block will only be chosen to be emitted if it has
     * fewer bits than a fixed-code block would for the same set of symbols.
     * Therefore its average symbol length is assured to be less than 31. So
     * the compressed data for a dynamic block also cannot overwrite the
     * symbols from which it is being constructed.
     */

        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);

        // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
        //s->sym_buf = s->pending_buf + s->lit_bufsize;
        s.sym_buf = s.lit_bufsize;

        //s->sym_end = (s->lit_bufsize - 1) * 3;
        s.sym_end = (s.lit_bufsize - 1) * 3;
        /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */

        s.level = level;
        s.strategy = strategy;
        s.method = method;

        return deflateReset(strm);
    };

    const deflateInit = (strm, level) => {

        return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    };


    /* ========================================================================= */
    const deflate$2 = (strm, flush) => {

        if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
        }

        const s = strm.state;

        if (!strm.output ||
            (strm.avail_in !== 0 && !strm.input) ||
            (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
            return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
        }

        const old_flush = s.last_flush;
        s.last_flush = flush;

        /* Flush as much pending output as possible */
        if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
                /* Since avail_out is 0, deflate will be called again with
         * more output space, but possibly with both pending and
         * avail_in equal to zero. There won't be anything to do,
         * but this is not an error situation so make sure we
         * return OK instead of BUF_ERROR at next call of deflate:
         */
                s.last_flush = -1;
                return Z_OK$3;
            }

            /* Make sure there is something to do and avoid duplicate consecutive
       * flushes. For repeated and useless calls with Z_FINISH, we keep
       * returning Z_STREAM_END instead of Z_BUF_ERROR.
       */
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
            flush !== Z_FINISH$3) {
            return err(strm, Z_BUF_ERROR$1);
        }

        /* User must not provide more input after the first FINISH: */
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR$1);
        }

        /* Write the header */
        if (s.status === INIT_STATE && s.wrap === 0) {
            s.status = BUSY_STATE;
        }
        if (s.status === INIT_STATE) {
            /* zlib header */
            let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
            let level_flags = -1;

            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
            } else if (s.level < 6) {
                level_flags = 1;
            } else if (s.level === 6) {
                level_flags = 2;
            } else {
                level_flags = 3;
            }
            header |= (level_flags << 6);
            if (s.strstart !== 0) { header |= PRESET_DICT; }
            header += 31 - (header % 31);

            putShortMSB(s, header);

            /* Save the adler32 of the preset dictionary: */
            if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 0xffff);
            }
            strm.adler = 1; // adler32(0L, Z_NULL, 0);
            s.status = BUSY_STATE;

            /* Compression must start with an empty pending buffer */
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
        //#ifdef GZIP
        if (s.status === GZIP_STATE) {
            /* gzip header */
            strm.adler = 0;  //crc32(0L, Z_NULL, 0);
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) { // s->gzhead == Z_NULL
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                        4 : 0));
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;

                /* Compression must start with an empty pending buffer */
                flush_pending(strm);
                if (s.pending !== 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
            }
            else {
                put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
                put_byte(s, s.gzhead.time & 0xff);
                put_byte(s, (s.gzhead.time >> 8) & 0xff);
                put_byte(s, (s.gzhead.time >> 16) & 0xff);
                put_byte(s, (s.gzhead.time >> 24) & 0xff);
                put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                        4 : 0));
                put_byte(s, s.gzhead.os & 0xff);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 0xff);
                    put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
                }
                if (s.gzhead.hcrc) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
            }
        }
        if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra/* != Z_NULL*/) {
                let beg = s.pending;   /* start of bytes to update crc */
                let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
                while (s.pending + left > s.pending_buf_size) {
                    let copy = s.pending_buf_size - s.pending;
                    // zmemcpy(s.pending_buf + s.pending,
                    //    s.gzhead.extra + s.gzindex, copy);
                    s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
                    s.pending = s.pending_buf_size;
                    //--- HCRC_UPDATE(beg) ---//
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    //---//
                    s.gzindex += copy;
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                    beg = 0;
                    left -= copy;
                }
                // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
                //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
                let gzhead_extra = new Uint8Array(s.gzhead.extra);
                // zmemcpy(s->pending_buf + s->pending,
                //     s->gzhead->extra + s->gzindex, left);
                s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
                s.pending += left;
                //--- HCRC_UPDATE(beg) ---//
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                //---//
                s.gzindex = 0;
            }
            s.status = NAME_STATE;
        }
        if (s.status === NAME_STATE) {
            if (s.gzhead.name/* != Z_NULL*/) {
                let beg = s.pending;   /* start of bytes to update crc */
                let val;
                do {
                    if (s.pending === s.pending_buf_size) {
                        //--- HCRC_UPDATE(beg) ---//
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        //---//
                        flush_pending(strm);
                        if (s.pending !== 0) {
                            s.last_flush = -1;
                            return Z_OK$3;
                        }
                        beg = 0;
                    }
                    // JS specific: little magic to add zero terminator to end of string
                    if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                //--- HCRC_UPDATE(beg) ---//
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                //---//
                s.gzindex = 0;
            }
            s.status = COMMENT_STATE;
        }
        if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment/* != Z_NULL*/) {
                let beg = s.pending;   /* start of bytes to update crc */
                let val;
                do {
                    if (s.pending === s.pending_buf_size) {
                        //--- HCRC_UPDATE(beg) ---//
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        //---//
                        flush_pending(strm);
                        if (s.pending !== 0) {
                            s.last_flush = -1;
                            return Z_OK$3;
                        }
                        beg = 0;
                    }
                    // JS specific: little magic to add zero terminator to end of string
                    if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                //--- HCRC_UPDATE(beg) ---//
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                //---//
            }
            s.status = HCRC_STATE;
        }
        if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                }
                put_byte(s, strm.adler & 0xff);
                put_byte(s, (strm.adler >> 8) & 0xff);
                strm.adler = 0; //crc32(0L, Z_NULL, 0);
            }
            s.status = BUSY_STATE;

            /* Compression must start with an empty pending buffer */
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
        //#endif

        /* Start a new block or continue the current one.
     */
        if (strm.avail_in !== 0 || s.lookahead !== 0 ||
            (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
            let bstate = s.level === 0 ? deflate_stored(s, flush) :
                s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                    s.strategy === Z_RLE ? deflate_rle(s, flush) :
                        configuration_table[s.level].func(s, flush);

            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    /* avoid BUF_ERROR next call, see above */
                }
                return Z_OK$3;
                /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
         * of deflate should use the same flush parameter to make sure
         * that the flush is complete. So we don't have to output an
         * empty block here, this will be done at next call. This also
         * ensures that for a very small output buffer, we emit at most
         * one empty block.
         */
            }
            if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                    _tr_align(s);
                }
                else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

                    _tr_stored_block(s, 0, 0, false);
                    /* For a full flush, this empty block will be recognized
           * as a special marker by inflate_sync().
           */
                    if (flush === Z_FULL_FLUSH$1) {
                        /*** CLEAR_HASH(s); ***/             /* forget history */
                        zero(s.head); // Fill with NIL (= 0);

                        if (s.lookahead === 0) {
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                        }
                    }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
                    return Z_OK$3;
                }
            }
        }

        if (flush !== Z_FINISH$3) { return Z_OK$3; }
        if (s.wrap <= 0) { return Z_STREAM_END$3; }

        /* Write the trailer */
        if (s.wrap === 2) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            put_byte(s, (strm.adler >> 16) & 0xff);
            put_byte(s, (strm.adler >> 24) & 0xff);
            put_byte(s, strm.total_in & 0xff);
            put_byte(s, (strm.total_in >> 8) & 0xff);
            put_byte(s, (strm.total_in >> 16) & 0xff);
            put_byte(s, (strm.total_in >> 24) & 0xff);
        }
        else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
        }

        flush_pending(strm);
        /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
        if (s.wrap > 0) { s.wrap = -s.wrap; }
        /* write the trailer only once! */
        return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };


    const deflateEnd = (strm) => {

        if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
        }

        const status = strm.state.status;

        strm.state = null;

        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };


    /* =========================================================================
   * Initializes the compression dictionary from the given byte
   * sequence without producing any compressed output.
   */
    const deflateSetDictionary = (strm, dictionary) => {

        let dictLength = dictionary.length;

        if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
        }

        const s = strm.state;
        const wrap = s.wrap;

        if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
            return Z_STREAM_ERROR$2;
        }

        /* when using zlib wrappers, compute Adler-32 for provided dictionary */
        if (wrap === 1) {
            /* adler32(strm->adler, dictionary, dictLength); */
            strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
        }

        s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

        /* if dictionary would fill window, just replace the history */
        if (dictLength >= s.w_size) {
            if (wrap === 0) {            /* already empty otherwise */
                /*** CLEAR_HASH(s); ***/
                zero(s.head); // Fill with NIL (= 0);
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
            }
            /* use the tail */
            // dictionary = dictionary.slice(dictLength - s.w_size);
            let tmpDict = new Uint8Array(s.w_size);
            tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
        }
        /* insert dictionary into window and hash */
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
            let str = s.strstart;
            let n = s.lookahead - (MIN_MATCH - 1);
            do {
                /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

                s.prev[str & s.w_mask] = s.head[s.ins_h];

                s.head[s.ins_h] = str;
                str++;
            } while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK$3;
    };


    var deflateInit_1 = deflateInit;
    var deflateInit2_1 = deflateInit2;
    var deflateReset_1 = deflateReset;
    var deflateResetKeep_1 = deflateResetKeep;
    var deflateSetHeader_1 = deflateSetHeader;
    var deflate_2$1 = deflate$2;
    var deflateEnd_1 = deflateEnd;
    var deflateSetDictionary_1 = deflateSetDictionary;
    var deflateInfo = 'pako deflate (from Nodeca project)';

    /* Not implemented
  module.exports.deflateBound = deflateBound;
  module.exports.deflateCopy = deflateCopy;
  module.exports.deflateGetDictionary = deflateGetDictionary;
  module.exports.deflateParams = deflateParams;
  module.exports.deflatePending = deflatePending;
  module.exports.deflatePrime = deflatePrime;
  module.exports.deflateTune = deflateTune;
  */

    var deflate_1$2 = {
        deflateInit: deflateInit_1,
        deflateInit2: deflateInit2_1,
        deflateReset: deflateReset_1,
        deflateResetKeep: deflateResetKeep_1,
        deflateSetHeader: deflateSetHeader_1,
        deflate: deflate_2$1,
        deflateEnd: deflateEnd_1,
        deflateSetDictionary: deflateSetDictionary_1,
        deflateInfo: deflateInfo
    };

    const _has = (obj, key) => {
        return Object.prototype.hasOwnProperty.call(obj, key);
    };

    var assign = function (obj /*from1, from2, from3, ...*/) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
            const source = sources.shift();
            if (!source) { continue; }

            if (typeof source !== 'object') {
                throw new TypeError(source + 'must be non-object');
            }

            for (const p in source) {
                if (_has(source, p)) {
                    obj[p] = source[p];
                }
            }
        }

        return obj;
    };


    // Join array of chunks to single array.
    var flattenChunks = (chunks) => {
        // calculate data length
        let len = 0;

        for (let i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
        }

        // join chunks
        const result = new Uint8Array(len);

        for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
            let chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
        }

        return result;
    };

    var common = {
        assign: assign,
        flattenChunks: flattenChunks
    };

    // String encode/decode helpers


    // Quick check if we can use fast array to bin string conversion
    //
    // - apply(Array) can fail on Android 2.2
    // - apply(Uint8Array) can fail on iOS 5.1 Safari
    //
    let STR_APPLY_UIA_OK = true;

    try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


    // Table with utf8 lengths (calculated by first byte of sequence)
    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
    // because max possible codepoint is 0x10ffff
    const _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
        _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
    }
    _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


    // convert string to array (typed, when possible)
    var string2buf = (str) => {
        if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
            return new TextEncoder().encode(str);
        }

        let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

        // count binary size
        for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 0xfc00) === 0xdc00) {
                    c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                    m_pos++;
                }
            }
            buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
        }

        // allocate buffer
        buf = new Uint8Array(buf_len);

        // convert
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 0xfc00) === 0xdc00) {
                    c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                    m_pos++;
                }
            }
            if (c < 0x80) {
                /* one byte */
                buf[i++] = c;
            } else if (c < 0x800) {
                /* two bytes */
                buf[i++] = 0xC0 | (c >>> 6);
                buf[i++] = 0x80 | (c & 0x3f);
            } else if (c < 0x10000) {
                /* three bytes */
                buf[i++] = 0xE0 | (c >>> 12);
                buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                buf[i++] = 0x80 | (c & 0x3f);
            } else {
                /* four bytes */
                buf[i++] = 0xf0 | (c >>> 18);
                buf[i++] = 0x80 | (c >>> 12 & 0x3f);
                buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                buf[i++] = 0x80 | (c & 0x3f);
            }
        }

        return buf;
    };

    // Helper
    const buf2binstring = (buf, len) => {
        // On Chrome, the arguments in a function call that are allowed is `65534`.
        // If the length of the buffer is smaller than that, we can use this optimization,
        // otherwise we will take a slower path.
        if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK) {
                return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
            }
        }

        let result = '';
        for (let i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
        }
        return result;
    };


    // convert array to string
    var buf2string = (buf, max) => {
        const len = max || buf.length;

        if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
            return new TextDecoder().decode(buf.subarray(0, max));
        }

        let i, out;

        // Reserve max possible length (2 words per char)
        // NB: by unknown reasons, Array is significantly faster for
        //     String.fromCharCode.apply than Uint16Array.
        const utf16buf = new Array(len * 2);

        for (out = 0, i = 0; i < len;) {
            let c = buf[i++];
            // quick process ascii
            if (c < 0x80) { utf16buf[out++] = c; continue; }

            let c_len = _utf8len[c];
            // skip 5 & 6 byte codes
            if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

            // apply mask on first byte
            c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
            // join the rest
            while (c_len > 1 && i < len) {
                c = (c << 6) | (buf[i++] & 0x3f);
                c_len--;
            }

            // terminated by end of string?
            if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

            if (c < 0x10000) {
                utf16buf[out++] = c;
            } else {
                c -= 0x10000;
                utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
                utf16buf[out++] = 0xdc00 | (c & 0x3ff);
            }
        }

        return buf2binstring(utf16buf, out);
    };


    // Calculate max possible position in utf8 buffer,
    // that will not break sequence. If that's not possible
    // - (very small limits) return max size as is.
    //
    // buf[] - utf8 bytes array
    // max   - length limit (mandatory);
    var utf8border = (buf, max) => {

        max = max || buf.length;
        if (max > buf.length) { max = buf.length; }

        // go back from last position, until start of sequence found
        let pos = max - 1;
        while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

        // Very small and broken sequence,
        // return max, because we should return something anyway.
        if (pos < 0) { return max; }

        // If we came to start of buffer - that means buffer is too small,
        // return max too.
        if (pos === 0) { return max; }

        return (pos + _utf8len[buf[pos]] > max) ? pos : max;
    };

    var strings = {
        string2buf: string2buf,
        buf2string: buf2string,
        utf8border: utf8border
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    function ZStream() {
        /* next input byte */
        this.input = null; // JS specific, because we have no pointers
        this.next_in = 0;
        /* number of bytes available at input */
        this.avail_in = 0;
        /* total number of input bytes read so far */
        this.total_in = 0;
        /* next output byte should be put there */
        this.output = null; // JS specific, because we have no pointers
        this.next_out = 0;
        /* remaining free space at output */
        this.avail_out = 0;
        /* total number of bytes output so far */
        this.total_out = 0;
        /* last error message, NULL if no error */
        this.msg = ''/*Z_NULL*/;
        /* not visible by applications */
        this.state = null;
        /* best guess about the data type: binary or text */
        this.data_type = 2/*Z_UNKNOWN*/;
        /* adler32 value of the uncompressed data */
        this.adler = 0;
    }

    var zstream = ZStream;

    const toString$1 = Object.prototype.toString;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    const {
        Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
        Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_STRATEGY,
        Z_DEFLATED: Z_DEFLATED$1
    } = constants$2;

    /* ===========================================================================*/


    /**
     * class Deflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[deflate]],
     * [[deflateRaw]] and [[gzip]].
     **/

    /* internal
   * Deflate.chunks -> Array
   *
   * Chunks of output data, if [[Deflate#onData]] not overridden.
   **/

    /**
     * Deflate.result -> Uint8Array
     *
     * Compressed result, generated by default [[Deflate#onData]]
     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
     **/

    /**
     * Deflate.err -> Number
     *
     * Error code after deflate finished. 0 (Z_OK) on success.
     * You will not need it in real life, because deflate errors
     * are possible only on wrong options or bad `onData` / `onEnd`
     * custom handlers.
     **/

    /**
     * Deflate.msg -> String
     *
     * Error message, if [[Deflate.err]] != 0
     **/


    /**
     * new Deflate(options)
     * - options (Object): zlib deflate options.
     *
     * Creates new deflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `level`
     * - `windowBits`
     * - `memLevel`
     * - `strategy`
     * - `dictionary`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * - `chunkSize` - size of generated data chunks (16K by default)
     * - `raw` (Boolean) - do raw deflate
     * - `gzip` (Boolean) - create gzip wrapper
     * - `header` (Object) - custom header for gzip
     *   - `text` (Boolean) - true if compressed data believed to be text
     *   - `time` (Number) - modification time, unix timestamp
     *   - `os` (Number) - operation system code
     *   - `extra` (Array) - array of bytes with extra data (max 65536)
     *   - `name` (String) - file name (binary string)
     *   - `comment` (String) - comment (binary string)
     *   - `hcrc` (Boolean) - true if header crc should be added
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako')
     *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
     *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * const deflate = new pako.Deflate({ level: 3});
     *
     * deflate.push(chunk1, false);
     * deflate.push(chunk2, true);  // true -> last chunk
     *
     * if (deflate.err) { throw new Error(deflate.err); }
     *
     * console.log(deflate.result);
     * ```
     **/
    function Deflate$1(options) {
        this.options = common.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED$1,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY
        }, options || {});

        let opt = this.options;

        if (opt.raw && (opt.windowBits > 0)) {
            opt.windowBits = -opt.windowBits;
        }

        else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
            opt.windowBits += 16;
        }

        this.err = 0;      // error code, if happens (0 = Z_OK)
        this.msg = '';     // error message
        this.ended = false;  // used to avoid multiple onEnd() calls
        this.chunks = [];     // chunks of compressed data

        this.strm = new zstream();
        this.strm.avail_out = 0;

        let status = deflate_1$2.deflateInit2(
            this.strm,
            opt.level,
            opt.method,
            opt.windowBits,
            opt.memLevel,
            opt.strategy
        );

        if (status !== Z_OK$2) {
            throw new Error(messages[status]);
        }

        if (opt.header) {
            deflate_1$2.deflateSetHeader(this.strm, opt.header);
        }

        if (opt.dictionary) {
            let dict;
            // Convert data if needed
            if (typeof opt.dictionary === 'string') {
                // If we need to compress text, change encoding to utf8.
                dict = strings.string2buf(opt.dictionary);
            } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
                dict = new Uint8Array(opt.dictionary);
            } else {
                dict = opt.dictionary;
            }

            status = deflate_1$2.deflateSetDictionary(this.strm, dict);

            if (status !== Z_OK$2) {
                throw new Error(messages[status]);
            }

            this._dict_set = true;
        }
    }

    /**
     * Deflate#push(data[, flush_mode]) -> Boolean
     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
     *   converted to utf8 byte sequence.
     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
     *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
     *
     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
     * new compressed chunks. Returns `true` on success. The last data block must
     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
     * buffers and call [[Deflate#onEnd]].
     *
     * On fail call [[Deflate#onEnd]] with error code and return false.
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     **/
    Deflate$1.prototype.push = function (data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;

        if (this.ended) { return false; }

        if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
        else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

        // Convert data if needed
        if (typeof data === 'string') {
            // If we need to compress text, change encoding to utf8.
            strm.input = strings.string2buf(data);
        } else if (toString$1.call(data) === '[object ArrayBuffer]') {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }

        strm.next_in = 0;
        strm.avail_in = strm.input.length;

        for (; ;) {
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }

            // Make sure avail_out > 6 to avoid repeating markers
            if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
                this.onData(strm.output.subarray(0, strm.next_out));
                strm.avail_out = 0;
                continue;
            }

            status = deflate_1$2.deflate(strm, _flush_mode);

            // Ended => flush and finish
            if (status === Z_STREAM_END$2) {
                if (strm.next_out > 0) {
                    this.onData(strm.output.subarray(0, strm.next_out));
                }
                status = deflate_1$2.deflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return status === Z_OK$2;
            }

            // Flush if out buffer full
            if (strm.avail_out === 0) {
                this.onData(strm.output);
                continue;
            }

            // Flush if requested and has data
            if (_flush_mode > 0 && strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
                strm.avail_out = 0;
                continue;
            }

            if (strm.avail_in === 0) break;
        }

        return true;
    };


    /**
     * Deflate#onData(chunk) -> Void
     * - chunk (Uint8Array): output data.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     **/
    Deflate$1.prototype.onData = function (chunk) {
        this.chunks.push(chunk);
    };


    /**
     * Deflate#onEnd(status) -> Void
     * - status (Number): deflate status. 0 (Z_OK) on success,
     *   other if not.
     *
     * Called once after you tell deflate that the input stream is
     * complete (Z_FINISH). By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     **/
    Deflate$1.prototype.onEnd = function (status) {
        // On success - join
        if (status === Z_OK$2) {
            this.result = common.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };


    /**
     * deflate(data[, options]) -> Uint8Array
     * - data (Uint8Array|ArrayBuffer|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * Compress `data` with deflate algorithm and `options`.
     *
     * Supported options are:
     *
     * - level
     * - windowBits
     * - memLevel
     * - strategy
     * - dictionary
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Sugar (options):
     *
     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
     *   negative windowBits implicitly.
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako')
     * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
     *
     * console.log(pako.deflate(data));
     * ```
     **/
    function deflate$1(input, options) {
        const deflator = new Deflate$1(options);

        deflator.push(input, true);

        // That will never happens, if you don't cheat with options :)
        if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

        return deflator.result;
    }


    /**
     * deflateRaw(data[, options]) -> Uint8Array
     * - data (Uint8Array|ArrayBuffer|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * The same as [[deflate]], but creates raw data, without wrapper
     * (header and adler32 crc).
     **/
    function deflateRaw$1(input, options) {
        options = options || {};
        options.raw = true;
        return deflate$1(input, options);
    }


    /**
     * gzip(data[, options]) -> Uint8Array
     * - data (Uint8Array|ArrayBuffer|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * The same as [[deflate]], but create gzip wrapper instead of
     * deflate one.
     **/
    function gzip$1(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate$1(input, options);
    }


    var Deflate_1$1 = Deflate$1;
    var deflate_2 = deflate$1;
    var deflateRaw_1$1 = deflateRaw$1;
    var gzip_1$1 = gzip$1;
    var constants$1 = constants$2;

    var deflate_1$1 = {
        Deflate: Deflate_1$1,
        deflate: deflate_2,
        deflateRaw: deflateRaw_1$1,
        gzip: gzip_1$1,
        constants: constants$1
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    // See state defs from inflate.js
    const BAD$1 = 16209;       /* got a data error -- remain here until reset */
    const TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */

    /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.

     Entry assumptions:

          state.mode === LEN
          strm.avail_in >= 6
          strm.avail_out >= 258
          start >= strm.avail_out
          state.bits < 8

     On return, state.mode is one of:

          LEN -- ran out of enough output space or enough available input
          TYPE -- reached end of block code, inflate() to interpret next block
          BAD -- error in block data

     Notes:

      - The maximum input bits used by a length/distance pair is 15 bits for the
        length code, 5 bits for the length extra, 15 bits for the distance code,
        and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
        Therefore if strm.avail_in >= 6, then there is enough input to avoid
        checking for available input while decoding.

      - The maximum bytes that a single length/distance pair can output is 258
        bytes, which is the maximum length that can be coded.  inflate_fast()
        requires strm.avail_out >= 258 for each loop to avoid checking for
        output space.
   */
    var inffast = function inflate_fast(strm, start) {
        let _in;                    /* local strm.input */
        let last;                   /* have enough input while in < last */
        let _out;                   /* local strm.output */
        let beg;                    /* inflate()'s initial strm.output */
        let end;                    /* while out < end, enough space available */
        //#ifdef INFLATE_STRICT
        let dmax;                   /* maximum distance from zlib header */
        //#endif
        let wsize;                  /* window size or zero if not using window */
        let whave;                  /* valid bytes in the window */
        let wnext;                  /* window write index */
        // Use `s_window` instead `window`, avoid conflict with instrumentation tools
        let s_window;               /* allocated sliding window, if wsize != 0 */
        let hold;                   /* local strm.hold */
        let bits;                   /* local strm.bits */
        let lcode;                  /* local strm.lencode */
        let dcode;                  /* local strm.distcode */
        let lmask;                  /* mask for first level of length codes */
        let dmask;                  /* mask for first level of distance codes */
        let here;                   /* retrieved table entry */
        let op;                     /* code bits, operation, extra bits, or */
        /*  window position, window bytes to copy */
        let len;                    /* match length, unused bytes */
        let dist;                   /* match distance */
        let from;                   /* where to copy match from */
        let from_source;


        let input, output; // JS specific, because we have no pointers

        /* copy state to local variables */
        const state = strm.state;
        //here = state.here;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        //#ifdef INFLATE_STRICT
        dmax = state.dmax;
        //#endif
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;


        /* decode literals and length/distances until end-of-block or not enough
       input data or output space */

        top:
        do {
            if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
            }

            here = lcode[hold & lmask];

            dolen:
            for (; ;) { // Goto emulation
                op = here >>> 24/*here.bits*/;
                hold >>>= op;
                bits -= op;
                op = (here >>> 16) & 0xff/*here.op*/;
                if (op === 0) {                          /* literal */
                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                    //        "inflate:         literal '%c'\n" :
                    //        "inflate:         literal 0x%02x\n", here.val));
                    output[_out++] = here & 0xffff/*here.val*/;
                }
                else if (op & 16) {                     /* length base */
                    len = here & 0xffff/*here.val*/;
                    op &= 15;                           /* number of extra bits */
                    if (op) {
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                        }
                        len += hold & ((1 << op) - 1);
                        hold >>>= op;
                        bits -= op;
                    }
                    //Tracevv((stderr, "inflate:         length %u\n", len));
                    if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    here = dcode[hold & dmask];

                    dodist:
                    for (; ;) { // goto emulation
                        op = here >>> 24/*here.bits*/;
                        hold >>>= op;
                        bits -= op;
                        op = (here >>> 16) & 0xff/*here.op*/;

                        if (op & 16) {                      /* distance base */
                            dist = here & 0xffff/*here.val*/;
                            op &= 15;                       /* number of extra bits */
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                            }
                            dist += hold & ((1 << op) - 1);
                            //#ifdef INFLATE_STRICT
                            if (dist > dmax) {
                                strm.msg = 'invalid distance too far back';
                                state.mode = BAD$1;
                                break top;
                            }
                            //#endif
                            hold >>>= op;
                            bits -= op;
                            //Tracevv((stderr, "inflate:         distance %u\n", dist));
                            op = _out - beg;                /* max distance in output */
                            if (dist > op) {                /* see if copy from window */
                                op = dist - op;               /* distance back in window */
                                if (op > whave) {
                                    if (state.sane) {
                                        strm.msg = 'invalid distance too far back';
                                        state.mode = BAD$1;
                                        break top;
                                    }

                                    // (!) This block is disabled in zlib defaults,
                                    // don't enable it for binary compatibility
                                    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                    //                if (len <= op - whave) {
                                    //                  do {
                                    //                    output[_out++] = 0;
                                    //                  } while (--len);
                                    //                  continue top;
                                    //                }
                                    //                len -= op - whave;
                                    //                do {
                                    //                  output[_out++] = 0;
                                    //                } while (--op > whave);
                                    //                if (op === 0) {
                                    //                  from = _out - dist;
                                    //                  do {
                                    //                    output[_out++] = output[from++];
                                    //                  } while (--len);
                                    //                  continue top;
                                    //                }
                                    //#endif
                                }
                                from = 0; // window index
                                from_source = s_window;
                                if (wnext === 0) {           /* very common case */
                                    from += wsize - op;
                                    if (op < len) {         /* some from window */
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;  /* rest from output */
                                        from_source = output;
                                    }
                                }
                                else if (wnext < op) {      /* wrap around window */
                                    from += wsize + wnext - op;
                                    op -= wnext;
                                    if (op < len) {         /* some from end of window */
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = 0;
                                        if (wnext < len) {  /* some from start of window */
                                            op = wnext;
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            from = _out - dist;      /* rest from output */
                                            from_source = output;
                                        }
                                    }
                                }
                                else {                      /* contiguous in window */
                                    from += wnext - op;
                                    if (op < len) {         /* some from window */
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;  /* rest from output */
                                        from_source = output;
                                    }
                                }
                                while (len > 2) {
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    len -= 3;
                                }
                                if (len) {
                                    output[_out++] = from_source[from++];
                                    if (len > 1) {
                                        output[_out++] = from_source[from++];
                                    }
                                }
                            }
                            else {
                                from = _out - dist;          /* copy direct from output */
                                do {                        /* minimum length is three */
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    len -= 3;
                                } while (len > 2);
                                if (len) {
                                    output[_out++] = output[from++];
                                    if (len > 1) {
                                        output[_out++] = output[from++];
                                    }
                                }
                            }
                        }
                        else if ((op & 64) === 0) {          /* 2nd level distance code */
                            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                            continue dodist;
                        }
                        else {
                            strm.msg = 'invalid distance code';
                            state.mode = BAD$1;
                            break top;
                        }

                        break; // need to emulate goto via "continue"
                    }
                }
                else if ((op & 64) === 0) {              /* 2nd level length code */
                    here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                    continue dolen;
                }
                else if (op & 32) {                     /* end-of-block */
                    //Tracevv((stderr, "inflate:         end of block\n"));
                    state.mode = TYPE$1;
                    break top;
                }
                else {
                    strm.msg = 'invalid literal/length code';
                    state.mode = BAD$1;
                    break top;
                }

                break; // need to emulate goto via "continue"
            }
        } while (_in < last && _out < end);

        /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;

        /* update state and return */
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
        strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
        state.hold = hold;
        state.bits = bits;
        return;
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    const MAXBITS = 15;
    const ENOUGH_LENS$1 = 852;
    const ENOUGH_DISTS$1 = 592;
    //const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

    const CODES$1 = 0;
    const LENS$1 = 1;
    const DISTS$1 = 2;

    const lbase = new Uint16Array([ /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ]);

    const lext = new Uint8Array([ /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
    ]);

    const dbase = new Uint16Array([ /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0
    ]);

    const dext = new Uint8Array([ /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64
    ]);

    const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
        const bits = opts.bits;
        //here = opts.here; /* table entry for duplication */

        let len = 0;               /* a code's length in bits */
        let sym = 0;               /* index of code symbols */
        let min = 0, max = 0;          /* minimum and maximum code lengths */
        let root = 0;              /* number of index bits for root table */
        let curr = 0;              /* number of index bits for current table */
        let drop = 0;              /* code bits to drop for sub-table */
        let left = 0;                   /* number of prefix codes available */
        let used = 0;              /* code entries in table used */
        let huff = 0;              /* Huffman code */
        let incr;              /* for incrementing code, index */
        let fill;              /* index for replicating entries */
        let low;               /* low bits for current root entry */
        let mask;              /* mask for low root bits */
        let next;             /* next available space in table */
        let base = null;     /* base value table to use */
        //  let shoextra;    /* extra bits table to use */
        let match;                  /* use base and extra for symbol >= match */
        const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
        const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
        let extra = null;

        let here_bits, here_op, here_val;

        /*
     Process a set of code lengths to create a canonical Huffman code.  The
     code lengths are lens[0..codes-1].  Each length corresponds to the
     symbols 0..codes-1.  The Huffman code is generated by first sorting the
     symbols by length from short to long, and retaining the symbol order
     for codes with equal lengths.  Then the code starts with all zero bits
     for the first code of the shortest length, and the codes are integer
     increments for the same length, and zeros are appended as the length
     increases.  For the deflate format, these bits are stored backwards
     from their more natural integer increment ordering, and so when the
     decoding tables are built in the large loop below, the integer codes
     are incremented backwards.

     This routine assumes, but does not check, that all of the entries in
     lens[] are in the range 0..MAXBITS.  The caller must assure this.
     1..MAXBITS is interpreted as that code length.  zero means that that
     symbol does not occur in this code.

     The codes are sorted by computing a count of codes for each length,
     creating from that a table of starting indices for each length in the
     sorted table, and then entering the symbols in order in the sorted
     table.  The sorted table is work[], with that space being provided by
     the caller.

     The length counts are used for other purposes as well, i.e. finding
     the minimum and maximum length codes, determining if there are any
     codes at all, checking for a valid set of lengths, and looking ahead
     at length counts to determine sub-table sizes when building the
     decoding tables.
     */

        /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
        for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
        }

        /* bound code lengths, force root to be within code lengths */
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) { break; }
        }
        if (root > max) {
            root = max;
        }
        if (max === 0) {                     /* no symbols to code at all */
            //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
            //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
            //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
            table[table_index++] = (1 << 24) | (64 << 16) | 0;


            //table.op[opts.table_index] = 64;
            //table.bits[opts.table_index] = 1;
            //table.val[opts.table_index++] = 0;
            table[table_index++] = (1 << 24) | (64 << 16) | 0;

            opts.bits = 1;
            return 0;     /* no symbols, but wait for decoding to report error */
        }
        for (min = 1; min < max; min++) {
            if (count[min] !== 0) { break; }
        }
        if (root < min) {
            root = min;
        }

        /* check for an over-subscribed or incomplete set of lengths */
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
                return -1;
            }        /* over-subscribed */
        }
        if (left > 0 && (type === CODES$1 || max !== 1)) {
            return -1;                      /* incomplete set */
        }

        /* generate offsets into symbol table for each length for sorting */
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
        }

        /* sort symbols by length, by symbol order within each length */
        for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
            }
        }

        /*
     Create and fill in decoding tables.  In this loop, the table being
     filled is at next and has curr index bits.  The code being used is huff
     with length len.  That code is converted to an index by dropping drop
     bits off of the bottom.  For codes where len is less than drop + curr,
     those top drop + curr - len bits are incremented through all values to
     fill the table with replicated entries.

     root is the number of index bits for the root table.  When len exceeds
     root, sub-tables are created pointed to by the root entry with an index
     of the low root bits of huff.  This is saved in low to check for when a
     new sub-table should be started.  drop is zero when the root table is
     being filled, and drop is root when sub-tables are being filled.

     When a new sub-table is needed, it is necessary to look ahead in the
     code lengths to determine what size sub-table is needed.  The length
     counts are used for this, and so count[] is decremented as codes are
     entered in the tables.

     used keeps track of how many table entries have been allocated from the
     provided *table space.  It is checked for LENS and DIST tables against
     the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
     the initial root table size constants.  See the comments in inftrees.h
     for more information.

     sym increments through all symbols, and the loop terminates when
     all codes of length max, i.e. all codes, have been processed.  This
     routine permits incomplete codes, so another loop after this one fills
     in the rest of the decoding tables with invalid code markers.
     */

        /* set up for code type */
        // poor man optimization - use if-else instead of switch,
        // to avoid deopts in old v8
        if (type === CODES$1) {
            base = extra = work;    /* dummy value--not used */
            match = 20;

        } else if (type === LENS$1) {
            base = lbase;
            extra = lext;
            match = 257;

        } else {                    /* DISTS */
            base = dbase;
            extra = dext;
            match = 0;
        }

        /* initialize opts for loop */
        huff = 0;                   /* starting code */
        sym = 0;                    /* starting code symbol */
        len = min;                  /* starting code length */
        next = table_index;              /* current table to fill in */
        curr = root;                /* current table index bits */
        drop = 0;                   /* current bits to drop from code for index */
        low = -1;                   /* trigger new sub-table when len > root */
        used = 1 << root;          /* use root table entries */
        mask = used - 1;            /* mask for comparing low */

        /* check available table space */
        if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
            (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
            return 1;
        }

        /* process all codes and make table entries */
        for (; ;) {
            /* create table entry */
            here_bits = len - drop;
            if (work[sym] + 1 < match) {
                here_op = 0;
                here_val = work[sym];
            }
            else if (work[sym] >= match) {
                here_op = extra[work[sym] - match];
                here_val = base[work[sym] - match];
            }
            else {
                here_op = 32 + 64;         /* end of block */
                here_val = 0;
            }

            /* replicate for those indices with low len bits equal to huff */
            incr = 1 << (len - drop);
            fill = 1 << curr;
            min = fill;                 /* save offset to next table */
            do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
            } while (fill !== 0);

            /* backwards increment the len-bit code huff */
            incr = 1 << (len - 1);
            while (huff & incr) {
                incr >>= 1;
            }
            if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
            } else {
                huff = 0;
            }

            /* go to next symbol, update count, len */
            sym++;
            if (--count[len] === 0) {
                if (len === max) { break; }
                len = lens[lens_index + work[sym]];
            }

            /* create new sub-table if needed */
            if (len > root && (huff & mask) !== low) {
                /* if first time, transition to sub-tables */
                if (drop === 0) {
                    drop = root;
                }

                /* increment past last table */
                next += min;            /* here min is 1 << curr */

                /* determine length of next table */
                curr = len - drop;
                left = 1 << curr;
                while (curr + drop < max) {
                    left -= count[curr + drop];
                    if (left <= 0) { break; }
                    curr++;
                    left <<= 1;
                }

                /* check for enough space */
                used += 1 << curr;
                if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
                    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
                    return 1;
                }

                /* point entry in root table to sub-table */
                low = huff & mask;
                /*table.op[low] = curr;
        table.bits[low] = root;
        table.val[low] = next - opts.table_index;*/
                table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
            }
        }

        /* fill in remaining table entry if code is incomplete (guaranteed to have
     at most one remaining entry, since if the code is incomplete, the
     maximum code length that was allowed to get this far is one bit) */
        if (huff !== 0) {
            //table.op[next + huff] = 64;            /* invalid code marker */
            //table.bits[next + huff] = len - drop;
            //table.val[next + huff] = 0;
            table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
        }

        /* set return parameters */
        //opts.table_index += used;
        opts.bits = root;
        return 0;
    };


    var inftrees = inflate_table;

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.






    const CODES = 0;
    const LENS = 1;
    const DISTS = 2;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    const {
        Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
        Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
        Z_DEFLATED
    } = constants$2;


    /* STATES ====================================================================*/
    /* ===========================================================================*/


    const HEAD = 16180;       /* i: waiting for magic header */
    const FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
    const TIME = 16182;       /* i: waiting for modification time (gzip) */
    const OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
    const EXLEN = 16184;      /* i: waiting for extra length (gzip) */
    const EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
    const NAME = 16186;       /* i: waiting for end of file name (gzip) */
    const COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
    const HCRC = 16188;       /* i: waiting for header crc (gzip) */
    const DICTID = 16189;    /* i: waiting for dictionary check value */
    const DICT = 16190;      /* waiting for inflateSetDictionary() call */
    const TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
    const TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
    const STORED = 16193;    /* i: waiting for stored size (length and complement) */
    const COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
    const COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
    const TABLE = 16196;     /* i: waiting for dynamic block table lengths */
    const LENLENS = 16197;   /* i: waiting for code length code lengths */
    const CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
    const LEN_ = 16199;      /* i: same as LEN below, but only first time in */
    const LEN = 16200;       /* i: waiting for length/lit/eob code */
    const LENEXT = 16201;    /* i: waiting for length extra bits */
    const DIST = 16202;      /* i: waiting for distance code */
    const DISTEXT = 16203;   /* i: waiting for distance extra bits */
    const MATCH = 16204;     /* o: waiting for output space to copy string */
    const LIT = 16205;       /* o: waiting for output space to write literal */
    const CHECK = 16206;     /* i: waiting for 32-bit check value */
    const LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
    const DONE = 16208;      /* finished check, done -- remain here until reset */
    const BAD = 16209;       /* got a data error -- remain here until reset */
    const MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
    const SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

    /* ===========================================================================*/



    const ENOUGH_LENS = 852;
    const ENOUGH_DISTS = 592;
    //const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

    const MAX_WBITS = 15;
    /* 32K LZ77 window */
    const DEF_WBITS = MAX_WBITS;


    const zswap32 = (q) => {

        return (((q >>> 24) & 0xff) +
            ((q >>> 8) & 0xff00) +
            ((q & 0xff00) << 8) +
            ((q & 0xff) << 24));
    };


    function InflateState() {
        this.strm = null;           /* pointer back to this zlib stream */
        this.mode = 0;              /* current inflate mode */
        this.last = false;          /* true if processing last block */
        this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                   bit 2 true to validate check value */
        this.havedict = false;      /* true if dictionary provided */
        this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                   -1 if raw or no header yet */
        this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
        this.check = 0;             /* protected copy of check value */
        this.total = 0;             /* protected copy of output count */
        // TODO: may be {}
        this.head = null;           /* where to save gzip header information */

        /* sliding window */
        this.wbits = 0;             /* log base 2 of requested window size */
        this.wsize = 0;             /* window size or zero if not using window */
        this.whave = 0;             /* valid bytes in the window */
        this.wnext = 0;             /* window write index */
        this.window = null;         /* allocated sliding window, if needed */

        /* bit accumulator */
        this.hold = 0;              /* input bit accumulator */
        this.bits = 0;              /* number of bits in "in" */

        /* for string and stored block copying */
        this.length = 0;            /* literal or length of data to copy */
        this.offset = 0;            /* distance back to copy string from */

        /* for table and code decoding */
        this.extra = 0;             /* extra bits needed */

        /* fixed and dynamic code tables */
        this.lencode = null;          /* starting table for length/literal codes */
        this.distcode = null;         /* starting table for distance codes */
        this.lenbits = 0;           /* index bits for lencode */
        this.distbits = 0;          /* index bits for distcode */

        /* dynamic table building */
        this.ncode = 0;             /* number of code length code lengths */
        this.nlen = 0;              /* number of length code lengths */
        this.ndist = 0;             /* number of distance code lengths */
        this.have = 0;              /* number of code lengths in lens[] */
        this.next = null;              /* next available space in codes[] */

        this.lens = new Uint16Array(320); /* temporary storage for code lengths */
        this.work = new Uint16Array(288); /* work area for code table building */

        /*
     because we don't have pointers in js, we use lencode and distcode directly
     as buffers so we don't need codes
    */
        //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
        this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
        this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
        this.sane = 0;                   /* if false, allow invalid distance too far */
        this.back = 0;                   /* bits back of last unprocessed length/lit */
        this.was = 0;                    /* initial length of match */
    }


    const inflateStateCheck = (strm) => {

        if (!strm) {
            return 1;
        }
        const state = strm.state;
        if (!state || state.strm !== strm ||
            state.mode < HEAD || state.mode > SYNC) {
            return 1;
        }
        return 0;
    };


    const inflateResetKeep = (strm) => {

        if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = ''; /*Z_NULL*/
        if (state.wrap) {       /* to support ill-conceived Java test suite */
            strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.flags = -1;
        state.dmax = 32768;
        state.head = null/*Z_NULL*/;
        state.hold = 0;
        state.bits = 0;
        //state.lencode = state.distcode = state.next = state.codes;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

        state.sane = 1;
        state.back = -1;
        //Tracev((stderr, "inflate: reset\n"));
        return Z_OK$1;
    };


    const inflateReset = (strm) => {

        if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);

    };


    const inflateReset2 = (strm, windowBits) => {
        let wrap;

        /* get the state */
        if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
        const state = strm.state;

        /* extract wrap request from windowBits parameter */
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        }
        else {
            wrap = (windowBits >> 4) + 5;
            if (windowBits < 48) {
                windowBits &= 15;
            }
        }

        /* set number of window bits, free window if different */
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR$1;
        }
        if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
        }

        /* update state and reset the rest of it */
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
    };


    const inflateInit2 = (strm, windowBits) => {

        if (!strm) { return Z_STREAM_ERROR$1; }
        //strm.msg = Z_NULL;                 /* in case we return an error */

        const state = new InflateState();

        //if (state === Z_NULL) return Z_MEM_ERROR;
        //Tracev((stderr, "inflate: allocated\n"));
        strm.state = state;
        state.strm = strm;
        state.window = null/*Z_NULL*/;
        state.mode = HEAD;     /* to pass state test in inflateReset2() */
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK$1) {
            strm.state = null/*Z_NULL*/;
        }
        return ret;
    };


    const inflateInit = (strm) => {

        return inflateInit2(strm, DEF_WBITS);
    };


    /*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
   */
    let virgin = true;

    let lenfix, distfix; // We have no pointers in JS, so keep tables separate


    const fixedtables = (state) => {

        /* build fixed huffman tables if first call (may not be thread safe) */
        if (virgin) {
            lenfix = new Int32Array(512);
            distfix = new Int32Array(32);

            /* literal/length table */
            let sym = 0;
            while (sym < 144) { state.lens[sym++] = 8; }
            while (sym < 256) { state.lens[sym++] = 9; }
            while (sym < 280) { state.lens[sym++] = 7; }
            while (sym < 288) { state.lens[sym++] = 8; }

            inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });

            /* distance table */
            sym = 0;
            while (sym < 32) { state.lens[sym++] = 5; }

            inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });

            /* do this just once */
            virgin = false;
        }

        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
    };


    /*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
   */
    const updatewindow = (strm, src, end, copy) => {

        let dist;
        const state = strm.state;

        /* if it hasn't been done already, allocate space for the window */
        if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;

            state.window = new Uint8Array(state.wsize);
        }

        /* copy state->wsize or less output bytes into the circular window */
        if (copy >= state.wsize) {
            state.window.set(src.subarray(end - state.wsize, end), 0);
            state.wnext = 0;
            state.whave = state.wsize;
        }
        else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
                dist = copy;
            }
            //zmemcpy(state->window + state->wnext, end - copy, dist);
            state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
            copy -= dist;
            if (copy) {
                //zmemcpy(state->window, end - copy, copy);
                state.window.set(src.subarray(end - copy, end), 0);
                state.wnext = copy;
                state.whave = state.wsize;
            }
            else {
                state.wnext += dist;
                if (state.wnext === state.wsize) { state.wnext = 0; }
                if (state.whave < state.wsize) { state.whave += dist; }
            }
        }
        return 0;
    };


    const inflate$2 = (strm, flush) => {

        let state;
        let input, output;          // input/output buffers
        let next;                   /* next input INDEX */
        let put;                    /* next output INDEX */
        let have, left;             /* available input and output */
        let hold;                   /* bit buffer */
        let bits;                   /* bits in bit buffer */
        let _in, _out;              /* save starting available input and output */
        let copy;                   /* number of stored or match bytes to copy */
        let from;                   /* where to copy match bytes from */
        let from_source;
        let here = 0;               /* current decoding table entry */
        let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
        //let last;                   /* parent table entry */
        let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
        let len;                    /* length to copy for repeats, bits to drop */
        let ret;                    /* return code */
        const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
        let opts;

        let n; // temporary variable for NEED_BITS

        const order = /* permutation of code lengths */
            new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);


        if (inflateStateCheck(strm) || !strm.output ||
            (!strm.input && strm.avail_in !== 0)) {
            return Z_STREAM_ERROR$1;
        }

        state = strm.state;
        if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        _in = have;
        _out = left;
        ret = Z_OK$1;

        inf_leave: // goto emulation
        for (; ;) {
            switch (state.mode) {
                case HEAD:
                    if (state.wrap === 0) {
                        state.mode = TYPEDO;
                        break;
                    }
                    //=== NEEDBITS(16);
                    while (bits < 16) {
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    //===//
                    if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
                        if (state.wbits === 0) {
                            state.wbits = 15;
                        }
                        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
                        //=== CRC2(state.check, hold);
                        hbuf[0] = hold & 0xff;
                        hbuf[1] = (hold >>> 8) & 0xff;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                        //===//

                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = FLAGS;
                        break;
                    }
                    if (state.head) {
                        state.head.done = false;
                    }
                    if (!(state.wrap & 1) ||   /* check if zlib header allowed */
                        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
                        strm.msg = 'incorrect header check';
                        state.mode = BAD;
                        break;
                    }
                    if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
                        strm.msg = 'unknown compression method';
                        state.mode = BAD;
                        break;
                    }
                    //--- DROPBITS(4) ---//
                    hold >>>= 4;
                    bits -= 4;
                    //---//
                    len = (hold & 0x0f)/*BITS(4)*/ + 8;
                    if (state.wbits === 0) {
                        state.wbits = len;
                    }
                    if (len > 15 || len > state.wbits) {
                        strm.msg = 'invalid window size';
                        state.mode = BAD;
                        break;
                    }

                    // !!! pako patch. Force use `options.windowBits` if passed.
                    // Required to always use max window size by default.
                    state.dmax = 1 << state.wbits;
                    //state.dmax = 1 << len;

                    state.flags = 0;               /* indicate zlib header */
                    //Tracev((stderr, "inflate:   zlib header ok\n"));
                    strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
                    state.mode = hold & 0x200 ? DICTID : TYPE;
                    //=== INITBITS();
                    hold = 0;
                    bits = 0;
                    //===//
                    break;
                case FLAGS:
                    //=== NEEDBITS(16); */
                    while (bits < 16) {
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    //===//
                    state.flags = hold;
                    if ((state.flags & 0xff) !== Z_DEFLATED) {
                        strm.msg = 'unknown compression method';
                        state.mode = BAD;
                        break;
                    }
                    if (state.flags & 0xe000) {
                        strm.msg = 'unknown header flags set';
                        state.mode = BAD;
                        break;
                    }
                    if (state.head) {
                        state.head.text = ((hold >> 8) & 1);
                    }
                    if ((state.flags & 0x0200) && (state.wrap & 4)) {
                        //=== CRC2(state.check, hold);
                        hbuf[0] = hold & 0xff;
                        hbuf[1] = (hold >>> 8) & 0xff;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                        //===//
                    }
                    //=== INITBITS();
                    hold = 0;
                    bits = 0;
                    //===//
                    state.mode = TIME;
                /* falls through */
                case TIME:
                    //=== NEEDBITS(32); */
                    while (bits < 32) {
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    //===//
                    if (state.head) {
                        state.head.time = hold;
                    }
                    if ((state.flags & 0x0200) && (state.wrap & 4)) {
                        //=== CRC4(state.check, hold)
                        hbuf[0] = hold & 0xff;
                        hbuf[1] = (hold >>> 8) & 0xff;
                        hbuf[2] = (hold >>> 16) & 0xff;
                        hbuf[3] = (hold >>> 24) & 0xff;
                        state.check = crc32_1(state.check, hbuf, 4, 0);
                        //===
                    }
                    //=== INITBITS();
                    hold = 0;
                    bits = 0;
                    //===//
                    state.mode = OS;
                /* falls through */
                case OS:
                    //=== NEEDBITS(16); */
                    while (bits < 16) {
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    //===//
                    if (state.head) {
                        state.head.xflags = (hold & 0xff);
                        state.head.os = (hold >> 8);
                    }
                    if ((state.flags & 0x0200) && (state.wrap & 4)) {
                        //=== CRC2(state.check, hold);
                        hbuf[0] = hold & 0xff;
                        hbuf[1] = (hold >>> 8) & 0xff;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                        //===//
                    }
                    //=== INITBITS();
                    hold = 0;
                    bits = 0;
                    //===//
                    state.mode = EXLEN;
                /* falls through */
                case EXLEN:
                    if (state.flags & 0x0400) {
                        //=== NEEDBITS(16); */
                        while (bits < 16) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.length = hold;
                        if (state.head) {
                            state.head.extra_len = hold;
                        }
                        if ((state.flags & 0x0200) && (state.wrap & 4)) {
                            //=== CRC2(state.check, hold);
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            state.check = crc32_1(state.check, hbuf, 2, 0);
                            //===//
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                    }
                    else if (state.head) {
                        state.head.extra = null/*Z_NULL*/;
                    }
                    state.mode = EXTRA;
                /* falls through */
                case EXTRA:
                    if (state.flags & 0x0400) {
                        copy = state.length;
                        if (copy > have) { copy = have; }
                        if (copy) {
                            if (state.head) {
                                len = state.head.extra_len - state.length;
                                if (!state.head.extra) {
                                    // Use untyped array for more convenient processing later
                                    state.head.extra = new Uint8Array(state.head.extra_len);
                                }
                                state.head.extra.set(
                                    input.subarray(
                                        next,
                                        // extra field is limited to 65536 bytes
                                        // - no need for additional size check
                                        next + copy
                                    ),
                                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                    len
                                );
                                //zmemcpy(state.head.extra + len, next,
                                //        len + copy > state.head.extra_max ?
                                //        state.head.extra_max - len : copy);
                            }
                            if ((state.flags & 0x0200) && (state.wrap & 4)) {
                                state.check = crc32_1(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            state.length -= copy;
                        }
                        if (state.length) { break inf_leave; }
                    }
                    state.length = 0;
                    state.mode = NAME;
                /* falls through */
                case NAME:
                    if (state.flags & 0x0800) {
                        if (have === 0) { break inf_leave; }
                        copy = 0;
                        do {
                            // TODO: 2 or 1 bytes?
                            len = input[next + copy++];
                            /* use constant limit because in js we should not preallocate memory */
                            if (state.head && len &&
                                (state.length < 65536 /*state.head.name_max*/)) {
                                state.head.name += String.fromCharCode(len);
                            }
                        } while (len && copy < have);

                        if ((state.flags & 0x0200) && (state.wrap & 4)) {
                            state.check = crc32_1(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        if (len) { break inf_leave; }
                    }
                    else if (state.head) {
                        state.head.name = null;
                    }
                    state.length = 0;
                    state.mode = COMMENT;
                /* falls through */
                case COMMENT:
                    if (state.flags & 0x1000) {
                        if (have === 0) { break inf_leave; }
                        copy = 0;
                        do {
                            len = input[next + copy++];
                            /* use constant limit because in js we should not preallocate memory */
                            if (state.head && len &&
                                (state.length < 65536 /*state.head.comm_max*/)) {
                                state.head.comment += String.fromCharCode(len);
                            }
                        } while (len && copy < have);
                        if ((state.flags & 0x0200) && (state.wrap & 4)) {
                            state.check = crc32_1(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        if (len) { break inf_leave; }
                    }
                    else if (state.head) {
                        state.head.comment = null;
                    }
                    state.mode = HCRC;
                /* falls through */
                case HCRC:
                    if (state.flags & 0x0200) {
                        //=== NEEDBITS(16); */
                        while (bits < 16) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
                            strm.msg = 'header crc mismatch';
                            state.mode = BAD;
                            break;
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                    }
                    if (state.head) {
                        state.head.hcrc = ((state.flags >> 9) & 1);
                        state.head.done = true;
                    }
                    strm.adler = state.check = 0;
                    state.mode = TYPE;
                    break;
                case DICTID:
                    //=== NEEDBITS(32); */
                    while (bits < 32) {
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    //===//
                    strm.adler = state.check = zswap32(hold);
                    //=== INITBITS();
                    hold = 0;
                    bits = 0;
                    //===//
                    state.mode = DICT;
                /* falls through */
                case DICT:
                    if (state.havedict === 0) {
                        //--- RESTORE() ---
                        strm.next_out = put;
                        strm.avail_out = left;
                        strm.next_in = next;
                        strm.avail_in = have;
                        state.hold = hold;
                        state.bits = bits;
                        //---
                        return Z_NEED_DICT$1;
                    }
                    strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
                    state.mode = TYPE;
                /* falls through */
                case TYPE:
                    if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
                /* falls through */
                case TYPEDO:
                    if (state.last) {
                        //--- BYTEBITS() ---//
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        //---//
                        state.mode = CHECK;
                        break;
                    }
                    //=== NEEDBITS(3); */
                    while (bits < 3) {
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    //===//
                    state.last = (hold & 0x01)/*BITS(1)*/;
                    //--- DROPBITS(1) ---//
                    hold >>>= 1;
                    bits -= 1;
                    //---//

                    switch ((hold & 0x03)/*BITS(2)*/) {
                        case 0:                             /* stored block */
                            //Tracev((stderr, "inflate:     stored block%s\n",
                            //        state.last ? " (last)" : ""));
                            state.mode = STORED;
                            break;
                        case 1:                             /* fixed block */
                            fixedtables(state);
                            //Tracev((stderr, "inflate:     fixed codes block%s\n",
                            //        state.last ? " (last)" : ""));
                            state.mode = LEN_;             /* decode codes */
                            if (flush === Z_TREES) {
                                //--- DROPBITS(2) ---//
                                hold >>>= 2;
                                bits -= 2;
                                //---//
                                break inf_leave;
                            }
                            break;
                        case 2:                             /* dynamic block */
                            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                            //        state.last ? " (last)" : ""));
                            state.mode = TABLE;
                            break;
                        case 3:
                            strm.msg = 'invalid block type';
                            state.mode = BAD;
                    }
                    //--- DROPBITS(2) ---//
                    hold >>>= 2;
                    bits -= 2;
                    //---//
                    break;
                case STORED:
                    //--- BYTEBITS() ---// /* go to byte boundary */
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    //---//
                    //=== NEEDBITS(32); */
                    while (bits < 32) {
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    //===//
                    if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                        strm.msg = 'invalid stored block lengths';
                        state.mode = BAD;
                        break;
                    }
                    state.length = hold & 0xffff;
                    //Tracev((stderr, "inflate:       stored length %u\n",
                    //        state.length));
                    //=== INITBITS();
                    hold = 0;
                    bits = 0;
                    //===//
                    state.mode = COPY_;
                    if (flush === Z_TREES) { break inf_leave; }
                /* falls through */
                case COPY_:
                    state.mode = COPY;
                /* falls through */
                case COPY:
                    copy = state.length;
                    if (copy) {
                        if (copy > have) { copy = have; }
                        if (copy > left) { copy = left; }
                        if (copy === 0) { break inf_leave; }
                        //--- zmemcpy(put, next, copy); ---
                        output.set(input.subarray(next, next + copy), put);
                        //---//
                        have -= copy;
                        next += copy;
                        left -= copy;
                        put += copy;
                        state.length -= copy;
                        break;
                    }
                    //Tracev((stderr, "inflate:       stored end\n"));
                    state.mode = TYPE;
                    break;
                case TABLE:
                    //=== NEEDBITS(14); */
                    while (bits < 14) {
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    //===//
                    state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
                    //--- DROPBITS(5) ---//
                    hold >>>= 5;
                    bits -= 5;
                    //---//
                    state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
                    //--- DROPBITS(5) ---//
                    hold >>>= 5;
                    bits -= 5;
                    //---//
                    state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
                    //--- DROPBITS(4) ---//
                    hold >>>= 4;
                    bits -= 4;
                    //---//
                    //#ifndef PKZIP_BUG_WORKAROUND
                    if (state.nlen > 286 || state.ndist > 30) {
                        strm.msg = 'too many length or distance symbols';
                        state.mode = BAD;
                        break;
                    }
                    //#endif
                    //Tracev((stderr, "inflate:       table sizes ok\n"));
                    state.have = 0;
                    state.mode = LENLENS;
                /* falls through */
                case LENLENS:
                    while (state.have < state.ncode) {
                        //=== NEEDBITS(3);
                        while (bits < 3) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
                        //--- DROPBITS(3) ---//
                        hold >>>= 3;
                        bits -= 3;
                        //---//
                    }
                    while (state.have < 19) {
                        state.lens[order[state.have++]] = 0;
                    }
                    // We have separate tables & no pointers. 2 commented lines below not needed.
                    //state.next = state.codes;
                    //state.lencode = state.next;
                    // Switch to use dynamic table
                    state.lencode = state.lendyn;
                    state.lenbits = 7;

                    opts = { bits: state.lenbits };
                    ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                    state.lenbits = opts.bits;

                    if (ret) {
                        strm.msg = 'invalid code lengths set';
                        state.mode = BAD;
                        break;
                    }
                    //Tracev((stderr, "inflate:       code lengths ok\n"));
                    state.have = 0;
                    state.mode = CODELENS;
                /* falls through */
                case CODELENS:
                    while (state.have < state.nlen + state.ndist) {
                        for (; ;) {
                            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
                            here_bits = here >>> 24;
                            here_op = (here >>> 16) & 0xff;
                            here_val = here & 0xffff;

                            if ((here_bits) <= bits) { break; }
                            //--- PULLBYTE() ---//
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                            //---//
                        }
                        if (here_val < 16) {
                            //--- DROPBITS(here.bits) ---//
                            hold >>>= here_bits;
                            bits -= here_bits;
                            //---//
                            state.lens[state.have++] = here_val;
                        }
                        else {
                            if (here_val === 16) {
                                //=== NEEDBITS(here.bits + 2);
                                n = here_bits + 2;
                                while (bits < n) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                //--- DROPBITS(here.bits) ---//
                                hold >>>= here_bits;
                                bits -= here_bits;
                                //---//
                                if (state.have === 0) {
                                    strm.msg = 'invalid bit length repeat';
                                    state.mode = BAD;
                                    break;
                                }
                                len = state.lens[state.have - 1];
                                copy = 3 + (hold & 0x03);//BITS(2);
                                //--- DROPBITS(2) ---//
                                hold >>>= 2;
                                bits -= 2;
                                //---//
                            }
                            else if (here_val === 17) {
                                //=== NEEDBITS(here.bits + 3);
                                n = here_bits + 3;
                                while (bits < n) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                //--- DROPBITS(here.bits) ---//
                                hold >>>= here_bits;
                                bits -= here_bits;
                                //---//
                                len = 0;
                                copy = 3 + (hold & 0x07);//BITS(3);
                                //--- DROPBITS(3) ---//
                                hold >>>= 3;
                                bits -= 3;
                                //---//
                            }
                            else {
                                //=== NEEDBITS(here.bits + 7);
                                n = here_bits + 7;
                                while (bits < n) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                //--- DROPBITS(here.bits) ---//
                                hold >>>= here_bits;
                                bits -= here_bits;
                                //---//
                                len = 0;
                                copy = 11 + (hold & 0x7f);//BITS(7);
                                //--- DROPBITS(7) ---//
                                hold >>>= 7;
                                bits -= 7;
                                //---//
                            }
                            if (state.have + copy > state.nlen + state.ndist) {
                                strm.msg = 'invalid bit length repeat';
                                state.mode = BAD;
                                break;
                            }
                            while (copy--) {
                                state.lens[state.have++] = len;
                            }
                        }
                    }

                    /* handle error breaks in while */
                    if (state.mode === BAD) { break; }

                    /* check for end-of-block code (better have one) */
                    if (state.lens[256] === 0) {
                        strm.msg = 'invalid code -- missing end-of-block';
                        state.mode = BAD;
                        break;
                    }

                    /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
                    state.lenbits = 9;

                    opts = { bits: state.lenbits };
                    ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                    // We have separate tables & no pointers. 2 commented lines below not needed.
                    // state.next_index = opts.table_index;
                    state.lenbits = opts.bits;
                    // state.lencode = state.next;

                    if (ret) {
                        strm.msg = 'invalid literal/lengths set';
                        state.mode = BAD;
                        break;
                    }

                    state.distbits = 6;
                    //state.distcode.copy(state.codes);
                    // Switch to use dynamic table
                    state.distcode = state.distdyn;
                    opts = { bits: state.distbits };
                    ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                    // We have separate tables & no pointers. 2 commented lines below not needed.
                    // state.next_index = opts.table_index;
                    state.distbits = opts.bits;
                    // state.distcode = state.next;

                    if (ret) {
                        strm.msg = 'invalid distances set';
                        state.mode = BAD;
                        break;
                    }
                    //Tracev((stderr, 'inflate:       codes ok\n'));
                    state.mode = LEN_;
                    if (flush === Z_TREES) { break inf_leave; }
                /* falls through */
                case LEN_:
                    state.mode = LEN;
                /* falls through */
                case LEN:
                    if (have >= 6 && left >= 258) {
                        //--- RESTORE() ---
                        strm.next_out = put;
                        strm.avail_out = left;
                        strm.next_in = next;
                        strm.avail_in = have;
                        state.hold = hold;
                        state.bits = bits;
                        //---
                        inffast(strm, _out);
                        //--- LOAD() ---
                        put = strm.next_out;
                        output = strm.output;
                        left = strm.avail_out;
                        next = strm.next_in;
                        input = strm.input;
                        have = strm.avail_in;
                        hold = state.hold;
                        bits = state.bits;
                        //---

                        if (state.mode === TYPE) {
                            state.back = -1;
                        }
                        break;
                    }
                    state.back = 0;
                    for (; ;) {
                        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
                        here_bits = here >>> 24;
                        here_op = (here >>> 16) & 0xff;
                        here_val = here & 0xffff;

                        if (here_bits <= bits) { break; }
                        //--- PULLBYTE() ---//
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                        //---//
                    }
                    if (here_op && (here_op & 0xf0) === 0) {
                        last_bits = here_bits;
                        last_op = here_op;
                        last_val = here_val;
                        for (; ;) {
                            here = state.lencode[last_val +
                                ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = (here >>> 16) & 0xff;
                            here_val = here & 0xffff;

                            if ((last_bits + here_bits) <= bits) { break; }
                            //--- PULLBYTE() ---//
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                            //---//
                        }
                        //--- DROPBITS(last.bits) ---//
                        hold >>>= last_bits;
                        bits -= last_bits;
                        //---//
                        state.back += last_bits;
                    }
                    //--- DROPBITS(here.bits) ---//
                    hold >>>= here_bits;
                    bits -= here_bits;
                    //---//
                    state.back += here_bits;
                    state.length = here_val;
                    if (here_op === 0) {
                        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        //        "inflate:         literal '%c'\n" :
                        //        "inflate:         literal 0x%02x\n", here.val));
                        state.mode = LIT;
                        break;
                    }
                    if (here_op & 32) {
                        //Tracevv((stderr, "inflate:         end of block\n"));
                        state.back = -1;
                        state.mode = TYPE;
                        break;
                    }
                    if (here_op & 64) {
                        strm.msg = 'invalid literal/length code';
                        state.mode = BAD;
                        break;
                    }
                    state.extra = here_op & 15;
                    state.mode = LENEXT;
                /* falls through */
                case LENEXT:
                    if (state.extra) {
                        //=== NEEDBITS(state.extra);
                        n = state.extra;
                        while (bits < n) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
                        //--- DROPBITS(state.extra) ---//
                        hold >>>= state.extra;
                        bits -= state.extra;
                        //---//
                        state.back += state.extra;
                    }
                    //Tracevv((stderr, "inflate:         length %u\n", state.length));
                    state.was = state.length;
                    state.mode = DIST;
                /* falls through */
                case DIST:
                    for (; ;) {
                        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
                        here_bits = here >>> 24;
                        here_op = (here >>> 16) & 0xff;
                        here_val = here & 0xffff;

                        if ((here_bits) <= bits) { break; }
                        //--- PULLBYTE() ---//
                        if (have === 0) { break inf_leave; }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                        //---//
                    }
                    if ((here_op & 0xf0) === 0) {
                        last_bits = here_bits;
                        last_op = here_op;
                        last_val = here_val;
                        for (; ;) {
                            here = state.distcode[last_val +
                                ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = (here >>> 16) & 0xff;
                            here_val = here & 0xffff;

                            if ((last_bits + here_bits) <= bits) { break; }
                            //--- PULLBYTE() ---//
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                            //---//
                        }
                        //--- DROPBITS(last.bits) ---//
                        hold >>>= last_bits;
                        bits -= last_bits;
                        //---//
                        state.back += last_bits;
                    }
                    //--- DROPBITS(here.bits) ---//
                    hold >>>= here_bits;
                    bits -= here_bits;
                    //---//
                    state.back += here_bits;
                    if (here_op & 64) {
                        strm.msg = 'invalid distance code';
                        state.mode = BAD;
                        break;
                    }
                    state.offset = here_val;
                    state.extra = (here_op) & 15;
                    state.mode = DISTEXT;
                /* falls through */
                case DISTEXT:
                    if (state.extra) {
                        //=== NEEDBITS(state.extra);
                        n = state.extra;
                        while (bits < n) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
                        //--- DROPBITS(state.extra) ---//
                        hold >>>= state.extra;
                        bits -= state.extra;
                        //---//
                        state.back += state.extra;
                    }
                    //#ifdef INFLATE_STRICT
                    if (state.offset > state.dmax) {
                        strm.msg = 'invalid distance too far back';
                        state.mode = BAD;
                        break;
                    }
                    //#endif
                    //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
                    state.mode = MATCH;
                /* falls through */
                case MATCH:
                    if (left === 0) { break inf_leave; }
                    copy = _out - left;
                    if (state.offset > copy) {         /* copy from window */
                        copy = state.offset - copy;
                        if (copy > state.whave) {
                            if (state.sane) {
                                strm.msg = 'invalid distance too far back';
                                state.mode = BAD;
                                break;
                            }
                            // (!) This block is disabled in zlib defaults,
                            // don't enable it for binary compatibility
                            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                            //          Trace((stderr, "inflate.c too far\n"));
                            //          copy -= state.whave;
                            //          if (copy > state.length) { copy = state.length; }
                            //          if (copy > left) { copy = left; }
                            //          left -= copy;
                            //          state.length -= copy;
                            //          do {
                            //            output[put++] = 0;
                            //          } while (--copy);
                            //          if (state.length === 0) { state.mode = LEN; }
                            //          break;
                            //#endif
                        }
                        if (copy > state.wnext) {
                            copy -= state.wnext;
                            from = state.wsize - copy;
                        }
                        else {
                            from = state.wnext - copy;
                        }
                        if (copy > state.length) { copy = state.length; }
                        from_source = state.window;
                    }
                    else {                              /* copy from output */
                        from_source = output;
                        from = put - state.offset;
                        copy = state.length;
                    }
                    if (copy > left) { copy = left; }
                    left -= copy;
                    state.length -= copy;
                    do {
                        output[put++] = from_source[from++];
                    } while (--copy);
                    if (state.length === 0) { state.mode = LEN; }
                    break;
                case LIT:
                    if (left === 0) { break inf_leave; }
                    output[put++] = state.length;
                    left--;
                    state.mode = LEN;
                    break;
                case CHECK:
                    if (state.wrap) {
                        //=== NEEDBITS(32);
                        while (bits < 32) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            // Use '|' instead of '+' to make sure that result is signed
                            hold |= input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        _out -= left;
                        strm.total_out += _out;
                        state.total += _out;
                        if ((state.wrap & 4) && _out) {
                            strm.adler = state.check =
                                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

                        }
                        _out = left;
                        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
                        if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
                            strm.msg = 'incorrect data check';
                            state.mode = BAD;
                            break;
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        //Tracev((stderr, "inflate:   check matches trailer\n"));
                    }
                    state.mode = LENGTH;
                /* falls through */
                case LENGTH:
                    if (state.wrap && state.flags) {
                        //=== NEEDBITS(32);
                        while (bits < 32) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
                            strm.msg = 'incorrect length check';
                            state.mode = BAD;
                            break;
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        //Tracev((stderr, "inflate:   length matches trailer\n"));
                    }
                    state.mode = DONE;
                /* falls through */
                case DONE:
                    ret = Z_STREAM_END$1;
                    break inf_leave;
                case BAD:
                    ret = Z_DATA_ERROR$1;
                    break inf_leave;
                case MEM:
                    return Z_MEM_ERROR$1;
                case SYNC:
                /* falls through */
                default:
                    return Z_STREAM_ERROR$1;
            }
        }

        // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

        /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */

        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---

        if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
            (state.mode < CHECK || flush !== Z_FINISH$1))) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out));
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if ((state.wrap & 4) && _out) {
            strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) +
            (state.mode === TYPE ? 128 : 0) +
            (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
            ret = Z_BUF_ERROR;
        }
        return ret;
    };


    const inflateEnd = (strm) => {

        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }

        let state = strm.state;
        if (state.window) {
            state.window = null;
        }
        strm.state = null;
        return Z_OK$1;
    };


    const inflateGetHeader = (strm, head) => {

        /* check state */
        if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
        const state = strm.state;
        if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

        /* save header structure */
        state.head = head;
        head.done = false;
        return Z_OK$1;
    };


    const inflateSetDictionary = (strm, dictionary) => {
        const dictLength = dictionary.length;

        let state;
        let dictid;
        let ret;

        /* check state */
        if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
        state = strm.state;

        if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR$1;
        }

        /* check for correct dictionary identifier */
        if (state.mode === DICT) {
            dictid = 1; /* adler32(0, null, 0)*/
            /* dictid = adler32(dictid, dictionary, dictLength); */
            dictid = adler32_1(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
                return Z_DATA_ERROR$1;
            }
        }
        /* copy dictionary to window using updatewindow(), which will amend the
     existing dictionary if appropriate */
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR$1;
        }
        state.havedict = 1;
        // Tracev((stderr, "inflate:   dictionary set\n"));
        return Z_OK$1;
    };


    var inflateReset_1 = inflateReset;
    var inflateReset2_1 = inflateReset2;
    var inflateResetKeep_1 = inflateResetKeep;
    var inflateInit_1 = inflateInit;
    var inflateInit2_1 = inflateInit2;
    var inflate_2$1 = inflate$2;
    var inflateEnd_1 = inflateEnd;
    var inflateGetHeader_1 = inflateGetHeader;
    var inflateSetDictionary_1 = inflateSetDictionary;
    var inflateInfo = 'pako inflate (from Nodeca project)';

    /* Not implemented
  module.exports.inflateCodesUsed = inflateCodesUsed;
  module.exports.inflateCopy = inflateCopy;
  module.exports.inflateGetDictionary = inflateGetDictionary;
  module.exports.inflateMark = inflateMark;
  module.exports.inflatePrime = inflatePrime;
  module.exports.inflateSync = inflateSync;
  module.exports.inflateSyncPoint = inflateSyncPoint;
  module.exports.inflateUndermine = inflateUndermine;
  module.exports.inflateValidate = inflateValidate;
  */

    var inflate_1$2 = {
        inflateReset: inflateReset_1,
        inflateReset2: inflateReset2_1,
        inflateResetKeep: inflateResetKeep_1,
        inflateInit: inflateInit_1,
        inflateInit2: inflateInit2_1,
        inflate: inflate_2$1,
        inflateEnd: inflateEnd_1,
        inflateGetHeader: inflateGetHeader_1,
        inflateSetDictionary: inflateSetDictionary_1,
        inflateInfo: inflateInfo
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    function GZheader() {
        /* true if compressed data believed to be text */
        this.text = 0;
        /* modification time */
        this.time = 0;
        /* extra flags (not used when writing a gzip file) */
        this.xflags = 0;
        /* operating system */
        this.os = 0;
        /* pointer to extra field or Z_NULL if none */
        this.extra = null;
        /* extra field length (valid if extra != Z_NULL) */
        this.extra_len = 0; // Actually, we don't need it in JS,
        // but leave for few code modifications

        //
        // Setup limits is not necessary because in js we should not preallocate memory
        // for inflate use constant limit in 65536 bytes
        //

        /* space at extra (only when reading header) */
        // this.extra_max  = 0;
        /* pointer to zero-terminated file name or Z_NULL */
        this.name = '';
        /* space at name (only when reading header) */
        // this.name_max   = 0;
        /* pointer to zero-terminated comment or Z_NULL */
        this.comment = '';
        /* space at comment (only when reading header) */
        // this.comm_max   = 0;
        /* true if there was or will be a header crc */
        this.hcrc = 0;
        /* true when done reading gzip header (not used when writing a gzip file) */
        this.done = false;
    }

    var gzheader = GZheader;

    const toString = Object.prototype.toString;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    const {
        Z_NO_FLUSH, Z_FINISH,
        Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
    } = constants$2;

    /* ===========================================================================*/


    /**
     * class Inflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[inflate]]
     * and [[inflateRaw]].
     **/

    /* internal
   * inflate.chunks -> Array
   *
   * Chunks of output data, if [[Inflate#onData]] not overridden.
   **/

    /**
     * Inflate.result -> Uint8Array|String
     *
     * Uncompressed result, generated by default [[Inflate#onData]]
     * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
     **/

    /**
     * Inflate.err -> Number
     *
     * Error code after inflate finished. 0 (Z_OK) on success.
     * Should be checked if broken data possible.
     **/

    /**
     * Inflate.msg -> String
     *
     * Error message, if [[Inflate.err]] != 0
     **/


    /**
     * new Inflate(options)
     * - options (Object): zlib inflate options.
     *
     * Creates new inflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `windowBits`
     * - `dictionary`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * - `chunkSize` - size of generated data chunks (16K by default)
     * - `raw` (Boolean) - do raw inflate
     * - `to` (String) - if equal to 'string', then result will be converted
     *   from utf8 to utf16 (javascript) string. When string output requested,
     *   chunk length can differ from `chunkSize`, depending on content.
     *
     * By default, when no options set, autodetect deflate/gzip data format via
     * wrapper header.
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako')
     * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
     * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * const inflate = new pako.Inflate({ level: 3});
     *
     * inflate.push(chunk1, false);
     * inflate.push(chunk2, true);  // true -> last chunk
     *
     * if (inflate.err) { throw new Error(inflate.err); }
     *
     * console.log(inflate.result);
     * ```
     **/
    function Inflate$1(options) {
        this.options = common.assign({
            chunkSize: 1024 * 64,
            windowBits: 15,
            to: ''
        }, options || {});

        const opt = this.options;

        // Force window size for `raw` data, if not set directly,
        // because we have no header for autodetect.
        if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) { opt.windowBits = -15; }
        }

        // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
        if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
            !(options && options.windowBits)) {
            opt.windowBits += 32;
        }

        // Gzip header has no info about windows size, we can do autodetect only
        // for deflate. So, if window size not set, force it to max when gzip possible
        if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
            // bit 3 (16) -> gzipped data
            // bit 4 (32) -> autodetect gzip/deflate
            if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
            }
        }

        this.err = 0;      // error code, if happens (0 = Z_OK)
        this.msg = '';     // error message
        this.ended = false;  // used to avoid multiple onEnd() calls
        this.chunks = [];     // chunks of compressed data

        this.strm = new zstream();
        this.strm.avail_out = 0;

        let status = inflate_1$2.inflateInit2(
            this.strm,
            opt.windowBits
        );

        if (status !== Z_OK) {
            throw new Error(messages[status]);
        }

        this.header = new gzheader();

        inflate_1$2.inflateGetHeader(this.strm, this.header);

        // Setup dictionary
        if (opt.dictionary) {
            // Convert data if needed
            if (typeof opt.dictionary === 'string') {
                opt.dictionary = strings.string2buf(opt.dictionary);
            } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
                opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) { //In raw mode we need to set the dictionary early
                status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
                if (status !== Z_OK) {
                    throw new Error(messages[status]);
                }
            }
        }
    }

    /**
     * Inflate#push(data[, flush_mode]) -> Boolean
     * - data (Uint8Array|ArrayBuffer): input data
     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
     *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
     *   `true` means Z_FINISH.
     *
     * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
     * new output chunks. Returns `true` on success. If end of stream detected,
     * [[Inflate#onEnd]] will be called.
     *
     * `flush_mode` is not needed for normal operation, because end of stream
     * detected automatically. You may try to use it for advanced things, but
     * this functionality was not tested.
     *
     * On fail call [[Inflate#onEnd]] with error code and return false.
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     **/
    Inflate$1.prototype.push = function (data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;

        if (this.ended) return false;

        if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
        else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

        // Convert data if needed
        if (toString.call(data) === '[object ArrayBuffer]') {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }

        strm.next_in = 0;
        strm.avail_in = strm.input.length;

        for (; ;) {
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }

            status = inflate_1$2.inflate(strm, _flush_mode);

            if (status === Z_NEED_DICT && dictionary) {
                status = inflate_1$2.inflateSetDictionary(strm, dictionary);

                if (status === Z_OK) {
                    status = inflate_1$2.inflate(strm, _flush_mode);
                } else if (status === Z_DATA_ERROR) {
                    // Replace code with more verbose
                    status = Z_NEED_DICT;
                }
            }

            // Skip snyc markers if more data follows and not raw mode
            while (strm.avail_in > 0 &&
                status === Z_STREAM_END &&
                strm.state.wrap > 0 &&
                data[strm.next_in] !== 0) {
                inflate_1$2.inflateReset(strm);
                status = inflate_1$2.inflate(strm, _flush_mode);
            }

            switch (status) {
                case Z_STREAM_ERROR:
                case Z_DATA_ERROR:
                case Z_NEED_DICT:
                case Z_MEM_ERROR:
                    this.onEnd(status);
                    this.ended = true;
                    return false;
            }

            // Remember real `avail_out` value, because we may patch out buffer content
            // to align utf8 strings boundaries.
            last_avail_out = strm.avail_out;

            if (strm.next_out) {
                if (strm.avail_out === 0 || status === Z_STREAM_END) {

                    if (this.options.to === 'string') {

                        let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

                        let tail = strm.next_out - next_out_utf8;
                        let utf8str = strings.buf2string(strm.output, next_out_utf8);

                        // move tail & realign counters
                        strm.next_out = tail;
                        strm.avail_out = chunkSize - tail;
                        if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

                        this.onData(utf8str);

                    } else {
                        this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                    }
                }
            }

            // Must repeat iteration if out buffer is full
            if (status === Z_OK && last_avail_out === 0) continue;

            // Finalize if end of stream reached.
            if (status === Z_STREAM_END) {
                status = inflate_1$2.inflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return true;
            }

            if (strm.avail_in === 0) break;
        }

        return true;
    };


    /**
     * Inflate#onData(chunk) -> Void
     * - chunk (Uint8Array|String): output data. When string output requested,
     *   each chunk will be string.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     **/
    Inflate$1.prototype.onData = function (chunk) {
        this.chunks.push(chunk);
    };


    /**
     * Inflate#onEnd(status) -> Void
     * - status (Number): inflate status. 0 (Z_OK) on success,
     *   other if not.
     *
     * Called either after you tell inflate that the input stream is
     * complete (Z_FINISH). By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     **/
    Inflate$1.prototype.onEnd = function (status) {
        // On success - join
        if (status === Z_OK) {
            if (this.options.to === 'string') {
                this.result = this.chunks.join('');
            } else {
                this.result = common.flattenChunks(this.chunks);
            }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };


    /**
     * inflate(data[, options]) -> Uint8Array|String
     * - data (Uint8Array|ArrayBuffer): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * Decompress `data` with inflate/ungzip and `options`. Autodetect
     * format via wrapper header by default. That's why we don't provide
     * separate `ungzip` method.
     *
     * Supported options are:
     *
     * - windowBits
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information.
     *
     * Sugar (options):
     *
     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
     *   negative windowBits implicitly.
     * - `to` (String) - if equal to 'string', then result will be converted
     *   from utf8 to utf16 (javascript) string. When string output requested,
     *   chunk length can differ from `chunkSize`, depending on content.
     *
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako');
     * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
     * let output;
     *
     * try {
     *   output = pako.inflate(input);
     * } catch (err) {
     *   console.log(err);
     * }
     * ```
     **/
    function inflate$1(input, options) {
        const inflator = new Inflate$1(options);

        inflator.push(input);

        // That will never happens, if you don't cheat with options :)
        if (inflator.err) throw inflator.msg || messages[inflator.err];

        return inflator.result;
    }


    /**
     * inflateRaw(data[, options]) -> Uint8Array|String
     * - data (Uint8Array|ArrayBuffer): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * The same as [[inflate]], but creates raw data, without wrapper
     * (header and adler32 crc).
     **/
    function inflateRaw$1(input, options) {
        options = options || {};
        options.raw = true;
        return inflate$1(input, options);
    }


    /**
     * ungzip(data[, options]) -> Uint8Array|String
     * - data (Uint8Array|ArrayBuffer): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * Just shortcut to [[inflate]], because it autodetects format
     * by header.content. Done for convenience.
     **/


    var Inflate_1$1 = Inflate$1;
    var inflate_2 = inflate$1;
    var inflateRaw_1$1 = inflateRaw$1;
    var ungzip$1 = inflate$1;
    var constants = constants$2;

    var inflate_1$1 = {
        Inflate: Inflate_1$1,
        inflate: inflate_2,
        inflateRaw: inflateRaw_1$1,
        ungzip: ungzip$1,
        constants: constants
    };

    const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

    const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



    var Deflate_1 = Deflate;
    var deflate_1 = deflate;
    var deflateRaw_1 = deflateRaw;
    var gzip_1 = gzip;
    var Inflate_1 = Inflate;
    var inflate_1 = inflate;
    var inflateRaw_1 = inflateRaw;
    var ungzip_1 = ungzip;
    var constants_1 = constants$2;

    var pako = {
        Deflate: Deflate_1,
        deflate: deflate_1,
        deflateRaw: deflateRaw_1,
        gzip: gzip_1,
        Inflate: Inflate_1,
        inflate: inflate_1,
        inflateRaw: inflateRaw_1,
        ungzip: ungzip_1,
        constants: constants_1
    };

    exports.Deflate = Deflate_1;
    exports.Inflate = Inflate_1;
    exports.constants = constants_1;
    exports["default"] = pako;
    exports.deflate = deflate_1;
    exports.deflateRaw = deflateRaw_1;
    exports.gzip = gzip_1;
    exports.inflate = inflate_1;
    exports.inflateRaw = inflateRaw_1;
    exports.ungzip = ungzip_1;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
/*!

 handlebars v4.0.5

Copyright (C) 2011-2015 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else if (typeof exports === 'object')
        exports["Handlebars"] = factory();
    else
        root["Handlebars"] = factory();
})(this, function () {
    return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
                /******/
            };

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
            /******/
        }


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
        /******/
    })
/************************************************************************/
/******/([
/* 0 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _handlebarsRuntime = __webpack_require__(2);

            var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

            // Compiler imports

            var _handlebarsCompilerAst = __webpack_require__(21);

            var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

            var _handlebarsCompilerBase = __webpack_require__(22);

            var _handlebarsCompilerCompiler = __webpack_require__(27);

            var _handlebarsCompilerJavascriptCompiler = __webpack_require__(28);

            var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

            var _handlebarsCompilerVisitor = __webpack_require__(25);

            var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

            var _handlebarsNoConflict = __webpack_require__(20);

            var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

            var _create = _handlebarsRuntime2['default'].create;
            function create() {
                var hb = _create();

                hb.compile = function (input, options) {
                    return _handlebarsCompilerCompiler.compile(input, options, hb);
                };
                hb.precompile = function (input, options) {
                    return _handlebarsCompilerCompiler.precompile(input, options, hb);
                };

                hb.AST = _handlebarsCompilerAst2['default'];
                hb.Compiler = _handlebarsCompilerCompiler.Compiler;
                hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
                hb.Parser = _handlebarsCompilerBase.parser;
                hb.parse = _handlebarsCompilerBase.parse;

                return hb;
            }

            var inst = create();
            inst.create = create;

            _handlebarsNoConflict2['default'](inst);

            inst.Visitor = _handlebarsCompilerVisitor2['default'];

            inst['default'] = inst;

            exports['default'] = inst;
            module.exports = exports['default'];

            /***/
        },
/* 1 */
/***/ function (module, exports) {

            "use strict";

            exports["default"] = function (obj) {
                return obj && obj.__esModule ? obj : {
                    "default": obj
                };
            };

            exports.__esModule = true;

            /***/
        },
/* 2 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _handlebarsBase = __webpack_require__(4);

            var base = _interopRequireWildcard(_handlebarsBase);

            // Each of these augment the Handlebars object. No need to setup here.
            // (This is done to easily share code between commonjs and browse envs)

            var _handlebarsSafeString = __webpack_require__(18);

            var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

            var _handlebarsException = __webpack_require__(6);

            var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

            var _handlebarsUtils = __webpack_require__(5);

            var Utils = _interopRequireWildcard(_handlebarsUtils);

            var _handlebarsRuntime = __webpack_require__(19);

            var runtime = _interopRequireWildcard(_handlebarsRuntime);

            var _handlebarsNoConflict = __webpack_require__(20);

            var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

            // For compatibility and usage outside of module systems, make the Handlebars object a namespace
            function create() {
                var hb = new base.HandlebarsEnvironment();

                Utils.extend(hb, base);
                hb.SafeString = _handlebarsSafeString2['default'];
                hb.Exception = _handlebarsException2['default'];
                hb.Utils = Utils;
                hb.escapeExpression = Utils.escapeExpression;

                hb.VM = runtime;
                hb.template = function (spec) {
                    return runtime.template(spec, hb);
                };

                return hb;
            }

            var inst = create();
            inst.create = create;

            _handlebarsNoConflict2['default'](inst);

            inst['default'] = inst;

            exports['default'] = inst;
            module.exports = exports['default'];

            /***/
        },
/* 3 */
/***/ function (module, exports) {

            "use strict";

            exports["default"] = function (obj) {
                if (obj && obj.__esModule) {
                    return obj;
                } else {
                    var newObj = {};

                    if (obj != null) {
                        for (var key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                        }
                    }

                    newObj["default"] = obj;
                    return newObj;
                }
            };

            exports.__esModule = true;

            /***/
        },
/* 4 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.HandlebarsEnvironment = HandlebarsEnvironment;

            var _utils = __webpack_require__(5);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _helpers = __webpack_require__(7);

            var _decorators = __webpack_require__(15);

            var _logger = __webpack_require__(17);

            var _logger2 = _interopRequireDefault(_logger);

            var VERSION = '4.0.5';
            exports.VERSION = VERSION;
            var COMPILER_REVISION = 7;

            exports.COMPILER_REVISION = COMPILER_REVISION;
            var REVISION_CHANGES = {
                1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
                2: '== 1.0.0-rc.3',
                3: '== 1.0.0-rc.4',
                4: '== 1.x.x',
                5: '== 2.0.0-alpha.x',
                6: '>= 2.0.0-beta.1',
                7: '>= 4.0.0'
            };

            exports.REVISION_CHANGES = REVISION_CHANGES;
            var objectType = '[object Object]';

            function HandlebarsEnvironment(helpers, partials, decorators) {
                this.helpers = helpers || {};
                this.partials = partials || {};
                this.decorators = decorators || {};

                _helpers.registerDefaultHelpers(this);
                _decorators.registerDefaultDecorators(this);
            }

            HandlebarsEnvironment.prototype = {
                constructor: HandlebarsEnvironment,

                logger: _logger2['default'],
                log: _logger2['default'].log,

                registerHelper: function registerHelper(name, fn) {
                    if (_utils.toString.call(name) === objectType) {
                        if (fn) {
                            throw new _exception2['default']('Arg not supported with multiple helpers');
                        }
                        _utils.extend(this.helpers, name);
                    } else {
                        this.helpers[name] = fn;
                    }
                },
                unregisterHelper: function unregisterHelper(name) {
                    delete this.helpers[name];
                },

                registerPartial: function registerPartial(name, partial) {
                    if (_utils.toString.call(name) === objectType) {
                        _utils.extend(this.partials, name);
                    } else {
                        if (typeof partial === 'undefined') {
                            throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
                        }
                        this.partials[name] = partial;
                    }
                },
                unregisterPartial: function unregisterPartial(name) {
                    delete this.partials[name];
                },

                registerDecorator: function registerDecorator(name, fn) {
                    if (_utils.toString.call(name) === objectType) {
                        if (fn) {
                            throw new _exception2['default']('Arg not supported with multiple decorators');
                        }
                        _utils.extend(this.decorators, name);
                    } else {
                        this.decorators[name] = fn;
                    }
                },
                unregisterDecorator: function unregisterDecorator(name) {
                    delete this.decorators[name];
                }
            };

            var log = _logger2['default'].log;

            exports.log = log;
            exports.createFrame = _utils.createFrame;
            exports.logger = _logger2['default'];

            /***/
        },
/* 5 */
/***/ function (module, exports) {

            'use strict';

            exports.__esModule = true;
            exports.extend = extend;
            exports.indexOf = indexOf;
            exports.escapeExpression = escapeExpression;
            exports.isEmpty = isEmpty;
            exports.createFrame = createFrame;
            exports.blockParams = blockParams;
            exports.appendContextPath = appendContextPath;
            var escape = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '`': '&#x60;',
                '=': '&#x3D;'
            };

            var badChars = /[&<>"'`=]/g,
                possible = /[&<>"'`=]/;

            function escapeChar(chr) {
                return escape[chr];
            }

            function extend(obj /* , ...source */) {
                for (var i = 1; i < arguments.length; i++) {
                    for (var key in arguments[i]) {
                        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                            obj[key] = arguments[i][key];
                        }
                    }
                }

                return obj;
            }

            var toString = Object.prototype.toString;

            exports.toString = toString;
            // Sourced from lodash
            // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
            /* eslint-disable func-style */
            var isFunction = function isFunction(value) {
                return typeof value === 'function';
            };
            // fallback for older versions of Chrome and Safari
            /* istanbul ignore next */
            if (isFunction(/x/)) {
                exports.isFunction = isFunction = function (value) {
                    return typeof value === 'function' && toString.call(value) === '[object Function]';
                };
            }
            exports.isFunction = isFunction;

            /* eslint-enable func-style */

            /* istanbul ignore next */
            var isArray = Array.isArray || function (value) {
                return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
            };

            exports.isArray = isArray;
            // Older IE versions do not directly support indexOf so we must implement our own, sadly.

            function indexOf(array, value) {
                for (var i = 0, len = array.length; i < len; i++) {
                    if (array[i] === value) {
                        return i;
                    }
                }
                return -1;
            }

            function escapeExpression(string) {
                if (typeof string !== 'string') {
                    // don't escape SafeStrings, since they're already safe
                    if (string && string.toHTML) {
                        return string.toHTML();
                    } else if (string == null) {
                        return '';
                    } else if (!string) {
                        return string + '';
                    }

                    // Force a string conversion as this will be done by the append regardless and
                    // the regex test will do this transparently behind the scenes, causing issues if
                    // an object's to string has escaped characters in it.
                    string = '' + string;
                }

                if (!possible.test(string)) {
                    return string;
                }
                return string.replace(badChars, escapeChar);
            }

            function isEmpty(value) {
                if (!value && value !== 0) {
                    return true;
                } else if (isArray(value) && value.length === 0) {
                    return true;
                } else {
                    return false;
                }
            }

            function createFrame(object) {
                var frame = extend({}, object);
                frame._parent = object;
                return frame;
            }

            function blockParams(params, ids) {
                params.path = ids;
                return params;
            }

            function appendContextPath(contextPath, id) {
                return (contextPath ? contextPath + '.' : '') + id;
            }

            /***/
        },
/* 6 */
/***/ function (module, exports) {

            'use strict';

            exports.__esModule = true;

            var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

            function Exception(message, node) {
                var loc = node && node.loc,
                    line = undefined,
                    column = undefined;
                if (loc) {
                    line = loc.start.line;
                    column = loc.start.column;

                    message += ' - ' + line + ':' + column;
                }

                var tmp = Error.prototype.constructor.call(this, message);

                // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
                for (var idx = 0; idx < errorProps.length; idx++) {
                    this[errorProps[idx]] = tmp[errorProps[idx]];
                }

                /* istanbul ignore else */
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, Exception);
                }

                if (loc) {
                    this.lineNumber = line;
                    this.column = column;
                }
            }

            Exception.prototype = new Error();

            exports['default'] = Exception;
            module.exports = exports['default'];

            /***/
        },
/* 7 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.registerDefaultHelpers = registerDefaultHelpers;

            var _helpersBlockHelperMissing = __webpack_require__(8);

            var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

            var _helpersEach = __webpack_require__(9);

            var _helpersEach2 = _interopRequireDefault(_helpersEach);

            var _helpersHelperMissing = __webpack_require__(10);

            var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

            var _helpersIf = __webpack_require__(11);

            var _helpersIf2 = _interopRequireDefault(_helpersIf);

            var _helpersLog = __webpack_require__(12);

            var _helpersLog2 = _interopRequireDefault(_helpersLog);

            var _helpersLookup = __webpack_require__(13);

            var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

            var _helpersWith = __webpack_require__(14);

            var _helpersWith2 = _interopRequireDefault(_helpersWith);

            function registerDefaultHelpers(instance) {
                _helpersBlockHelperMissing2['default'](instance);
                _helpersEach2['default'](instance);
                _helpersHelperMissing2['default'](instance);
                _helpersIf2['default'](instance);
                _helpersLog2['default'](instance);
                _helpersLookup2['default'](instance);
                _helpersWith2['default'](instance);
            }

            /***/
        },
/* 8 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('blockHelperMissing', function (context, options) {
                    var inverse = options.inverse,
                        fn = options.fn;

                    if (context === true) {
                        return fn(this);
                    } else if (context === false || context == null) {
                        return inverse(this);
                    } else if (_utils.isArray(context)) {
                        if (context.length > 0) {
                            if (options.ids) {
                                options.ids = [options.name];
                            }

                            return instance.helpers.each(context, options);
                        } else {
                            return inverse(this);
                        }
                    } else {
                        if (options.data && options.ids) {
                            var data = _utils.createFrame(options.data);
                            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
                            options = { data: data };
                        }

                        return fn(context, options);
                    }
                });
            };

            module.exports = exports['default'];

            /***/
        },
/* 9 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            exports['default'] = function (instance) {
                instance.registerHelper('each', function (context, options) {
                    if (!options) {
                        throw new _exception2['default']('Must pass iterator to #each');
                    }

                    var fn = options.fn,
                        inverse = options.inverse,
                        i = 0,
                        ret = '',
                        data = undefined,
                        contextPath = undefined;

                    if (options.data && options.ids) {
                        contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
                    }

                    if (_utils.isFunction(context)) {
                        context = context.call(this);
                    }

                    if (options.data) {
                        data = _utils.createFrame(options.data);
                    }

                    function execIteration(field, index, last) {
                        if (data) {
                            data.key = field;
                            data.index = index;
                            data.first = index === 0;
                            data.last = !!last;

                            if (contextPath) {
                                data.contextPath = contextPath + field;
                            }
                        }

                        ret = ret + fn(context[field], {
                            data: data,
                            blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
                        });
                    }

                    if (context && typeof context === 'object') {
                        if (_utils.isArray(context)) {
                            for (var j = context.length; i < j; i++) {
                                if (i in context) {
                                    execIteration(i, i, i === context.length - 1);
                                }
                            }
                        } else {
                            var priorKey = undefined;

                            for (var key in context) {
                                if (context.hasOwnProperty(key)) {
                                    // We're running the iterations one step out of sync so we can detect
                                    // the last iteration without have to scan the object twice and create
                                    // an itermediate keys array.
                                    if (priorKey !== undefined) {
                                        execIteration(priorKey, i - 1);
                                    }
                                    priorKey = key;
                                    i++;
                                }
                            }
                            if (priorKey !== undefined) {
                                execIteration(priorKey, i - 1, true);
                            }
                        }
                    }

                    if (i === 0) {
                        ret = inverse(this);
                    }

                    return ret;
                });
            };

            module.exports = exports['default'];

            /***/
        },
/* 10 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            exports['default'] = function (instance) {
                instance.registerHelper('helperMissing', function () /* [args, ]options */ {
                    if (arguments.length === 1) {
                        // A missing field in a {{foo}} construct.
                        return undefined;
                    } else {
                        // Someone is actually trying to call something, blow up.
                        throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                    }
                });
            };

            module.exports = exports['default'];

            /***/
        },
/* 11 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('if', function (conditional, options) {
                    if (_utils.isFunction(conditional)) {
                        conditional = conditional.call(this);
                    }

                    // Default behavior is to render the positive path if the value is truthy and not empty.
                    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
                        return options.inverse(this);
                    } else {
                        return options.fn(this);
                    }
                });

                instance.registerHelper('unless', function (conditional, options) {
                    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
                });
            };

            module.exports = exports['default'];

            /***/
        },
/* 12 */
/***/ function (module, exports) {

            'use strict';

            exports.__esModule = true;

            exports['default'] = function (instance) {
                instance.registerHelper('log', function () /* message, options */ {
                    var args = [undefined],
                        options = arguments[arguments.length - 1];
                    for (var i = 0; i < arguments.length - 1; i++) {
                        args.push(arguments[i]);
                    }

                    var level = 1;
                    if (options.hash.level != null) {
                        level = options.hash.level;
                    } else if (options.data && options.data.level != null) {
                        level = options.data.level;
                    }
                    args[0] = level;

                    instance.log.apply(instance, args);
                });
            };

            module.exports = exports['default'];

            /***/
        },
/* 13 */
/***/ function (module, exports) {

            'use strict';

            exports.__esModule = true;

            exports['default'] = function (instance) {
                instance.registerHelper('lookup', function (obj, field) {
                    return obj && obj[field];
                });
            };

            module.exports = exports['default'];

            /***/
        },
/* 14 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('with', function (context, options) {
                    if (_utils.isFunction(context)) {
                        context = context.call(this);
                    }

                    var fn = options.fn;

                    if (!_utils.isEmpty(context)) {
                        var data = options.data;
                        if (options.data && options.ids) {
                            data = _utils.createFrame(options.data);
                            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
                        }

                        return fn(context, {
                            data: data,
                            blockParams: _utils.blockParams([context], [data && data.contextPath])
                        });
                    } else {
                        return options.inverse(this);
                    }
                });
            };

            module.exports = exports['default'];

            /***/
        },
/* 15 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.registerDefaultDecorators = registerDefaultDecorators;

            var _decoratorsInline = __webpack_require__(16);

            var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

            function registerDefaultDecorators(instance) {
                _decoratorsInline2['default'](instance);
            }

            /***/
        },
/* 16 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerDecorator('inline', function (fn, props, container, options) {
                    var ret = fn;
                    if (!props.partials) {
                        props.partials = {};
                        ret = function (context, options) {
                            // Create a new partials stack frame prior to exec.
                            var original = container.partials;
                            container.partials = _utils.extend({}, original, props.partials);
                            var ret = fn(context, options);
                            container.partials = original;
                            return ret;
                        };
                    }

                    props.partials[options.args[0]] = options.fn;

                    return ret;
                });
            };

            module.exports = exports['default'];

            /***/
        },
/* 17 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var logger = {
                methodMap: ['debug', 'info', 'warn', 'error'],
                level: 'info',

                // Maps a given level value to the `methodMap` indexes above.
                lookupLevel: function lookupLevel(level) {
                    if (typeof level === 'string') {
                        var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
                        if (levelMap >= 0) {
                            level = levelMap;
                        } else {
                            level = parseInt(level, 10);
                        }
                    }

                    return level;
                },

                // Can be overridden in the host environment
                log: function log(level) {
                    level = logger.lookupLevel(level);

                    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
                        var method = logger.methodMap[level];
                        if (!console[method]) {
                            // eslint-disable-line no-console
                            method = 'log';
                        }

                        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            message[_key - 1] = arguments[_key];
                        }

                        console[method].apply(console, message); // eslint-disable-line no-console
                    }
                }
            };

            exports['default'] = logger;
            module.exports = exports['default'];

            /***/
        },
/* 18 */
/***/ function (module, exports) {

            // Build out our basic SafeString type
            'use strict';

            exports.__esModule = true;
            function SafeString(string) {
                this.string = string;
            }

            SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
                return '' + this.string;
            };

            exports['default'] = SafeString;
            module.exports = exports['default'];

            /***/
        },
/* 19 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.checkRevision = checkRevision;
            exports.template = template;
            exports.wrapProgram = wrapProgram;
            exports.resolvePartial = resolvePartial;
            exports.invokePartial = invokePartial;
            exports.noop = noop;

            var _utils = __webpack_require__(5);

            var Utils = _interopRequireWildcard(_utils);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _base = __webpack_require__(4);

            function checkRevision(compilerInfo) {
                var compilerRevision = compilerInfo && compilerInfo[0] || 1,
                    currentRevision = _base.COMPILER_REVISION;

                if (compilerRevision !== currentRevision) {
                    if (compilerRevision < currentRevision) {
                        var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
                            compilerVersions = _base.REVISION_CHANGES[compilerRevision];
                        throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
                    } else {
                        // Use the embedded version info since the runtime doesn't know about this revision yet
                        throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
                    }
                }
            }

            function template(templateSpec, env) {
                /* istanbul ignore next */
                if (!env) {
                    throw new _exception2['default']('No environment passed to template');
                }
                if (!templateSpec || !templateSpec.main) {
                    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
                }

                templateSpec.main.decorator = templateSpec.main_d;

                // Note: Using env.VM references rather than local var references throughout this section to allow
                // for external users to override these as psuedo-supported APIs.
                env.VM.checkRevision(templateSpec.compiler);

                function invokePartialWrapper(partial, context, options) {
                    if (options.hash) {
                        context = Utils.extend({}, context, options.hash);
                        if (options.ids) {
                            options.ids[0] = true;
                        }
                    }

                    partial = env.VM.resolvePartial.call(this, partial, context, options);
                    var result = env.VM.invokePartial.call(this, partial, context, options);

                    if (result == null && env.compile) {
                        options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
                        result = options.partials[options.name](context, options);
                    }
                    if (result != null) {
                        if (options.indent) {
                            var lines = result.split('\n');
                            for (var i = 0, l = lines.length; i < l; i++) {
                                if (!lines[i] && i + 1 === l) {
                                    break;
                                }

                                lines[i] = options.indent + lines[i];
                            }
                            result = lines.join('\n');
                        }
                        return result;
                    } else {
                        throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
                    }
                }

                // Just add water
                var container = {
                    strict: function strict(obj, name) {
                        if (!(name in obj)) {
                            throw new _exception2['default']('"' + name + '" not defined in ' + obj);
                        }
                        return obj[name];
                    },
                    lookup: function lookup(depths, name) {
                        var len = depths.length;
                        for (var i = 0; i < len; i++) {
                            if (depths[i] && depths[i][name] != null) {
                                return depths[i][name];
                            }
                        }
                    },
                    lambda: function lambda(current, context) {
                        return typeof current === 'function' ? current.call(context) : current;
                    },

                    escapeExpression: Utils.escapeExpression,
                    invokePartial: invokePartialWrapper,

                    fn: function fn(i) {
                        var ret = templateSpec[i];
                        ret.decorator = templateSpec[i + '_d'];
                        return ret;
                    },

                    programs: [],
                    program: function program(i, data, declaredBlockParams, blockParams, depths) {
                        var programWrapper = this.programs[i],
                            fn = this.fn(i);
                        if (data || depths || blockParams || declaredBlockParams) {
                            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                        } else if (!programWrapper) {
                            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                        }
                        return programWrapper;
                    },

                    data: function data(value, depth) {
                        while (value && depth--) {
                            value = value._parent;
                        }
                        return value;
                    },
                    merge: function merge(param, common) {
                        var obj = param || common;

                        if (param && common && param !== common) {
                            obj = Utils.extend({}, common, param);
                        }

                        return obj;
                    },

                    noop: env.VM.noop,
                    compilerInfo: templateSpec.compiler
                };

                function ret(context) {
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    var data = options.data;

                    ret._setup(options);
                    if (!options.partial && templateSpec.useData) {
                        data = initData(context, data);
                    }
                    var depths = undefined,
                        blockParams = templateSpec.useBlockParams ? [] : undefined;
                    if (templateSpec.useDepths) {
                        if (options.depths) {
                            depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
                        } else {
                            depths = [context];
                        }
                    }

                    function main(context /*, options*/) {
                        return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
                    }
                    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
                    return main(context, options);
                }
                ret.isTop = true;

                ret._setup = function (options) {
                    if (!options.partial) {
                        container.helpers = container.merge(options.helpers, env.helpers);

                        if (templateSpec.usePartial) {
                            container.partials = container.merge(options.partials, env.partials);
                        }
                        if (templateSpec.usePartial || templateSpec.useDecorators) {
                            container.decorators = container.merge(options.decorators, env.decorators);
                        }
                    } else {
                        container.helpers = options.helpers;
                        container.partials = options.partials;
                        container.decorators = options.decorators;
                    }
                };

                ret._child = function (i, data, blockParams, depths) {
                    if (templateSpec.useBlockParams && !blockParams) {
                        throw new _exception2['default']('must pass block params');
                    }
                    if (templateSpec.useDepths && !depths) {
                        throw new _exception2['default']('must pass parent depths');
                    }

                    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
                };
                return ret;
            }

            function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
                function prog(context) {
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    var currentDepths = depths;
                    if (depths && context !== depths[0]) {
                        currentDepths = [context].concat(depths);
                    }

                    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
                }

                prog = executeDecorators(fn, prog, container, depths, data, blockParams);

                prog.program = i;
                prog.depth = depths ? depths.length : 0;
                prog.blockParams = declaredBlockParams || 0;
                return prog;
            }

            function resolvePartial(partial, context, options) {
                if (!partial) {
                    if (options.name === '@partial-block') {
                        partial = options.data['partial-block'];
                    } else {
                        partial = options.partials[options.name];
                    }
                } else if (!partial.call && !options.name) {
                    // This is a dynamic partial that returned a string
                    options.name = partial;
                    partial = options.partials[partial];
                }
                return partial;
            }

            function invokePartial(partial, context, options) {
                options.partial = true;
                if (options.ids) {
                    options.data.contextPath = options.ids[0] || options.data.contextPath;
                }

                var partialBlock = undefined;
                if (options.fn && options.fn !== noop) {
                    options.data = _base.createFrame(options.data);
                    partialBlock = options.data['partial-block'] = options.fn;

                    if (partialBlock.partials) {
                        options.partials = Utils.extend({}, options.partials, partialBlock.partials);
                    }
                }

                if (partial === undefined && partialBlock) {
                    partial = partialBlock;
                }

                if (partial === undefined) {
                    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
                } else if (partial instanceof Function) {
                    return partial(context, options);
                }
            }

            function noop() {
                return '';
            }

            function initData(context, data) {
                if (!data || !('root' in data)) {
                    data = data ? _base.createFrame(data) : {};
                    data.root = context;
                }
                return data;
            }

            function executeDecorators(fn, prog, container, depths, data, blockParams) {
                if (fn.decorator) {
                    var props = {};
                    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                    Utils.extend(prog, props);
                }
                return prog;
            }

            /***/
        },
/* 20 */
/***/ function (module, exports) {

	/* WEBPACK VAR INJECTION */(function (global) {/* global window */
                'use strict';

                exports.__esModule = true;

                exports['default'] = function (Handlebars) {
                    /* istanbul ignore next */
                    var root = typeof global !== 'undefined' ? global : window,
                        $Handlebars = root.Handlebars;
                    /* istanbul ignore next */
                    Handlebars.noConflict = function () {
                        if (root.Handlebars === Handlebars) {
                            root.Handlebars = $Handlebars;
                        }
                        return Handlebars;
                    };
                };

                module.exports = exports['default'];
                /* WEBPACK VAR INJECTION */
            }.call(exports, (function () { return this; }())))

            /***/
        },
/* 21 */
/***/ function (module, exports) {

            'use strict';

            exports.__esModule = true;
            var AST = {
                // Public API used to evaluate derived attributes regarding AST nodes
                helpers: {
                    // a mustache is definitely a helper if:
                    // * it is an eligible helper, and
                    // * it has at least one parameter or hash segment
                    helperExpression: function helperExpression(node) {
                        return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
                    },

                    scopedId: function scopedId(path) {
                        return (/^\.|this\b/.test(path.original)
                        );
                    },

                    // an ID is simple if it only has one part, and that part is not
                    // `..` or `this`.
                    simpleId: function simpleId(path) {
                        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
                    }
                }
            };

            // Must be exported as an object rather than the root of the module as the jison lexer
            // must modify the object to operate properly.
            exports['default'] = AST;
            module.exports = exports['default'];

            /***/
        },
/* 22 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            exports.__esModule = true;
            exports.parse = parse;

            var _parser = __webpack_require__(23);

            var _parser2 = _interopRequireDefault(_parser);

            var _whitespaceControl = __webpack_require__(24);

            var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

            var _helpers = __webpack_require__(26);

            var Helpers = _interopRequireWildcard(_helpers);

            var _utils = __webpack_require__(5);

            exports.parser = _parser2['default'];

            var yy = {};
            _utils.extend(yy, Helpers);

            function parse(input, options) {
                // Just return if an already-compiled AST was passed in.
                if (input.type === 'Program') {
                    return input;
                }

                _parser2['default'].yy = yy;

                // Altering the shared object here, but this is ok as parser is a sync operation
                yy.locInfo = function (locInfo) {
                    return new yy.SourceLocation(options && options.srcName, locInfo);
                };

                var strip = new _whitespaceControl2['default'](options);
                return strip.accept(_parser2['default'].parse(input));
            }

            /***/
        },
/* 23 */
/***/ function (module, exports) {

            /* istanbul ignore next */
            /* Jison generated parser */
            "use strict";

            var handlebars = (function () {
                var parser = {
                    trace: function trace() { },
                    yy: {},
                    symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
                    terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
                    productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
                    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
	        /**/) {

                        var $0 = $$.length - 1;
                        switch (yystate) {
                            case 1:
                                return $$[$0 - 1];
                                break;
                            case 2:
                                this.$ = yy.prepareProgram($$[$0]);
                                break;
                            case 3:
                                this.$ = $$[$0];
                                break;
                            case 4:
                                this.$ = $$[$0];
                                break;
                            case 5:
                                this.$ = $$[$0];
                                break;
                            case 6:
                                this.$ = $$[$0];
                                break;
                            case 7:
                                this.$ = $$[$0];
                                break;
                            case 8:
                                this.$ = $$[$0];
                                break;
                            case 9:
                                this.$ = {
                                    type: 'CommentStatement',
                                    value: yy.stripComment($$[$0]),
                                    strip: yy.stripFlags($$[$0], $$[$0]),
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 10:
                                this.$ = {
                                    type: 'ContentStatement',
                                    original: $$[$0],
                                    value: $$[$0],
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 11:
                                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                break;
                            case 12:
                                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                                break;
                            case 13:
                                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                                break;
                            case 14:
                                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                                break;
                            case 15:
                                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                break;
                            case 16:
                                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                break;
                            case 17:
                                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                break;
                            case 18:
                                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                                break;
                            case 19:
                                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                                    program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                                program.chained = true;

                                this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

                                break;
                            case 20:
                                this.$ = $$[$0];
                                break;
                            case 21:
                                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                                break;
                            case 22:
                                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                break;
                            case 23:
                                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                break;
                            case 24:
                                this.$ = {
                                    type: 'PartialStatement',
                                    name: $$[$0 - 3],
                                    params: $$[$0 - 2],
                                    hash: $$[$0 - 1],
                                    indent: '',
                                    strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 25:
                                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                break;
                            case 26:
                                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                                break;
                            case 27:
                                this.$ = $$[$0];
                                break;
                            case 28:
                                this.$ = $$[$0];
                                break;
                            case 29:
                                this.$ = {
                                    type: 'SubExpression',
                                    path: $$[$0 - 3],
                                    params: $$[$0 - 2],
                                    hash: $$[$0 - 1],
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 30:
                                this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
                                break;
                            case 31:
                                this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                                break;
                            case 32:
                                this.$ = yy.id($$[$0 - 1]);
                                break;
                            case 33:
                                this.$ = $$[$0];
                                break;
                            case 34:
                                this.$ = $$[$0];
                                break;
                            case 35:
                                this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                                break;
                            case 36:
                                this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                                break;
                            case 37:
                                this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
                                break;
                            case 38:
                                this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
                                break;
                            case 39:
                                this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
                                break;
                            case 40:
                                this.$ = $$[$0];
                                break;
                            case 41:
                                this.$ = $$[$0];
                                break;
                            case 42:
                                this.$ = yy.preparePath(true, $$[$0], this._$);
                                break;
                            case 43:
                                this.$ = yy.preparePath(false, $$[$0], this._$);
                                break;
                            case 44:
                                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] }); this.$ = $$[$0 - 2];
                                break;
                            case 45:
                                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                                break;
                            case 46:
                                this.$ = [];
                                break;
                            case 47:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 48:
                                this.$ = [$$[$0]];
                                break;
                            case 49:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 50:
                                this.$ = [];
                                break;
                            case 51:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 58:
                                this.$ = [];
                                break;
                            case 59:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 64:
                                this.$ = [];
                                break;
                            case 65:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 70:
                                this.$ = [];
                                break;
                            case 71:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 78:
                                this.$ = [];
                                break;
                            case 79:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 82:
                                this.$ = [];
                                break;
                            case 83:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 86:
                                this.$ = [];
                                break;
                            case 87:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 90:
                                this.$ = [];
                                break;
                            case 91:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 94:
                                this.$ = [];
                                break;
                            case 95:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 98:
                                this.$ = [$$[$0]];
                                break;
                            case 99:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 100:
                                this.$ = [$$[$0]];
                                break;
                            case 101:
                                $$[$0 - 1].push($$[$0]);
                                break;
                        }
                    },
                    table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
                    defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
                    parseError: function parseError(str, hash) {
                        throw new Error(str);
                    },
                    parse: function parse(input) {
                        var self = this,
                            stack = [0],
                            vstack = [null],
                            lstack = [],
                            table = this.table,
                            yytext = "",
                            yylineno = 0,
                            yyleng = 0,
                            recovering = 0,
                            TERROR = 2,
                            EOF = 1;
                        this.lexer.setInput(input);
                        this.lexer.yy = this.yy;
                        this.yy.lexer = this.lexer;
                        this.yy.parser = this;
                        if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
                        var yyloc = this.lexer.yylloc;
                        lstack.push(yyloc);
                        var ranges = this.lexer.options && this.lexer.options.ranges;
                        if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
                        function popStack(n) {
                            stack.length = stack.length - 2 * n;
                            vstack.length = vstack.length - n;
                            lstack.length = lstack.length - n;
                        }
                        function lex() {
                            var token;
                            token = self.lexer.lex() || 1;
                            if (typeof token !== "number") {
                                token = self.symbols_[token] || token;
                            }
                            return token;
                        }
                        var symbol,
                            preErrorSymbol,
                            state,
                            action,
                            a,
                            r,
                            yyval = {},
                            p,
                            len,
                            newState,
                            expected;
                        while (true) {
                            state = stack[stack.length - 1];
                            if (this.defaultActions[state]) {
                                action = this.defaultActions[state];
                            } else {
                                if (symbol === null || typeof symbol == "undefined") {
                                    symbol = lex();
                                }
                                action = table[state] && table[state][symbol];
                            }
                            if (typeof action === "undefined" || !action.length || !action[0]) {
                                var errStr = "";
                                if (!recovering) {
                                    expected = [];
                                    for (p in table[state]) if (this.terminals_[p] && p > 2) {
                                        expected.push("'" + this.terminals_[p] + "'");
                                    }
                                    if (this.lexer.showPosition) {
                                        errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                                    } else {
                                        errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                                    }
                                    this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                                }
                            }
                            if (action[0] instanceof Array && action.length > 1) {
                                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                            }
                            switch (action[0]) {
                                case 1:
                                    stack.push(symbol);
                                    vstack.push(this.lexer.yytext);
                                    lstack.push(this.lexer.yylloc);
                                    stack.push(action[1]);
                                    symbol = null;
                                    if (!preErrorSymbol) {
                                        yyleng = this.lexer.yyleng;
                                        yytext = this.lexer.yytext;
                                        yylineno = this.lexer.yylineno;
                                        yyloc = this.lexer.yylloc;
                                        if (recovering > 0) recovering--;
                                    } else {
                                        symbol = preErrorSymbol;
                                        preErrorSymbol = null;
                                    }
                                    break;
                                case 2:
                                    len = this.productions_[action[1]][1];
                                    yyval.$ = vstack[vstack.length - len];
                                    yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                                    if (ranges) {
                                        yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                                    }
                                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                                    if (typeof r !== "undefined") {
                                        return r;
                                    }
                                    if (len) {
                                        stack = stack.slice(0, -1 * len * 2);
                                        vstack = vstack.slice(0, -1 * len);
                                        lstack = lstack.slice(0, -1 * len);
                                    }
                                    stack.push(this.productions_[action[1]][0]);
                                    vstack.push(yyval.$);
                                    lstack.push(yyval._$);
                                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                                    stack.push(newState);
                                    break;
                                case 3:
                                    return true;
                            }
                        }
                        return true;
                    }
                };
                /* Jison generated lexer */
                var lexer = (function () {
                    var lexer = {
                        EOF: 1,
                        parseError: function parseError(str, hash) {
                            if (this.yy.parser) {
                                this.yy.parser.parseError(str, hash);
                            } else {
                                throw new Error(str);
                            }
                        },
                        setInput: function setInput(input) {
                            this._input = input;
                            this._more = this._less = this.done = false;
                            this.yylineno = this.yyleng = 0;
                            this.yytext = this.matched = this.match = '';
                            this.conditionStack = ['INITIAL'];
                            this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                            if (this.options.ranges) this.yylloc.range = [0, 0];
                            this.offset = 0;
                            return this;
                        },
                        input: function input() {
                            var ch = this._input[0];
                            this.yytext += ch;
                            this.yyleng++;
                            this.offset++;
                            this.match += ch;
                            this.matched += ch;
                            var lines = ch.match(/(?:\r\n?|\n).*/g);
                            if (lines) {
                                this.yylineno++;
                                this.yylloc.last_line++;
                            } else {
                                this.yylloc.last_column++;
                            }
                            if (this.options.ranges) this.yylloc.range[1]++;

                            this._input = this._input.slice(1);
                            return ch;
                        },
                        unput: function unput(ch) {
                            var len = ch.length;
                            var lines = ch.split(/(?:\r\n?|\n)/g);

                            this._input = ch + this._input;
                            this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                            //this.yyleng -= len;
                            this.offset -= len;
                            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                            this.match = this.match.substr(0, this.match.length - 1);
                            this.matched = this.matched.substr(0, this.matched.length - 1);

                            if (lines.length - 1) this.yylineno -= lines.length - 1;
                            var r = this.yylloc.range;

                            this.yylloc = {
                                first_line: this.yylloc.first_line,
                                last_line: this.yylineno + 1,
                                first_column: this.yylloc.first_column,
                                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                            };

                            if (this.options.ranges) {
                                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                            }
                            return this;
                        },
                        more: function more() {
                            this._more = true;
                            return this;
                        },
                        less: function less(n) {
                            this.unput(this.match.slice(n));
                        },
                        pastInput: function pastInput() {
                            var past = this.matched.substr(0, this.matched.length - this.match.length);
                            return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                        },
                        upcomingInput: function upcomingInput() {
                            var next = this.match;
                            if (next.length < 20) {
                                next += this._input.substr(0, 20 - next.length);
                            }
                            return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                        },
                        showPosition: function showPosition() {
                            var pre = this.pastInput();
                            var c = new Array(pre.length + 1).join("-");
                            return pre + this.upcomingInput() + "\n" + c + "^";
                        },
                        next: function next() {
                            if (this.done) {
                                return this.EOF;
                            }
                            if (!this._input) this.done = true;

                            var token, match, tempMatch, index, col, lines;
                            if (!this._more) {
                                this.yytext = '';
                                this.match = '';
                            }
                            var rules = this._currentRules();
                            for (var i = 0; i < rules.length; i++) {
                                tempMatch = this._input.match(this.rules[rules[i]]);
                                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                                    match = tempMatch;
                                    index = i;
                                    if (!this.options.flex) break;
                                }
                            }
                            if (match) {
                                lines = match[0].match(/(?:\r\n?|\n).*/g);
                                if (lines) this.yylineno += lines.length;
                                this.yylloc = {
                                    first_line: this.yylloc.last_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.last_column,
                                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                                };
                                this.yytext += match[0];
                                this.match += match[0];
                                this.matches = match;
                                this.yyleng = this.yytext.length;
                                if (this.options.ranges) {
                                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
                                }
                                this._more = false;
                                this._input = this._input.slice(match[0].length);
                                this.matched += match[0];
                                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                                if (this.done && this._input) this.done = false;
                                if (token) return token; else return;
                            }
                            if (this._input === "") {
                                return this.EOF;
                            } else {
                                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
                            }
                        },
                        lex: function lex() {
                            var r = this.next();
                            if (typeof r !== 'undefined') {
                                return r;
                            } else {
                                return this.lex();
                            }
                        },
                        begin: function begin(condition) {
                            this.conditionStack.push(condition);
                        },
                        popState: function popState() {
                            return this.conditionStack.pop();
                        },
                        _currentRules: function _currentRules() {
                            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                        },
                        topState: function topState() {
                            return this.conditionStack[this.conditionStack.length - 2];
                        },
                        pushState: function begin(condition) {
                            this.begin(condition);
                        }
                    };
                    lexer.options = {};
                    lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
	        /**/) {

                        function strip(start, end) {
                            return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                        }

                        var YYSTATE = YY_START;
                        switch ($avoiding_name_collisions) {
                            case 0:
                                if (yy_.yytext.slice(-2) === "\\\\") {
                                    strip(0, 1);
                                    this.begin("mu");
                                } else if (yy_.yytext.slice(-1) === "\\") {
                                    strip(0, 1);
                                    this.begin("emu");
                                } else {
                                    this.begin("mu");
                                }
                                if (yy_.yytext) return 15;

                                break;
                            case 1:
                                return 15;
                                break;
                            case 2:
                                this.popState();
                                return 15;

                                break;
                            case 3:
                                this.begin('raw'); return 15;
                                break;
                            case 4:
                                this.popState();
                                // Should be using `this.topState()` below, but it currently
                                // returns the second top instead of the first top. Opened an
                                // issue about it at https://github.com/zaach/jison/issues/291
                                if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
                                    return 15;
                                } else {
                                    yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                                    return 'END_RAW_BLOCK';
                                }

                                break;
                            case 5:
                                return 15;
                                break;
                            case 6:
                                this.popState();
                                return 14;

                                break;
                            case 7:
                                return 65;
                                break;
                            case 8:
                                return 68;
                                break;
                            case 9:
                                return 19;
                                break;
                            case 10:
                                this.popState();
                                this.begin('raw');
                                return 23;

                                break;
                            case 11:
                                return 55;
                                break;
                            case 12:
                                return 60;
                                break;
                            case 13:
                                return 29;
                                break;
                            case 14:
                                return 47;
                                break;
                            case 15:
                                this.popState(); return 44;
                                break;
                            case 16:
                                this.popState(); return 44;
                                break;
                            case 17:
                                return 34;
                                break;
                            case 18:
                                return 39;
                                break;
                            case 19:
                                return 51;
                                break;
                            case 20:
                                return 48;
                                break;
                            case 21:
                                this.unput(yy_.yytext);
                                this.popState();
                                this.begin('com');

                                break;
                            case 22:
                                this.popState();
                                return 14;

                                break;
                            case 23:
                                return 48;
                                break;
                            case 24:
                                return 73;
                                break;
                            case 25:
                                return 72;
                                break;
                            case 26:
                                return 72;
                                break;
                            case 27:
                                return 87;
                                break;
                            case 28:
                                // ignore whitespace
                                break;
                            case 29:
                                this.popState(); return 54;
                                break;
                            case 30:
                                this.popState(); return 33;
                                break;
                            case 31:
                                yy_.yytext = strip(1, 2).replace(/\\"/g, '"'); return 80;
                                break;
                            case 32:
                                yy_.yytext = strip(1, 2).replace(/\\'/g, "'"); return 80;
                                break;
                            case 33:
                                return 85;
                                break;
                            case 34:
                                return 82;
                                break;
                            case 35:
                                return 82;
                                break;
                            case 36:
                                return 83;
                                break;
                            case 37:
                                return 84;
                                break;
                            case 38:
                                return 81;
                                break;
                            case 39:
                                return 75;
                                break;
                            case 40:
                                return 77;
                                break;
                            case 41:
                                return 72;
                                break;
                            case 42:
                                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1'); return 72;
                                break;
                            case 43:
                                return 'INVALID';
                                break;
                            case 44:
                                return 5;
                                break;
                        }
                    };
                    lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
                    lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
                    return lexer;
                })();
                parser.lexer = lexer;
                function Parser() {
                    this.yy = {};
                } Parser.prototype = parser; parser.Parser = Parser;
                return new Parser();
            })(); exports.__esModule = true;
            exports['default'] = handlebars;

            /***/
        },
/* 24 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _visitor = __webpack_require__(25);

            var _visitor2 = _interopRequireDefault(_visitor);

            function WhitespaceControl() {
                var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                this.options = options;
            }
            WhitespaceControl.prototype = new _visitor2['default']();

            WhitespaceControl.prototype.Program = function (program) {
                var doStandalone = !this.options.ignoreStandalone;

                var isRoot = !this.isRootSeen;
                this.isRootSeen = true;

                var body = program.body;
                for (var i = 0, l = body.length; i < l; i++) {
                    var current = body[i],
                        strip = this.accept(current);

                    if (!strip) {
                        continue;
                    }

                    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
                        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
                        openStandalone = strip.openStandalone && _isPrevWhitespace,
                        closeStandalone = strip.closeStandalone && _isNextWhitespace,
                        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

                    if (strip.close) {
                        omitRight(body, i, true);
                    }
                    if (strip.open) {
                        omitLeft(body, i, true);
                    }

                    if (doStandalone && inlineStandalone) {
                        omitRight(body, i);

                        if (omitLeft(body, i)) {
                            // If we are on a standalone node, save the indent info for partials
                            if (current.type === 'PartialStatement') {
                                // Pull out the whitespace from the final line
                                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
                            }
                        }
                    }
                    if (doStandalone && openStandalone) {
                        omitRight((current.program || current.inverse).body);

                        // Strip out the previous content node if it's whitespace only
                        omitLeft(body, i);
                    }
                    if (doStandalone && closeStandalone) {
                        // Always strip the next node
                        omitRight(body, i);

                        omitLeft((current.inverse || current.program).body);
                    }
                }

                return program;
            };

            WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
                this.accept(block.program);
                this.accept(block.inverse);

                // Find the inverse program that is involed with whitespace stripping.
                var program = block.program || block.inverse,
                    inverse = block.program && block.inverse,
                    firstInverse = inverse,
                    lastInverse = inverse;

                if (inverse && inverse.chained) {
                    firstInverse = inverse.body[0].program;

                    // Walk the inverse chain to find the last inverse that is actually in the chain.
                    while (lastInverse.chained) {
                        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
                    }
                }

                var strip = {
                    open: block.openStrip.open,
                    close: block.closeStrip.close,

                    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
                    // so our parent can determine if we actually are standalone
                    openStandalone: isNextWhitespace(program.body),
                    closeStandalone: isPrevWhitespace((firstInverse || program).body)
                };

                if (block.openStrip.close) {
                    omitRight(program.body, null, true);
                }

                if (inverse) {
                    var inverseStrip = block.inverseStrip;

                    if (inverseStrip.open) {
                        omitLeft(program.body, null, true);
                    }

                    if (inverseStrip.close) {
                        omitRight(firstInverse.body, null, true);
                    }
                    if (block.closeStrip.open) {
                        omitLeft(lastInverse.body, null, true);
                    }

                    // Find standalone else statments
                    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
                        omitLeft(program.body);
                        omitRight(firstInverse.body);
                    }
                } else if (block.closeStrip.open) {
                    omitLeft(program.body, null, true);
                }

                return strip;
            };

            WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
                return mustache.strip;
            };

            WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
                /* istanbul ignore next */
                var strip = node.strip || {};
                return {
                    inlineStandalone: true,
                    open: strip.open,
                    close: strip.close
                };
            };

            function isPrevWhitespace(body, i, isRoot) {
                if (i === undefined) {
                    i = body.length;
                }

                // Nodes that end with newlines are considered whitespace (but are special
                // cased for strip operations)
                var prev = body[i - 1],
                    sibling = body[i - 2];
                if (!prev) {
                    return isRoot;
                }

                if (prev.type === 'ContentStatement') {
                    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
                }
            }
            function isNextWhitespace(body, i, isRoot) {
                if (i === undefined) {
                    i = -1;
                }

                var next = body[i + 1],
                    sibling = body[i + 2];
                if (!next) {
                    return isRoot;
                }

                if (next.type === 'ContentStatement') {
                    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
                }
            }

            // Marks the node to the right of the position as omitted.
            // I.e. {{foo}}' ' will mark the ' ' node as omitted.
            //
            // If i is undefined, then the first child will be marked as such.
            //
            // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
            // content is met.
            function omitRight(body, i, multiple) {
                var current = body[i == null ? 0 : i + 1];
                if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
                    return;
                }

                var original = current.value;
                current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
                current.rightStripped = current.value !== original;
            }

            // Marks the node to the left of the position as omitted.
            // I.e. ' '{{foo}} will mark the ' ' node as omitted.
            //
            // If i is undefined then the last child will be marked as such.
            //
            // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
            // content is met.
            function omitLeft(body, i, multiple) {
                var current = body[i == null ? body.length - 1 : i - 1];
                if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
                    return;
                }

                // We omit the last node if it's whitespace only and not preceeded by a non-content node.
                var original = current.value;
                current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
                current.leftStripped = current.value !== original;
                return current.leftStripped;
            }

            exports['default'] = WhitespaceControl;
            module.exports = exports['default'];

            /***/
        },
/* 25 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            function Visitor() {
                this.parents = [];
            }

            Visitor.prototype = {
                constructor: Visitor,
                mutating: false,

                // Visits a given value. If mutating, will replace the value if necessary.
                acceptKey: function acceptKey(node, name) {
                    var value = this.accept(node[name]);
                    if (this.mutating) {
                        // Hacky sanity check: This may have a few false positives for type for the helper
                        // methods but will generally do the right thing without a lot of overhead.
                        if (value && !Visitor.prototype[value.type]) {
                            throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
                        }
                        node[name] = value;
                    }
                },

                // Performs an accept operation with added sanity check to ensure
                // required keys are not removed.
                acceptRequired: function acceptRequired(node, name) {
                    this.acceptKey(node, name);

                    if (!node[name]) {
                        throw new _exception2['default'](node.type + ' requires ' + name);
                    }
                },

                // Traverses a given array. If mutating, empty respnses will be removed
                // for child elements.
                acceptArray: function acceptArray(array) {
                    for (var i = 0, l = array.length; i < l; i++) {
                        this.acceptKey(array, i);

                        if (!array[i]) {
                            array.splice(i, 1);
                            i--;
                            l--;
                        }
                    }
                },

                accept: function accept(object) {
                    if (!object) {
                        return;
                    }

                    /* istanbul ignore next: Sanity code */
                    if (!this[object.type]) {
                        throw new _exception2['default']('Unknown type: ' + object.type, object);
                    }

                    if (this.current) {
                        this.parents.unshift(this.current);
                    }
                    this.current = object;

                    var ret = this[object.type](object);

                    this.current = this.parents.shift();

                    if (!this.mutating || ret) {
                        return ret;
                    } else if (ret !== false) {
                        return object;
                    }
                },

                Program: function Program(program) {
                    this.acceptArray(program.body);
                },

                MustacheStatement: visitSubExpression,
                Decorator: visitSubExpression,

                BlockStatement: visitBlock,
                DecoratorBlock: visitBlock,

                PartialStatement: visitPartial,
                PartialBlockStatement: function PartialBlockStatement(partial) {
                    visitPartial.call(this, partial);

                    this.acceptKey(partial, 'program');
                },

                ContentStatement: function ContentStatement() /* content */ { },
                CommentStatement: function CommentStatement() /* comment */ { },

                SubExpression: visitSubExpression,

                PathExpression: function PathExpression() /* path */ { },

                StringLiteral: function StringLiteral() /* string */ { },
                NumberLiteral: function NumberLiteral() /* number */ { },
                BooleanLiteral: function BooleanLiteral() /* bool */ { },
                UndefinedLiteral: function UndefinedLiteral() /* literal */ { },
                NullLiteral: function NullLiteral() /* literal */ { },

                Hash: function Hash(hash) {
                    this.acceptArray(hash.pairs);
                },
                HashPair: function HashPair(pair) {
                    this.acceptRequired(pair, 'value');
                }
            };

            function visitSubExpression(mustache) {
                this.acceptRequired(mustache, 'path');
                this.acceptArray(mustache.params);
                this.acceptKey(mustache, 'hash');
            }
            function visitBlock(block) {
                visitSubExpression.call(this, block);

                this.acceptKey(block, 'program');
                this.acceptKey(block, 'inverse');
            }
            function visitPartial(partial) {
                this.acceptRequired(partial, 'name');
                this.acceptArray(partial.params);
                this.acceptKey(partial, 'hash');
            }

            exports['default'] = Visitor;
            module.exports = exports['default'];

            /***/
        },
/* 26 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.SourceLocation = SourceLocation;
            exports.id = id;
            exports.stripFlags = stripFlags;
            exports.stripComment = stripComment;
            exports.preparePath = preparePath;
            exports.prepareMustache = prepareMustache;
            exports.prepareRawBlock = prepareRawBlock;
            exports.prepareBlock = prepareBlock;
            exports.prepareProgram = prepareProgram;
            exports.preparePartialBlock = preparePartialBlock;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            function validateClose(open, close) {
                close = close.path ? close.path.original : close;

                if (open.path.original !== close) {
                    var errorNode = { loc: open.path.loc };

                    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
                }
            }

            function SourceLocation(source, locInfo) {
                this.source = source;
                this.start = {
                    line: locInfo.first_line,
                    column: locInfo.first_column
                };
                this.end = {
                    line: locInfo.last_line,
                    column: locInfo.last_column
                };
            }

            function id(token) {
                if (/^\[.*\]$/.test(token)) {
                    return token.substr(1, token.length - 2);
                } else {
                    return token;
                }
            }

            function stripFlags(open, close) {
                return {
                    open: open.charAt(2) === '~',
                    close: close.charAt(close.length - 3) === '~'
                };
            }

            function stripComment(comment) {
                return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
            }

            function preparePath(data, parts, loc) {
                loc = this.locInfo(loc);

                var original = data ? '@' : '',
                    dig = [],
                    depth = 0,
                    depthString = '';

                for (var i = 0, l = parts.length; i < l; i++) {
                    var part = parts[i].part,

                        // If we have [] syntax then we do not treat path references as operators,
                        // i.e. foo.[this] resolves to approximately context.foo['this']
                        isLiteral = parts[i].original !== part;
                    original += (parts[i].separator || '') + part;

                    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
                        if (dig.length > 0) {
                            throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
                        } else if (part === '..') {
                            depth++;
                            depthString += '../';
                        }
                    } else {
                        dig.push(part);
                    }
                }

                return {
                    type: 'PathExpression',
                    data: data,
                    depth: depth,
                    parts: dig,
                    original: original,
                    loc: loc
                };
            }

            function prepareMustache(path, params, hash, open, strip, locInfo) {
                // Must use charAt to support IE pre-10
                var escapeFlag = open.charAt(3) || open.charAt(2),
                    escaped = escapeFlag !== '{' && escapeFlag !== '&';

                var decorator = /\*/.test(open);
                return {
                    type: decorator ? 'Decorator' : 'MustacheStatement',
                    path: path,
                    params: params,
                    hash: hash,
                    escaped: escaped,
                    strip: strip,
                    loc: this.locInfo(locInfo)
                };
            }

            function prepareRawBlock(openRawBlock, contents, close, locInfo) {
                validateClose(openRawBlock, close);

                locInfo = this.locInfo(locInfo);
                var program = {
                    type: 'Program',
                    body: contents,
                    strip: {},
                    loc: locInfo
                };

                return {
                    type: 'BlockStatement',
                    path: openRawBlock.path,
                    params: openRawBlock.params,
                    hash: openRawBlock.hash,
                    program: program,
                    openStrip: {},
                    inverseStrip: {},
                    closeStrip: {},
                    loc: locInfo
                };
            }

            function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
                if (close && close.path) {
                    validateClose(openBlock, close);
                }

                var decorator = /\*/.test(openBlock.open);

                program.blockParams = openBlock.blockParams;

                var inverse = undefined,
                    inverseStrip = undefined;

                if (inverseAndProgram) {
                    if (decorator) {
                        throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
                    }

                    if (inverseAndProgram.chain) {
                        inverseAndProgram.program.body[0].closeStrip = close.strip;
                    }

                    inverseStrip = inverseAndProgram.strip;
                    inverse = inverseAndProgram.program;
                }

                if (inverted) {
                    inverted = inverse;
                    inverse = program;
                    program = inverted;
                }

                return {
                    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
                    path: openBlock.path,
                    params: openBlock.params,
                    hash: openBlock.hash,
                    program: program,
                    inverse: inverse,
                    openStrip: openBlock.strip,
                    inverseStrip: inverseStrip,
                    closeStrip: close && close.strip,
                    loc: this.locInfo(locInfo)
                };
            }

            function prepareProgram(statements, loc) {
                if (!loc && statements.length) {
                    var firstLoc = statements[0].loc,
                        lastLoc = statements[statements.length - 1].loc;

                    /* istanbul ignore else */
                    if (firstLoc && lastLoc) {
                        loc = {
                            source: firstLoc.source,
                            start: {
                                line: firstLoc.start.line,
                                column: firstLoc.start.column
                            },
                            end: {
                                line: lastLoc.end.line,
                                column: lastLoc.end.column
                            }
                        };
                    }
                }

                return {
                    type: 'Program',
                    body: statements,
                    strip: {},
                    loc: loc
                };
            }

            function preparePartialBlock(open, program, close, locInfo) {
                validateClose(open, close);

                return {
                    type: 'PartialBlockStatement',
                    name: open.path,
                    params: open.params,
                    hash: open.hash,
                    program: program,
                    openStrip: open.strip,
                    closeStrip: close && close.strip,
                    loc: this.locInfo(locInfo)
                };
            }

            /***/
        },
/* 27 */
/***/ function (module, exports, __webpack_require__) {

            /* eslint-disable new-cap */

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.Compiler = Compiler;
            exports.precompile = precompile;
            exports.compile = compile;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _utils = __webpack_require__(5);

            var _ast = __webpack_require__(21);

            var _ast2 = _interopRequireDefault(_ast);

            var slice = [].slice;

            function Compiler() { }

            // the foundHelper register will disambiguate helper lookup from finding a
            // function in a context. This is necessary for mustache compatibility, which
            // requires that context functions in blocks are evaluated by blockHelperMissing,
            // and then proceed as if the resulting value was provided to blockHelperMissing.

            Compiler.prototype = {
                compiler: Compiler,

                equals: function equals(other) {
                    var len = this.opcodes.length;
                    if (other.opcodes.length !== len) {
                        return false;
                    }

                    for (var i = 0; i < len; i++) {
                        var opcode = this.opcodes[i],
                            otherOpcode = other.opcodes[i];
                        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
                            return false;
                        }
                    }

                    // We know that length is the same between the two arrays because they are directly tied
                    // to the opcode behavior above.
                    len = this.children.length;
                    for (var i = 0; i < len; i++) {
                        if (!this.children[i].equals(other.children[i])) {
                            return false;
                        }
                    }

                    return true;
                },

                guid: 0,

                compile: function compile(program, options) {
                    this.sourceNode = [];
                    this.opcodes = [];
                    this.children = [];
                    this.options = options;
                    this.stringParams = options.stringParams;
                    this.trackIds = options.trackIds;

                    options.blockParams = options.blockParams || [];

                    // These changes will propagate to the other compiler components
                    var knownHelpers = options.knownHelpers;
                    options.knownHelpers = {
                        'helperMissing': true,
                        'blockHelperMissing': true,
                        'each': true,
                        'if': true,
                        'unless': true,
                        'with': true,
                        'log': true,
                        'lookup': true
                    };
                    if (knownHelpers) {
                        for (var _name in knownHelpers) {
                            /* istanbul ignore else */
                            if (_name in knownHelpers) {
                                options.knownHelpers[_name] = knownHelpers[_name];
                            }
                        }
                    }

                    return this.accept(program);
                },

                compileProgram: function compileProgram(program) {
                    var childCompiler = new this.compiler(),
                        // eslint-disable-line new-cap
                        result = childCompiler.compile(program, this.options),
                        guid = this.guid++;

                    this.usePartial = this.usePartial || result.usePartial;

                    this.children[guid] = result;
                    this.useDepths = this.useDepths || result.useDepths;

                    return guid;
                },

                accept: function accept(node) {
                    /* istanbul ignore next: Sanity code */
                    if (!this[node.type]) {
                        throw new _exception2['default']('Unknown type: ' + node.type, node);
                    }

                    this.sourceNode.unshift(node);
                    var ret = this[node.type](node);
                    this.sourceNode.shift();
                    return ret;
                },

                Program: function Program(program) {
                    this.options.blockParams.unshift(program.blockParams);

                    var body = program.body,
                        bodyLength = body.length;
                    for (var i = 0; i < bodyLength; i++) {
                        this.accept(body[i]);
                    }

                    this.options.blockParams.shift();

                    this.isSimple = bodyLength === 1;
                    this.blockParams = program.blockParams ? program.blockParams.length : 0;

                    return this;
                },

                BlockStatement: function BlockStatement(block) {
                    transformLiteralToPath(block);

                    var program = block.program,
                        inverse = block.inverse;

                    program = program && this.compileProgram(program);
                    inverse = inverse && this.compileProgram(inverse);

                    var type = this.classifySexpr(block);

                    if (type === 'helper') {
                        this.helperSexpr(block, program, inverse);
                    } else if (type === 'simple') {
                        this.simpleSexpr(block);

                        // now that the simple mustache is resolved, we need to
                        // evaluate it by executing `blockHelperMissing`
                        this.opcode('pushProgram', program);
                        this.opcode('pushProgram', inverse);
                        this.opcode('emptyHash');
                        this.opcode('blockValue', block.path.original);
                    } else {
                        this.ambiguousSexpr(block, program, inverse);

                        // now that the simple mustache is resolved, we need to
                        // evaluate it by executing `blockHelperMissing`
                        this.opcode('pushProgram', program);
                        this.opcode('pushProgram', inverse);
                        this.opcode('emptyHash');
                        this.opcode('ambiguousBlockValue');
                    }

                    this.opcode('append');
                },

                DecoratorBlock: function DecoratorBlock(decorator) {
                    var program = decorator.program && this.compileProgram(decorator.program);
                    var params = this.setupFullMustacheParams(decorator, program, undefined),
                        path = decorator.path;

                    this.useDecorators = true;
                    this.opcode('registerDecorator', params.length, path.original);
                },

                PartialStatement: function PartialStatement(partial) {
                    this.usePartial = true;

                    var program = partial.program;
                    if (program) {
                        program = this.compileProgram(partial.program);
                    }

                    var params = partial.params;
                    if (params.length > 1) {
                        throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
                    } else if (!params.length) {
                        if (this.options.explicitPartialContext) {
                            this.opcode('pushLiteral', 'undefined');
                        } else {
                            params.push({ type: 'PathExpression', parts: [], depth: 0 });
                        }
                    }

                    var partialName = partial.name.original,
                        isDynamic = partial.name.type === 'SubExpression';
                    if (isDynamic) {
                        this.accept(partial.name);
                    }

                    this.setupFullMustacheParams(partial, program, undefined, true);

                    var indent = partial.indent || '';
                    if (this.options.preventIndent && indent) {
                        this.opcode('appendContent', indent);
                        indent = '';
                    }

                    this.opcode('invokePartial', isDynamic, partialName, indent);
                    this.opcode('append');
                },
                PartialBlockStatement: function PartialBlockStatement(partialBlock) {
                    this.PartialStatement(partialBlock);
                },

                MustacheStatement: function MustacheStatement(mustache) {
                    this.SubExpression(mustache);

                    if (mustache.escaped && !this.options.noEscape) {
                        this.opcode('appendEscaped');
                    } else {
                        this.opcode('append');
                    }
                },
                Decorator: function Decorator(decorator) {
                    this.DecoratorBlock(decorator);
                },

                ContentStatement: function ContentStatement(content) {
                    if (content.value) {
                        this.opcode('appendContent', content.value);
                    }
                },

                CommentStatement: function CommentStatement() { },

                SubExpression: function SubExpression(sexpr) {
                    transformLiteralToPath(sexpr);
                    var type = this.classifySexpr(sexpr);

                    if (type === 'simple') {
                        this.simpleSexpr(sexpr);
                    } else if (type === 'helper') {
                        this.helperSexpr(sexpr);
                    } else {
                        this.ambiguousSexpr(sexpr);
                    }
                },
                ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
                    var path = sexpr.path,
                        name = path.parts[0],
                        isBlock = program != null || inverse != null;

                    this.opcode('getContext', path.depth);

                    this.opcode('pushProgram', program);
                    this.opcode('pushProgram', inverse);

                    path.strict = true;
                    this.accept(path);

                    this.opcode('invokeAmbiguous', name, isBlock);
                },

                simpleSexpr: function simpleSexpr(sexpr) {
                    var path = sexpr.path;
                    path.strict = true;
                    this.accept(path);
                    this.opcode('resolvePossibleLambda');
                },

                helperSexpr: function helperSexpr(sexpr, program, inverse) {
                    var params = this.setupFullMustacheParams(sexpr, program, inverse),
                        path = sexpr.path,
                        name = path.parts[0];

                    if (this.options.knownHelpers[name]) {
                        this.opcode('invokeKnownHelper', params.length, name);
                    } else if (this.options.knownHelpersOnly) {
                        throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
                    } else {
                        path.strict = true;
                        path.falsy = true;

                        this.accept(path);
                        this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
                    }
                },

                PathExpression: function PathExpression(path) {
                    this.addDepth(path.depth);
                    this.opcode('getContext', path.depth);

                    var name = path.parts[0],
                        scoped = _ast2['default'].helpers.scopedId(path),
                        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

                    if (blockParamId) {
                        this.opcode('lookupBlockParam', blockParamId, path.parts);
                    } else if (!name) {
                        // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
                        this.opcode('pushContext');
                    } else if (path.data) {
                        this.options.data = true;
                        this.opcode('lookupData', path.depth, path.parts, path.strict);
                    } else {
                        this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
                    }
                },

                StringLiteral: function StringLiteral(string) {
                    this.opcode('pushString', string.value);
                },

                NumberLiteral: function NumberLiteral(number) {
                    this.opcode('pushLiteral', number.value);
                },

                BooleanLiteral: function BooleanLiteral(bool) {
                    this.opcode('pushLiteral', bool.value);
                },

                UndefinedLiteral: function UndefinedLiteral() {
                    this.opcode('pushLiteral', 'undefined');
                },

                NullLiteral: function NullLiteral() {
                    this.opcode('pushLiteral', 'null');
                },

                Hash: function Hash(hash) {
                    var pairs = hash.pairs,
                        i = 0,
                        l = pairs.length;

                    this.opcode('pushHash');

                    for (; i < l; i++) {
                        this.pushParam(pairs[i].value);
                    }
                    while (i--) {
                        this.opcode('assignToHash', pairs[i].key);
                    }
                    this.opcode('popHash');
                },

                // HELPERS
                opcode: function opcode(name) {
                    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
                },

                addDepth: function addDepth(depth) {
                    if (!depth) {
                        return;
                    }

                    this.useDepths = true;
                },

                classifySexpr: function classifySexpr(sexpr) {
                    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

                    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

                    // a mustache is an eligible helper if:
                    // * its id is simple (a single part, not `this` or `..`)
                    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

                    // if a mustache is an eligible helper but not a definite
                    // helper, it is ambiguous, and will be resolved in a later
                    // pass or at runtime.
                    var isEligible = !isBlockParam && (isHelper || isSimple);

                    // if ambiguous, we can possibly resolve the ambiguity now
                    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
                    if (isEligible && !isHelper) {
                        var _name2 = sexpr.path.parts[0],
                            options = this.options;

                        if (options.knownHelpers[_name2]) {
                            isHelper = true;
                        } else if (options.knownHelpersOnly) {
                            isEligible = false;
                        }
                    }

                    if (isHelper) {
                        return 'helper';
                    } else if (isEligible) {
                        return 'ambiguous';
                    } else {
                        return 'simple';
                    }
                },

                pushParams: function pushParams(params) {
                    for (var i = 0, l = params.length; i < l; i++) {
                        this.pushParam(params[i]);
                    }
                },

                pushParam: function pushParam(val) {
                    var value = val.value != null ? val.value : val.original || '';

                    if (this.stringParams) {
                        if (value.replace) {
                            value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
                        }

                        if (val.depth) {
                            this.addDepth(val.depth);
                        }
                        this.opcode('getContext', val.depth || 0);
                        this.opcode('pushStringParam', value, val.type);

                        if (val.type === 'SubExpression') {
                            // SubExpressions get evaluated and passed in
                            // in string params mode.
                            this.accept(val);
                        }
                    } else {
                        if (this.trackIds) {
                            var blockParamIndex = undefined;
                            if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
                                blockParamIndex = this.blockParamIndex(val.parts[0]);
                            }
                            if (blockParamIndex) {
                                var blockParamChild = val.parts.slice(1).join('.');
                                this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
                            } else {
                                value = val.original || value;
                                if (value.replace) {
                                    value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
                                }

                                this.opcode('pushId', val.type, value);
                            }
                        }
                        this.accept(val);
                    }
                },

                setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
                    var params = sexpr.params;
                    this.pushParams(params);

                    this.opcode('pushProgram', program);
                    this.opcode('pushProgram', inverse);

                    if (sexpr.hash) {
                        this.accept(sexpr.hash);
                    } else {
                        this.opcode('emptyHash', omitEmpty);
                    }

                    return params;
                },

                blockParamIndex: function blockParamIndex(name) {
                    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
                        var blockParams = this.options.blockParams[depth],
                            param = blockParams && _utils.indexOf(blockParams, name);
                        if (blockParams && param >= 0) {
                            return [depth, param];
                        }
                    }
                }
            };

            function precompile(input, options, env) {
                if (input == null || typeof input !== 'string' && input.type !== 'Program') {
                    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
                }

                options = options || {};
                if (!('data' in options)) {
                    options.data = true;
                }
                if (options.compat) {
                    options.useDepths = true;
                }

                var ast = env.parse(input, options),
                    environment = new env.Compiler().compile(ast, options);
                return new env.JavaScriptCompiler().compile(environment, options);
            }

            function compile(input, options, env) {
                if (options === undefined) options = {};

                if (input == null || typeof input !== 'string' && input.type !== 'Program') {
                    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
                }

                if (!('data' in options)) {
                    options.data = true;
                }
                if (options.compat) {
                    options.useDepths = true;
                }

                var compiled = undefined;

                function compileInput() {
                    var ast = env.parse(input, options),
                        environment = new env.Compiler().compile(ast, options),
                        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
                    return env.template(templateSpec);
                }

                // Template is only compiled on first use and cached after that point.
                function ret(context, execOptions) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled.call(this, context, execOptions);
                }
                ret._setup = function (setupOptions) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled._setup(setupOptions);
                };
                ret._child = function (i, data, blockParams, depths) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled._child(i, data, blockParams, depths);
                };
                return ret;
            }

            function argEquals(a, b) {
                if (a === b) {
                    return true;
                }

                if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
                    for (var i = 0; i < a.length; i++) {
                        if (!argEquals(a[i], b[i])) {
                            return false;
                        }
                    }
                    return true;
                }
            }

            function transformLiteralToPath(sexpr) {
                if (!sexpr.path.parts) {
                    var literal = sexpr.path;
                    // Casting to string here to make false and 0 literal values play nicely with the rest
                    // of the system.
                    sexpr.path = {
                        type: 'PathExpression',
                        data: false,
                        depth: 0,
                        parts: [literal.original + ''],
                        original: literal.original + '',
                        loc: literal.loc
                    };
                }
            }

            /***/
        },
/* 28 */
/***/ function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _base = __webpack_require__(4);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _utils = __webpack_require__(5);

            var _codeGen = __webpack_require__(29);

            var _codeGen2 = _interopRequireDefault(_codeGen);

            function Literal(value) {
                this.value = value;
            }

            function JavaScriptCompiler() { }

            JavaScriptCompiler.prototype = {
                // PUBLIC API: You can override these methods in a subclass to provide
                // alternative compiled forms for name lookup and buffering semantics
                nameLookup: function nameLookup(parent, name /* , type*/) {
                    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
                        return [parent, '.', name];
                    } else {
                        return [parent, '[', JSON.stringify(name), ']'];
                    }
                },
                depthedLookup: function depthedLookup(name) {
                    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
                },

                compilerInfo: function compilerInfo() {
                    var revision = _base.COMPILER_REVISION,
                        versions = _base.REVISION_CHANGES[revision];
                    return [revision, versions];
                },

                appendToBuffer: function appendToBuffer(source, location, explicit) {
                    // Force a source as this simplifies the merge logic.
                    if (!_utils.isArray(source)) {
                        source = [source];
                    }
                    source = this.source.wrap(source, location);

                    if (this.environment.isSimple) {
                        return ['return ', source, ';'];
                    } else if (explicit) {
                        // This is a case where the buffer operation occurs as a child of another
                        // construct, generally braces. We have to explicitly output these buffer
                        // operations to ensure that the emitted code goes in the correct location.
                        return ['buffer += ', source, ';'];
                    } else {
                        source.appendToBuffer = true;
                        return source;
                    }
                },

                initializeBuffer: function initializeBuffer() {
                    return this.quotedString('');
                },
                // END PUBLIC API

                compile: function compile(environment, options, context, asObject) {
                    this.environment = environment;
                    this.options = options;
                    this.stringParams = this.options.stringParams;
                    this.trackIds = this.options.trackIds;
                    this.precompile = !asObject;

                    this.name = this.environment.name;
                    this.isChild = !!context;
                    this.context = context || {
                        decorators: [],
                        programs: [],
                        environments: []
                    };

                    this.preamble();

                    this.stackSlot = 0;
                    this.stackVars = [];
                    this.aliases = {};
                    this.registers = { list: [] };
                    this.hashes = [];
                    this.compileStack = [];
                    this.inlineStack = [];
                    this.blockParams = [];

                    this.compileChildren(environment, options);

                    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
                    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

                    var opcodes = environment.opcodes,
                        opcode = undefined,
                        firstLoc = undefined,
                        i = undefined,
                        l = undefined;

                    for (i = 0, l = opcodes.length; i < l; i++) {
                        opcode = opcodes[i];

                        this.source.currentLocation = opcode.loc;
                        firstLoc = firstLoc || opcode.loc;
                        this[opcode.opcode].apply(this, opcode.args);
                    }

                    // Flush any trailing content that might be pending.
                    this.source.currentLocation = firstLoc;
                    this.pushSource('');

                    /* istanbul ignore next */
                    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
                        throw new _exception2['default']('Compile completed with content left on stack');
                    }

                    if (!this.decorators.isEmpty()) {
                        this.useDecorators = true;

                        this.decorators.prepend('var decorators = container.decorators;\n');
                        this.decorators.push('return fn;');

                        if (asObject) {
                            this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
                        } else {
                            this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
                            this.decorators.push('}\n');
                            this.decorators = this.decorators.merge();
                        }
                    } else {
                        this.decorators = undefined;
                    }

                    var fn = this.createFunctionContext(asObject);
                    if (!this.isChild) {
                        var ret = {
                            compiler: this.compilerInfo(),
                            main: fn
                        };

                        if (this.decorators) {
                            ret.main_d = this.decorators; // eslint-disable-line camelcase
                            ret.useDecorators = true;
                        }

                        var _context = this.context;
                        var programs = _context.programs;
                        var decorators = _context.decorators;

                        for (i = 0, l = programs.length; i < l; i++) {
                            if (programs[i]) {
                                ret[i] = programs[i];
                                if (decorators[i]) {
                                    ret[i + '_d'] = decorators[i];
                                    ret.useDecorators = true;
                                }
                            }
                        }

                        if (this.environment.usePartial) {
                            ret.usePartial = true;
                        }
                        if (this.options.data) {
                            ret.useData = true;
                        }
                        if (this.useDepths) {
                            ret.useDepths = true;
                        }
                        if (this.useBlockParams) {
                            ret.useBlockParams = true;
                        }
                        if (this.options.compat) {
                            ret.compat = true;
                        }

                        if (!asObject) {
                            ret.compiler = JSON.stringify(ret.compiler);

                            this.source.currentLocation = { start: { line: 1, column: 0 } };
                            ret = this.objectLiteral(ret);

                            if (options.srcName) {
                                ret = ret.toStringWithSourceMap({ file: options.destName });
                                ret.map = ret.map && ret.map.toString();
                            } else {
                                ret = ret.toString();
                            }
                        } else {
                            ret.compilerOptions = this.options;
                        }

                        return ret;
                    } else {
                        return fn;
                    }
                },

                preamble: function preamble() {
                    // track the last context pushed into place to allow skipping the
                    // getContext opcode when it would be a noop
                    this.lastContext = 0;
                    this.source = new _codeGen2['default'](this.options.srcName);
                    this.decorators = new _codeGen2['default'](this.options.srcName);
                },

                createFunctionContext: function createFunctionContext(asObject) {
                    var varDeclarations = '';

                    var locals = this.stackVars.concat(this.registers.list);
                    if (locals.length > 0) {
                        varDeclarations += ', ' + locals.join(', ');
                    }

                    // Generate minimizer alias mappings
                    //
                    // When using true SourceNodes, this will update all references to the given alias
                    // as the source nodes are reused in situ. For the non-source node compilation mode,
                    // aliases will not be used, but this case is already being run on the client and
                    // we aren't concern about minimizing the template size.
                    var aliasCount = 0;
                    for (var alias in this.aliases) {
                        // eslint-disable-line guard-for-in
                        var node = this.aliases[alias];

                        if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
                            varDeclarations += ', alias' + ++aliasCount + '=' + alias;
                            node.children[0] = 'alias' + aliasCount;
                        }
                    }

                    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

                    if (this.useBlockParams || this.useDepths) {
                        params.push('blockParams');
                    }
                    if (this.useDepths) {
                        params.push('depths');
                    }

                    // Perform a second pass over the output to merge content when possible
                    var source = this.mergeSource(varDeclarations);

                    if (asObject) {
                        params.push(source);

                        return Function.apply(this, params);
                    } else {
                        return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
                    }
                },
                mergeSource: function mergeSource(varDeclarations) {
                    var isSimple = this.environment.isSimple,
                        appendOnly = !this.forceBuffer,
                        appendFirst = undefined,
                        sourceSeen = undefined,
                        bufferStart = undefined,
                        bufferEnd = undefined;
                    this.source.each(function (line) {
                        if (line.appendToBuffer) {
                            if (bufferStart) {
                                line.prepend('  + ');
                            } else {
                                bufferStart = line;
                            }
                            bufferEnd = line;
                        } else {
                            if (bufferStart) {
                                if (!sourceSeen) {
                                    appendFirst = true;
                                } else {
                                    bufferStart.prepend('buffer += ');
                                }
                                bufferEnd.add(';');
                                bufferStart = bufferEnd = undefined;
                            }

                            sourceSeen = true;
                            if (!isSimple) {
                                appendOnly = false;
                            }
                        }
                    });

                    if (appendOnly) {
                        if (bufferStart) {
                            bufferStart.prepend('return ');
                            bufferEnd.add(';');
                        } else if (!sourceSeen) {
                            this.source.push('return "";');
                        }
                    } else {
                        varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

                        if (bufferStart) {
                            bufferStart.prepend('return buffer + ');
                            bufferEnd.add(';');
                        } else {
                            this.source.push('return buffer;');
                        }
                    }

                    if (varDeclarations) {
                        this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
                    }

                    return this.source.merge();
                },

                // [blockValue]
                //
                // On stack, before: hash, inverse, program, value
                // On stack, after: return value of blockHelperMissing
                //
                // The purpose of this opcode is to take a block of the form
                // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
                // replace it on the stack with the result of properly
                // invoking blockHelperMissing.
                blockValue: function blockValue(name) {
                    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                        params = [this.contextName(0)];
                    this.setupHelperArgs(name, 0, params);

                    var blockName = this.popStack();
                    params.splice(1, 0, blockName);

                    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
                },

                // [ambiguousBlockValue]
                //
                // On stack, before: hash, inverse, program, value
                // Compiler value, before: lastHelper=value of last found helper, if any
                // On stack, after, if no lastHelper: same as [blockValue]
                // On stack, after, if lastHelper: value
                ambiguousBlockValue: function ambiguousBlockValue() {
                    // We're being a bit cheeky and reusing the options value from the prior exec
                    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                        params = [this.contextName(0)];
                    this.setupHelperArgs('', 0, params, true);

                    this.flushInline();

                    var current = this.topStack();
                    params.splice(1, 0, current);

                    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
                },

                // [appendContent]
                //
                // On stack, before: ...
                // On stack, after: ...
                //
                // Appends the string value of `content` to the current buffer
                appendContent: function appendContent(content) {
                    if (this.pendingContent) {
                        content = this.pendingContent + content;
                    } else {
                        this.pendingLocation = this.source.currentLocation;
                    }

                    this.pendingContent = content;
                },

                // [append]
                //
                // On stack, before: value, ...
                // On stack, after: ...
                //
                // Coerces `value` to a String and appends it to the current buffer.
                //
                // If `value` is truthy, or 0, it is coerced into a string and appended
                // Otherwise, the empty string is appended
                append: function append() {
                    if (this.isInline()) {
                        this.replaceStack(function (current) {
                            return [' != null ? ', current, ' : ""'];
                        });

                        this.pushSource(this.appendToBuffer(this.popStack()));
                    } else {
                        var local = this.popStack();
                        this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
                        if (this.environment.isSimple) {
                            this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
                        }
                    }
                },

                // [appendEscaped]
                //
                // On stack, before: value, ...
                // On stack, after: ...
                //
                // Escape `value` and append it to the buffer
                appendEscaped: function appendEscaped() {
                    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
                },

                // [getContext]
                //
                // On stack, before: ...
                // On stack, after: ...
                // Compiler value, after: lastContext=depth
                //
                // Set the value of the `lastContext` compiler value to the depth
                getContext: function getContext(depth) {
                    this.lastContext = depth;
                },

                // [pushContext]
                //
                // On stack, before: ...
                // On stack, after: currentContext, ...
                //
                // Pushes the value of the current context onto the stack.
                pushContext: function pushContext() {
                    this.pushStackLiteral(this.contextName(this.lastContext));
                },

                // [lookupOnContext]
                //
                // On stack, before: ...
                // On stack, after: currentContext[name], ...
                //
                // Looks up the value of `name` on the current context and pushes
                // it onto the stack.
                lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
                    var i = 0;

                    if (!scoped && this.options.compat && !this.lastContext) {
                        // The depthed query is expected to handle the undefined logic for the root level that
                        // is implemented below, so we evaluate that directly in compat mode
                        this.push(this.depthedLookup(parts[i++]));
                    } else {
                        this.pushContext();
                    }

                    this.resolvePath('context', parts, i, falsy, strict);
                },

                // [lookupBlockParam]
                //
                // On stack, before: ...
                // On stack, after: blockParam[name], ...
                //
                // Looks up the value of `parts` on the given block param and pushes
                // it onto the stack.
                lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
                    this.useBlockParams = true;

                    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
                    this.resolvePath('context', parts, 1);
                },

                // [lookupData]
                //
                // On stack, before: ...
                // On stack, after: data, ...
                //
                // Push the data lookup operator
                lookupData: function lookupData(depth, parts, strict) {
                    if (!depth) {
                        this.pushStackLiteral('data');
                    } else {
                        this.pushStackLiteral('container.data(data, ' + depth + ')');
                    }

                    this.resolvePath('data', parts, 0, true, strict);
                },

                resolvePath: function resolvePath(type, parts, i, falsy, strict) {
                    // istanbul ignore next

                    var _this = this;

                    if (this.options.strict || this.options.assumeObjects) {
                        this.push(strictLookup(this.options.strict && strict, this, parts, type));
                        return;
                    }

                    var len = parts.length;
                    for (; i < len; i++) {
                        /* eslint-disable no-loop-func */
                        this.replaceStack(function (current) {
                            var lookup = _this.nameLookup(current, parts[i], type);
                            // We want to ensure that zero and false are handled properly if the context (falsy flag)
                            // needs to have the special handling for these values.
                            if (!falsy) {
                                return [' != null ? ', lookup, ' : ', current];
                            } else {
                                // Otherwise we can use generic falsy handling
                                return [' && ', lookup];
                            }
                        });
                        /* eslint-enable no-loop-func */
                    }
                },

                // [resolvePossibleLambda]
                //
                // On stack, before: value, ...
                // On stack, after: resolved value, ...
                //
                // If the `value` is a lambda, replace it on the stack by
                // the return value of the lambda
                resolvePossibleLambda: function resolvePossibleLambda() {
                    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
                },

                // [pushStringParam]
                //
                // On stack, before: ...
                // On stack, after: string, currentContext, ...
                //
                // This opcode is designed for use in string mode, which
                // provides the string value of a parameter along with its
                // depth rather than resolving it immediately.
                pushStringParam: function pushStringParam(string, type) {
                    this.pushContext();
                    this.pushString(type);

                    // If it's a subexpression, the string result
                    // will be pushed after this opcode.
                    if (type !== 'SubExpression') {
                        if (typeof string === 'string') {
                            this.pushString(string);
                        } else {
                            this.pushStackLiteral(string);
                        }
                    }
                },

                emptyHash: function emptyHash(omitEmpty) {
                    if (this.trackIds) {
                        this.push('{}'); // hashIds
                    }
                    if (this.stringParams) {
                        this.push('{}'); // hashContexts
                        this.push('{}'); // hashTypes
                    }
                    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
                },
                pushHash: function pushHash() {
                    if (this.hash) {
                        this.hashes.push(this.hash);
                    }
                    this.hash = { values: [], types: [], contexts: [], ids: [] };
                },
                popHash: function popHash() {
                    var hash = this.hash;
                    this.hash = this.hashes.pop();

                    if (this.trackIds) {
                        this.push(this.objectLiteral(hash.ids));
                    }
                    if (this.stringParams) {
                        this.push(this.objectLiteral(hash.contexts));
                        this.push(this.objectLiteral(hash.types));
                    }

                    this.push(this.objectLiteral(hash.values));
                },

                // [pushString]
                //
                // On stack, before: ...
                // On stack, after: quotedString(string), ...
                //
                // Push a quoted version of `string` onto the stack
                pushString: function pushString(string) {
                    this.pushStackLiteral(this.quotedString(string));
                },

                // [pushLiteral]
                //
                // On stack, before: ...
                // On stack, after: value, ...
                //
                // Pushes a value onto the stack. This operation prevents
                // the compiler from creating a temporary variable to hold
                // it.
                pushLiteral: function pushLiteral(value) {
                    this.pushStackLiteral(value);
                },

                // [pushProgram]
                //
                // On stack, before: ...
                // On stack, after: program(guid), ...
                //
                // Push a program expression onto the stack. This takes
                // a compile-time guid and converts it into a runtime-accessible
                // expression.
                pushProgram: function pushProgram(guid) {
                    if (guid != null) {
                        this.pushStackLiteral(this.programExpression(guid));
                    } else {
                        this.pushStackLiteral(null);
                    }
                },

                // [registerDecorator]
                //
                // On stack, before: hash, program, params..., ...
                // On stack, after: ...
                //
                // Pops off the decorator's parameters, invokes the decorator,
                // and inserts the decorator into the decorators list.
                registerDecorator: function registerDecorator(paramSize, name) {
                    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
                        options = this.setupHelperArgs(name, paramSize);

                    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
                },

                // [invokeHelper]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of helper invocation
                //
                // Pops off the helper's parameters, invokes the helper,
                // and pushes the helper's return value onto the stack.
                //
                // If the helper is not found, `helperMissing` is called.
                invokeHelper: function invokeHelper(paramSize, name, isSimple) {
                    var nonHelper = this.popStack(),
                        helper = this.setupHelper(paramSize, name),
                        simple = isSimple ? [helper.name, ' || '] : '';

                    var lookup = ['('].concat(simple, nonHelper);
                    if (!this.options.strict) {
                        lookup.push(' || ', this.aliasable('helpers.helperMissing'));
                    }
                    lookup.push(')');

                    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
                },

                // [invokeKnownHelper]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of helper invocation
                //
                // This operation is used when the helper is known to exist,
                // so a `helperMissing` fallback is not required.
                invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
                    var helper = this.setupHelper(paramSize, name);
                    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
                },

                // [invokeAmbiguous]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of disambiguation
                //
                // This operation is used when an expression like `{{foo}}`
                // is provided, but we don't know at compile-time whether it
                // is a helper or a path.
                //
                // This operation emits more code than the other options,
                // and can be avoided by passing the `knownHelpers` and
                // `knownHelpersOnly` flags at compile-time.
                invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
                    this.useRegister('helper');

                    var nonHelper = this.popStack();

                    this.emptyHash();
                    var helper = this.setupHelper(0, name, helperCall);

                    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

                    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
                    if (!this.options.strict) {
                        lookup[0] = '(helper = ';
                        lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
                    }

                    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
                },

                // [invokePartial]
                //
                // On stack, before: context, ...
                // On stack after: result of partial invocation
                //
                // This operation pops off a context, invokes a partial with that context,
                // and pushes the result of the invocation back.
                invokePartial: function invokePartial(isDynamic, name, indent) {
                    var params = [],
                        options = this.setupParams(name, 1, params);

                    if (isDynamic) {
                        name = this.popStack();
                        delete options.name;
                    }

                    if (indent) {
                        options.indent = JSON.stringify(indent);
                    }
                    options.helpers = 'helpers';
                    options.partials = 'partials';
                    options.decorators = 'container.decorators';

                    if (!isDynamic) {
                        params.unshift(this.nameLookup('partials', name, 'partial'));
                    } else {
                        params.unshift(name);
                    }

                    if (this.options.compat) {
                        options.depths = 'depths';
                    }
                    options = this.objectLiteral(options);
                    params.push(options);

                    this.push(this.source.functionCall('container.invokePartial', '', params));
                },

                // [assignToHash]
                //
                // On stack, before: value, ..., hash, ...
                // On stack, after: ..., hash, ...
                //
                // Pops a value off the stack and assigns it to the current hash
                assignToHash: function assignToHash(key) {
                    var value = this.popStack(),
                        context = undefined,
                        type = undefined,
                        id = undefined;

                    if (this.trackIds) {
                        id = this.popStack();
                    }
                    if (this.stringParams) {
                        type = this.popStack();
                        context = this.popStack();
                    }

                    var hash = this.hash;
                    if (context) {
                        hash.contexts[key] = context;
                    }
                    if (type) {
                        hash.types[key] = type;
                    }
                    if (id) {
                        hash.ids[key] = id;
                    }
                    hash.values[key] = value;
                },

                pushId: function pushId(type, name, child) {
                    if (type === 'BlockParam') {
                        this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
                    } else if (type === 'PathExpression') {
                        this.pushString(name);
                    } else if (type === 'SubExpression') {
                        this.pushStackLiteral('true');
                    } else {
                        this.pushStackLiteral('null');
                    }
                },

                // HELPERS

                compiler: JavaScriptCompiler,

                compileChildren: function compileChildren(environment, options) {
                    var children = environment.children,
                        child = undefined,
                        compiler = undefined;

                    for (var i = 0, l = children.length; i < l; i++) {
                        child = children[i];
                        compiler = new this.compiler(); // eslint-disable-line new-cap

                        var index = this.matchExistingProgram(child);

                        if (index == null) {
                            this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
                            index = this.context.programs.length;
                            child.index = index;
                            child.name = 'program' + index;
                            this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
                            this.context.decorators[index] = compiler.decorators;
                            this.context.environments[index] = child;

                            this.useDepths = this.useDepths || compiler.useDepths;
                            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
                        } else {
                            child.index = index;
                            child.name = 'program' + index;

                            this.useDepths = this.useDepths || child.useDepths;
                            this.useBlockParams = this.useBlockParams || child.useBlockParams;
                        }
                    }
                },
                matchExistingProgram: function matchExistingProgram(child) {
                    for (var i = 0, len = this.context.environments.length; i < len; i++) {
                        var environment = this.context.environments[i];
                        if (environment && environment.equals(child)) {
                            return i;
                        }
                    }
                },

                programExpression: function programExpression(guid) {
                    var child = this.environment.children[guid],
                        programParams = [child.index, 'data', child.blockParams];

                    if (this.useBlockParams || this.useDepths) {
                        programParams.push('blockParams');
                    }
                    if (this.useDepths) {
                        programParams.push('depths');
                    }

                    return 'container.program(' + programParams.join(', ') + ')';
                },

                useRegister: function useRegister(name) {
                    if (!this.registers[name]) {
                        this.registers[name] = true;
                        this.registers.list.push(name);
                    }
                },

                push: function push(expr) {
                    if (!(expr instanceof Literal)) {
                        expr = this.source.wrap(expr);
                    }

                    this.inlineStack.push(expr);
                    return expr;
                },

                pushStackLiteral: function pushStackLiteral(item) {
                    this.push(new Literal(item));
                },

                pushSource: function pushSource(source) {
                    if (this.pendingContent) {
                        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
                        this.pendingContent = undefined;
                    }

                    if (source) {
                        this.source.push(source);
                    }
                },

                replaceStack: function replaceStack(callback) {
                    var prefix = ['('],
                        stack = undefined,
                        createdStack = undefined,
                        usedLiteral = undefined;

                    /* istanbul ignore next */
                    if (!this.isInline()) {
                        throw new _exception2['default']('replaceStack on non-inline');
                    }

                    // We want to merge the inline statement into the replacement statement via ','
                    var top = this.popStack(true);

                    if (top instanceof Literal) {
                        // Literals do not need to be inlined
                        stack = [top.value];
                        prefix = ['(', stack];
                        usedLiteral = true;
                    } else {
                        // Get or create the current stack name for use by the inline
                        createdStack = true;
                        var _name = this.incrStack();

                        prefix = ['((', this.push(_name), ' = ', top, ')'];
                        stack = this.topStack();
                    }

                    var item = callback.call(this, stack);

                    if (!usedLiteral) {
                        this.popStack();
                    }
                    if (createdStack) {
                        this.stackSlot--;
                    }
                    this.push(prefix.concat(item, ')'));
                },

                incrStack: function incrStack() {
                    this.stackSlot++;
                    if (this.stackSlot > this.stackVars.length) {
                        this.stackVars.push('stack' + this.stackSlot);
                    }
                    return this.topStackName();
                },
                topStackName: function topStackName() {
                    return 'stack' + this.stackSlot;
                },
                flushInline: function flushInline() {
                    var inlineStack = this.inlineStack;
                    this.inlineStack = [];
                    for (var i = 0, len = inlineStack.length; i < len; i++) {
                        var entry = inlineStack[i];
                        /* istanbul ignore if */
                        if (entry instanceof Literal) {
                            this.compileStack.push(entry);
                        } else {
                            var stack = this.incrStack();
                            this.pushSource([stack, ' = ', entry, ';']);
                            this.compileStack.push(stack);
                        }
                    }
                },
                isInline: function isInline() {
                    return this.inlineStack.length;
                },

                popStack: function popStack(wrapped) {
                    var inline = this.isInline(),
                        item = (inline ? this.inlineStack : this.compileStack).pop();

                    if (!wrapped && item instanceof Literal) {
                        return item.value;
                    } else {
                        if (!inline) {
                            /* istanbul ignore next */
                            if (!this.stackSlot) {
                                throw new _exception2['default']('Invalid stack pop');
                            }
                            this.stackSlot--;
                        }
                        return item;
                    }
                },

                topStack: function topStack() {
                    var stack = this.isInline() ? this.inlineStack : this.compileStack,
                        item = stack[stack.length - 1];

                    /* istanbul ignore if */
                    if (item instanceof Literal) {
                        return item.value;
                    } else {
                        return item;
                    }
                },

                contextName: function contextName(context) {
                    if (this.useDepths && context) {
                        return 'depths[' + context + ']';
                    } else {
                        return 'depth' + context;
                    }
                },

                quotedString: function quotedString(str) {
                    return this.source.quotedString(str);
                },

                objectLiteral: function objectLiteral(obj) {
                    return this.source.objectLiteral(obj);
                },

                aliasable: function aliasable(name) {
                    var ret = this.aliases[name];
                    if (ret) {
                        ret.referenceCount++;
                        return ret;
                    }

                    ret = this.aliases[name] = this.source.wrap(name);
                    ret.aliasable = true;
                    ret.referenceCount = 1;

                    return ret;
                },

                setupHelper: function setupHelper(paramSize, name, blockHelper) {
                    var params = [],
                        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
                    var foundHelper = this.nameLookup('helpers', name, 'helper'),
                        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');

                    return {
                        params: params,
                        paramsInit: paramsInit,
                        name: foundHelper,
                        callParams: [callContext].concat(params)
                    };
                },

                setupParams: function setupParams(helper, paramSize, params) {
                    var options = {},
                        contexts = [],
                        types = [],
                        ids = [],
                        objectArgs = !params,
                        param = undefined;

                    if (objectArgs) {
                        params = [];
                    }

                    options.name = this.quotedString(helper);
                    options.hash = this.popStack();

                    if (this.trackIds) {
                        options.hashIds = this.popStack();
                    }
                    if (this.stringParams) {
                        options.hashTypes = this.popStack();
                        options.hashContexts = this.popStack();
                    }

                    var inverse = this.popStack(),
                        program = this.popStack();

                    // Avoid setting fn and inverse if neither are set. This allows
                    // helpers to do a check for `if (options.fn)`
                    if (program || inverse) {
                        options.fn = program || 'container.noop';
                        options.inverse = inverse || 'container.noop';
                    }

                    // The parameters go on to the stack in order (making sure that they are evaluated in order)
                    // so we need to pop them off the stack in reverse order
                    var i = paramSize;
                    while (i--) {
                        param = this.popStack();
                        params[i] = param;

                        if (this.trackIds) {
                            ids[i] = this.popStack();
                        }
                        if (this.stringParams) {
                            types[i] = this.popStack();
                            contexts[i] = this.popStack();
                        }
                    }

                    if (objectArgs) {
                        options.args = this.source.generateArray(params);
                    }

                    if (this.trackIds) {
                        options.ids = this.source.generateArray(ids);
                    }
                    if (this.stringParams) {
                        options.types = this.source.generateArray(types);
                        options.contexts = this.source.generateArray(contexts);
                    }

                    if (this.options.data) {
                        options.data = 'data';
                    }
                    if (this.useBlockParams) {
                        options.blockParams = 'blockParams';
                    }
                    return options;
                },

                setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
                    var options = this.setupParams(helper, paramSize, params);
                    options = this.objectLiteral(options);
                    if (useRegister) {
                        this.useRegister('options');
                        params.push('options');
                        return ['options=', options];
                    } else if (params) {
                        params.push(options);
                        return '';
                    } else {
                        return options;
                    }
                }
            };

            (function () {
                var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

                var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

                for (var i = 0, l = reservedWords.length; i < l; i++) {
                    compilerWords[reservedWords[i]] = true;
                }
            })();

            JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
                return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
            };

            function strictLookup(requireTerminal, compiler, parts, type) {
                var stack = compiler.popStack(),
                    i = 0,
                    len = parts.length;
                if (requireTerminal) {
                    len--;
                }

                for (; i < len; i++) {
                    stack = compiler.nameLookup(stack, parts[i], type);
                }

                if (requireTerminal) {
                    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
                } else {
                    return stack;
                }
            }

            exports['default'] = JavaScriptCompiler;
            module.exports = exports['default'];

            /***/
        },
/* 29 */
/***/ function (module, exports, __webpack_require__) {

            /* global define */
            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var SourceNode = undefined;

            try {
                /* istanbul ignore next */
                if (false) {
                    // We don't support this in AMD environments. For these environments, we asusme that
                    // they are running on the browser and thus have no need for the source-map library.
                    var SourceMap = require('source-map');
                    SourceNode = SourceMap.SourceNode;
                }
            } catch (err) { }
            /* NOP */

            /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
            if (!SourceNode) {
                SourceNode = function (line, column, srcFile, chunks) {
                    this.src = '';
                    if (chunks) {
                        this.add(chunks);
                    }
                };
                /* istanbul ignore next */
                SourceNode.prototype = {
                    add: function add(chunks) {
                        if (_utils.isArray(chunks)) {
                            chunks = chunks.join('');
                        }
                        this.src += chunks;
                    },
                    prepend: function prepend(chunks) {
                        if (_utils.isArray(chunks)) {
                            chunks = chunks.join('');
                        }
                        this.src = chunks + this.src;
                    },
                    toStringWithSourceMap: function toStringWithSourceMap() {
                        return { code: this.toString() };
                    },
                    toString: function toString() {
                        return this.src;
                    }
                };
            }

            function castChunk(chunk, codeGen, loc) {
                if (_utils.isArray(chunk)) {
                    var ret = [];

                    for (var i = 0, len = chunk.length; i < len; i++) {
                        ret.push(codeGen.wrap(chunk[i], loc));
                    }
                    return ret;
                } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
                    // Handle primitives that the SourceNode will throw up on
                    return chunk + '';
                }
                return chunk;
            }

            function CodeGen(srcFile) {
                this.srcFile = srcFile;
                this.source = [];
            }

            CodeGen.prototype = {
                isEmpty: function isEmpty() {
                    return !this.source.length;
                },
                prepend: function prepend(source, loc) {
                    this.source.unshift(this.wrap(source, loc));
                },
                push: function push(source, loc) {
                    this.source.push(this.wrap(source, loc));
                },

                merge: function merge() {
                    var source = this.empty();
                    this.each(function (line) {
                        source.add(['  ', line, '\n']);
                    });
                    return source;
                },

                each: function each(iter) {
                    for (var i = 0, len = this.source.length; i < len; i++) {
                        iter(this.source[i]);
                    }
                },

                empty: function empty() {
                    var loc = this.currentLocation || { start: {} };
                    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
                },
                wrap: function wrap(chunk) {
                    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

                    if (chunk instanceof SourceNode) {
                        return chunk;
                    }

                    chunk = castChunk(chunk, this, loc);

                    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
                },

                functionCall: function functionCall(fn, type, params) {
                    params = this.generateList(params);
                    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
                },

                quotedString: function quotedString(str) {
                    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
                        .replace(/\u2029/g, '\\u2029') + '"';
                },

                objectLiteral: function objectLiteral(obj) {
                    var pairs = [];

                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            var value = castChunk(obj[key], this);
                            if (value !== 'undefined') {
                                pairs.push([this.quotedString(key), ':', value]);
                            }
                        }
                    }

                    var ret = this.generateList(pairs);
                    ret.prepend('{');
                    ret.add('}');
                    return ret;
                },

                generateList: function generateList(entries) {
                    var ret = this.empty();

                    for (var i = 0, len = entries.length; i < len; i++) {
                        if (i) {
                            ret.add(',');
                        }

                        ret.add(castChunk(entries[i], this));
                    }

                    return ret;
                },

                generateArray: function generateArray(entries) {
                    var ret = this.generateList(entries);
                    ret.prepend('[');
                    ret.add(']');

                    return ret;
                }
            };

            exports['default'] = CodeGen;
            module.exports = exports['default'];

            /***/
        }
/******/])
});
;
function render(templateId, data) {
    var template = Handlebars.compile($(templateId).html());
    return template(data);
}

function renderInsideElement(templateId, target, data, callback) {
    var html = render(templateId, data);
    $(target).html(html).promise().done(callback);
}

/**
 * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most
 * recently used items while discarding least recently used items when its limit
 * is reached.
 *
 * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>
 * See README.md for details.
 *
 * Illustration of the design:
 *
 *       entry             entry             entry             entry
 *       ______            ______            ______            ______
 *      | head |.newer => |      |.newer => |      |.newer => | tail |
 *      |  A   |          |  B   |          |  C   |          |  D   |
 *      |______| <= older.|______| <= older.|______| <= older.|______|
 *
 *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added
 */
function LRUCache(limit) {
    // Current size of the cache. (Read-only).
    this.size = 0;
    // Maximum number of items this cache can hold.
    this.limit = limit;
    this._keymap = {};
}

/**
 * Put <value> into the cache associated with <key>. Returns the entry which was
 * removed to make room for the new entry. Otherwise undefined is returned
 * (i.e. if there was enough room already).
 */
LRUCache.prototype.put = function (key, value) {
    var entry = { key: key, value: value };
    // Note: No protection agains replacing, and thus orphan entries. By design.
    this._keymap[key] = entry;
    if (this.tail) {
        // link previous tail to the new tail (entry)
        this.tail.newer = entry;
        entry.older = this.tail;
    } else {
        // we're first in -- yay
        this.head = entry;
    }
    // add new entry to the end of the linked list -- it's now the freshest entry.
    this.tail = entry;
    if (this.size === this.limit) {
        // we hit the limit -- remove the head
        return this.shift();
    } else {
        // increase the size counter
        this.size++;
    }
};

/**
 * Purge the least recently used (oldest) entry from the cache. Returns the
 * removed entry or undefined if the cache was empty.
 *
 * If you need to perform any form of finalization of purged items, this is a
 * good place to do it. Simply override/replace this function:
 *
 *   var c = new LRUCache(123);
 *   c.shift = function() {
 *     var entry = LRUCache.prototype.shift.call(this);
 *     doSomethingWith(entry);
 *     return entry;
 *   }
 */
LRUCache.prototype.shift = function () {
    // todo: handle special case when limit == 1
    var entry = this.head;
    if (entry) {
        if (this.head.newer) {
            this.head = this.head.newer;
            this.head.older = undefined;
        } else {
            this.head = undefined;
        }
        // Remove last strong reference to <entry> and remove links from the purged
        // entry being returned:
        entry.newer = entry.older = undefined;
        // delete is slow, but we need to do this to avoid uncontrollable growth:
        delete this._keymap[entry.key];
    }
    return entry;
};

/**
 * Get and register recent use of <key>. Returns the value associated with <key>
 * or undefined if not in cache.
 */
LRUCache.prototype.get = function (key, returnEntry) {
    // First, find our cache entry
    var entry = this._keymap[key];
    if (entry === undefined) return; // Not cached. Sorry.
    // As <key> was found in the cache, register it as being requested recently
    if (entry === this.tail) {
        // Already the most recenlty used entry, so no need to update the list
        return returnEntry ? entry : entry.value;
    }
    // HEAD--------------TAIL
    //   <.older   .newer>
    //  <--- add direction --
    //   A  B  C  <D>  E
    if (entry.newer) {
        if (entry === this.head)
            this.head = entry.newer;
        entry.newer.older = entry.older; // C <-- E.
    }
    if (entry.older)
        entry.older.newer = entry.newer; // C. --> E
    entry.newer = undefined; // D --x
    entry.older = this.tail; // D. --> E
    if (this.tail)
        this.tail.newer = entry; // E. <-- D
    this.tail = entry;
    return returnEntry ? entry : entry.value;
};

// ----------------------------------------------------------------------------
// Following code is optional and can be removed without breaking the core
// functionality.

/**
 * Check if <key> is in the cache without registering recent use. Feasible if
 * you do not want to chage the state of the cache, but only "peek" at it.
 * Returns the entry associated with <key> if found, or undefined if not found.
 */
LRUCache.prototype.find = function (key) {
    return this._keymap[key];
};

/**
 * Update the value of entry with <key>. Returns the old value, or undefined if
 * entry was not in the cache.
 */
LRUCache.prototype.set = function (key, value) {
    var oldvalue, entry = this.get(key, true);
    if (entry) {
        oldvalue = entry.value;
        entry.value = value;
    } else {
        oldvalue = this.put(key, value);
        if (oldvalue) oldvalue = oldvalue.value;
    }
    return oldvalue;
};

/**
 * Remove entry <key> from cache and return its value. Returns undefined if not
 * found.
 */
LRUCache.prototype.remove = function (key) {
    var entry = this._keymap[key];
    if (!entry) return;
    delete this._keymap[entry.key]; // need to do delete unfortunately
    if (entry.newer && entry.older) {
        // relink the older entry with the newer entry
        entry.older.newer = entry.newer;
        entry.newer.older = entry.older;
    } else if (entry.newer) {
        // remove the link to us
        entry.newer.older = undefined;
        // link the newer entry to head
        this.head = entry.newer;
    } else if (entry.older) {
        // remove the link to us
        entry.older.newer = undefined;
        // link the newer entry to head
        this.tail = entry.older;
    } else {// if(entry.older === undefined && entry.newer === undefined) {
        this.head = this.tail = undefined;
    }

    this.size--;
    return entry.value;
};

/** Removes all entries */
LRUCache.prototype.removeAll = function () {
    // This should be safe, as we never expose strong refrences to the outside
    this.head = this.tail = undefined;
    this.size = 0;
    this._keymap = {};
};

/**
 * Return an array containing all keys of entries stored in the cache object, in
 * arbitrary order.
 */
if (typeof Object.keys === 'function') {
    LRUCache.prototype.keys = function () { return Object.keys(this._keymap); };
} else {
    LRUCache.prototype.keys = function () {
        var keys = [];
        for (var k in this._keymap) keys.push(k);
        return keys;
    };
}

/**
 * Call `fun` for each entry. Starting with the newest entry if `desc` is a true
 * value, otherwise starts with the oldest (head) enrty and moves towards the
 * tail.
 *
 * `fun` is called with 3 arguments in the context `context`:
 *   `fun.call(context, Object key, Object value, LRUCache self)`
 */
LRUCache.prototype.forEach = function (fun, context, desc) {
    var entry;
    if (context === true) { desc = true; context = undefined; }
    else if (typeof context !== 'object') context = this;
    if (desc) {
        entry = this.tail;
        while (entry) {
            fun.call(context, entry.key, entry.value, this);
            entry = entry.older;
        }
    } else {
        entry = this.head;
        while (entry) {
            fun.call(context, entry.key, entry.value, this);
            entry = entry.newer;
        }
    }
};

/** Returns a JSON (array) representation */
LRUCache.prototype.toJSON = function () {
    var s = [], entry = this.head;
    while (entry) {
        s.push({ key: entry.key.toJSON(), value: entry.value.toJSON() });
        entry = entry.newer;
    }
    return s;
};

/** Returns a String representation */
LRUCache.prototype.toString = function () {
    var s = '', entry = this.head;
    while (entry) {
        s += String(entry.key) + ':' + entry.value;
        entry = entry.newer;
        if (entry)
            s += ' < ';
    }
    return s;
};

// Export ourselves
if (typeof this === 'object') this.LRUCache = LRUCache;

var Bezier = function (t) { function n(i) { if (r[i]) return r[i].exports; var e = r[i] = { exports: {}, id: i, loaded: !1 }; return t[i].call(e.exports, e, e.exports, n), e.loaded = !0, e.exports } var r = {}; return n.m = t, n.c = r, n.p = "", n(0) }([function (t, n, r) { "use strict"; t.exports = r(1) }, function (t, n, r) { "use strict"; var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol ? "symbol" : typeof t }; !function () { function n(t, n, r, i, e) { "undefined" == typeof e && (e = .5); var o = y.projectionratio(e, t), s = 1 - o, u = { x: o * n.x + s * i.x, y: o * n.y + s * i.y }, a = y.abcratio(e, t), f = { x: r.x + (r.x - u.x) / a, y: r.y + (r.y - u.y) / a }; return { A: f, B: r, C: u } } var e = Math.abs, o = Math.min, s = Math.max, u = Math.cos, a = Math.sin, f = Math.acos, c = Math.sqrt, h = Math.PI, x = { x: 0, y: 0, z: 0 }, y = r(2), p = r(3), l = function (t) { var n = t && t.forEach ? t : [].slice.call(arguments), r = !1; if ("object" === i(n[0])) { r = n.length; var o = []; n.forEach(function (t) { ["x", "y", "z"].forEach(function (n) { "undefined" != typeof t[n] && o.push(t[n]) }) }), n = o } var s = !1, u = n.length; if (r) { if (r > 4) { if (1 !== arguments.length) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves"); s = !0 } } else if (6 !== u && 8 !== u && 9 !== u && 12 !== u && 1 !== arguments.length) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves"); var a = !s && (9 === u || 12 === u) || t && t[0] && "undefined" != typeof t[0].z; this._3d = a; for (var f = [], c = 0, h = a ? 3 : 2; u > c; c += h) { var x = { x: n[c], y: n[c + 1] }; a && (x.z = n[c + 2]), f.push(x) } this.order = f.length - 1, this.points = f; var p = ["x", "y"]; a && p.push("z"), this.dims = p, this.dimlen = p.length, function (t) { for (var n = t.order, r = t.points, i = y.align(r, { p1: r[0], p2: r[n] }), o = 0; o < i.length; o++)if (e(i[o].y) > 1e-4) return void (t._linear = !1); t._linear = !0 }(this), this._t1 = 0, this._t2 = 1, this.update() }; l.fromSVG = function (t) { var n = t.match(/[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g).map(parseFloat), r = /[cq]/.test(t); return r ? (n = n.map(function (t, r) { return 2 > r ? t : t + n[r % 2] }), new l(n)) : new l(n) }, l.quadraticFromPoints = function (t, r, i, e) { if ("undefined" == typeof e && (e = .5), 0 === e) return new l(r, r, i); if (1 === e) return new l(t, r, r); var o = n(2, t, r, i, e); return new l(t, o.A, i) }, l.cubicFromPoints = function (t, r, i, e, o) { "undefined" == typeof e && (e = .5); var s = n(3, t, r, i, e); "undefined" == typeof o && (o = y.dist(r, s.C)); var u = o * (1 - e) / e, a = y.dist(t, i), f = (i.x - t.x) / a, c = (i.y - t.y) / a, h = o * f, x = o * c, p = u * f, v = u * c, d = { x: r.x - h, y: r.y - x }, m = { x: r.x + p, y: r.y + v }, g = s.A, z = { x: g.x + (d.x - g.x) / (1 - e), y: g.y + (d.y - g.y) / (1 - e) }, b = { x: g.x + (m.x - g.x) / e, y: g.y + (m.y - g.y) / e }, _ = { x: t.x + (z.x - t.x) / e, y: t.y + (z.y - t.y) / e }, w = { x: i.x + (b.x - i.x) / (1 - e), y: i.y + (b.y - i.y) / (1 - e) }; return new l(t, _, w, i) }; var v = function () { return y }; l.getUtils = v, l.prototype = { getUtils: v, valueOf: function () { return this.toString() }, toString: function () { return y.pointsToString(this.points) }, toSVG: function (t) { if (this._3d) return !1; for (var n = this.points, r = n[0].x, i = n[0].y, e = ["M", r, i, 2 === this.order ? "Q" : "C"], o = 1, s = n.length; s > o; o++)e.push(n[o].x), e.push(n[o].y); return e.join(" ") }, update: function () { this.dpoints = []; for (var t = this.points, n = t.length, r = n - 1; n > 1; n--, r--) { for (var i, e = [], o = 0; r > o; o++)i = { x: r * (t[o + 1].x - t[o].x), y: r * (t[o + 1].y - t[o].y) }, this._3d && (i.z = r * (t[o + 1].z - t[o].z)), e.push(i); this.dpoints.push(e), t = e } this.computedirection() }, computedirection: function () { var t = this.points, n = y.angle(t[0], t[this.order], t[1]); this.clockwise = n > 0 }, length: function () { return y.length(this.derivative.bind(this)) }, _lut: [], getLUT: function (t) { if (t = t || 100, this._lut.length === t) return this._lut; this._lut = []; for (var n = 0; t >= n; n++)this._lut.push(this.compute(n / t)); return this._lut }, on: function (t, n) { n = n || 5; for (var r, i = this.getLUT(), e = [], o = 0, s = 0; s < i.length; s++)r = i[s], y.dist(r, t) < n && (e.push(r), o += s / i.length); return e.length ? o /= e.length : !1 }, project: function (t) { var n = this.getLUT(), r = n.length - 1, i = y.closest(n, t), e = i.mdist, o = i.mpos; if (0 === o || o === r) { var s = o / r, u = this.compute(s); return u.t = s, u.d = e, u } var a, s, f, c, h = (o - 1) / r, x = (o + 1) / r, p = .1 / r; for (e += 1, s = h, a = s; x + p > s; s += p)f = this.compute(s), c = y.dist(t, f), e > c && (e = c, a = s); return f = this.compute(a), f.t = a, f.d = e, f }, get: function (t) { return this.compute(t) }, point: function (t) { return this.points[t] }, compute: function (t) { if (0 === t) return this.points[0]; if (1 === t) return this.points[this.order]; var n = this.points, r = 1 - t; if (1 === this.order) return f = { x: r * n[0].x + t * n[1].x, y: r * n[0].y + t * n[1].y }, this._3d && (f.z = r * n[0].z + t * n[1].z), f; if (this.order < 4) { var i, e, o, s = r * r, u = t * t, a = 0; 2 === this.order ? (n = [n[0], n[1], n[2], x], i = s, e = r * t * 2, o = u) : 3 === this.order && (i = s * r, e = s * t * 3, o = r * u * 3, a = t * u); var f = { x: i * n[0].x + e * n[1].x + o * n[2].x + a * n[3].x, y: i * n[0].y + e * n[1].y + o * n[2].y + a * n[3].y }; return this._3d && (f.z = i * n[0].z + e * n[1].z + o * n[2].z + a * n[3].z), f } for (var c = JSON.parse(JSON.stringify(this.points)); c.length > 1;) { for (var h = 0; h < c.length - 1; h++)c[h] = { x: c[h].x + (c[h + 1].x - c[h].x) * t, y: c[h].y + (c[h + 1].y - c[h].y) * t }, "undefined" != typeof c[h].z && (c[h] = c[h].z + (c[h + 1].z - c[h].z) * t); c.splice(c.length - 1, 1) } return c[0] }, raise: function () { for (var t, n, r, i = this.points, e = [i[0]], o = i.length, t = 1; o > t; t++)n = i[t], r = i[t - 1], e[t] = { x: (o - t) / o * n.x + t / o * r.x, y: (o - t) / o * n.y + t / o * r.y }; return e[o] = i[o - 1], new l(e) }, derivative: function (t) { var n, r, i = 1 - t, e = 0, o = this.dpoints[0]; 2 === this.order && (o = [o[0], o[1], x], n = i, r = t), 3 === this.order && (n = i * i, r = i * t * 2, e = t * t); var s = { x: n * o[0].x + r * o[1].x + e * o[2].x, y: n * o[0].y + r * o[1].y + e * o[2].y }; return this._3d && (s.z = n * o[0].z + r * o[1].z + e * o[2].z), s }, inflections: function () { return y.inflections(this.points) }, normal: function (t) { return this._3d ? this.__normal3(t) : this.__normal2(t) }, __normal2: function (t) { var n = this.derivative(t), r = c(n.x * n.x + n.y * n.y); return { x: -n.y / r, y: n.x / r } }, __normal3: function (t) { var n = this.derivative(t), r = this.derivative(t + .01), i = c(n.x * n.x + n.y * n.y + n.z * n.z), e = c(r.x * r.x + r.y * r.y + r.z * r.z); n.x /= i, n.y /= i, n.z /= i, r.x /= e, r.y /= e, r.z /= e; var o = { x: r.y * n.z - r.z * n.y, y: r.z * n.x - r.x * n.z, z: r.x * n.y - r.y * n.x }, s = c(o.x * o.x + o.y * o.y + o.z * o.z); o.x /= s, o.y /= s, o.z /= s; var u = [o.x * o.x, o.x * o.y - o.z, o.x * o.z + o.y, o.x * o.y + o.z, o.y * o.y, o.y * o.z - o.x, o.x * o.z - o.y, o.y * o.z + o.x, o.z * o.z], a = { x: u[0] * n.x + u[1] * n.y + u[2] * n.z, y: u[3] * n.x + u[4] * n.y + u[5] * n.z, z: u[6] * n.x + u[7] * n.y + u[8] * n.z }; return a }, hull: function (t) { var n, r = this.points, i = [], e = [], o = 0, s = 0, u = 0; for (e[o++] = r[0], e[o++] = r[1], e[o++] = r[2], 3 === this.order && (e[o++] = r[3]); r.length > 1;) { for (i = [], s = 0, u = r.length - 1; u > s; s++)n = y.lerp(t, r[s], r[s + 1]), e[o++] = n, i.push(n); r = i } return e }, split: function (t, n) { if (0 === t && n) return this.split(n).left; if (1 === n) return this.split(t).right; var r = this.hull(t), i = { left: new l(2 === this.order ? [r[0], r[3], r[5]] : [r[0], r[4], r[7], r[9]]), right: new l(2 === this.order ? [r[5], r[4], r[2]] : [r[9], r[8], r[6], r[3]]), span: r }; if (i.left._t1 = y.map(0, 0, 1, this._t1, this._t2), i.left._t2 = y.map(t, 0, 1, this._t1, this._t2), i.right._t1 = y.map(t, 0, 1, this._t1, this._t2), i.right._t2 = y.map(1, 0, 1, this._t1, this._t2), !n) return i; n = y.map(n, t, 1, 0, 1); var e = i.right.split(n); return e.left }, extrema: function () { var t, n, r = this.dims, i = {}, e = []; return r.forEach(function (r) { n = function (t) { return t[r] }, t = this.dpoints[0].map(n), i[r] = y.droots(t), 3 === this.order && (t = this.dpoints[1].map(n), i[r] = i[r].concat(y.droots(t))), i[r] = i[r].filter(function (t) { return t >= 0 && 1 >= t }), e = e.concat(i[r].sort()) }.bind(this)), e = e.sort().filter(function (t, n) { return e.indexOf(t) === n }), i.values = e, i }, bbox: function () { var t = this.extrema(), n = {}; return this.dims.forEach(function (r) { n[r] = y.getminmax(this, r, t[r]) }.bind(this)), n }, overlaps: function (t) { var n = this.bbox(), r = t.bbox(); return y.bboxoverlap(n, r) }, offset: function (t, n) { if ("undefined" != typeof n) { var r = this.get(t), i = this.normal(t), e = { c: r, n: i, x: r.x + i.x * n, y: r.y + i.y * n }; return this._3d && (e.z = r.z + i.z * n), e } if (this._linear) { var o = this.normal(0), s = this.points.map(function (n) { var r = { x: n.x + t * o.x, y: n.y + t * o.y }; return n.z && i.z && (r.z = n.z + t * o.z), r }); return [new l(s)] } var u = this.reduce(); return u.map(function (n) { return n.scale(t) }) }, simple: function () { if (3 === this.order) { var t = y.angle(this.points[0], this.points[3], this.points[1]), n = y.angle(this.points[0], this.points[3], this.points[2]); if (t > 0 && 0 > n || 0 > t && n > 0) return !1 } var r = this.normal(0), i = this.normal(1), o = r.x * i.x + r.y * i.y; this._3d && (o += r.z * i.z); var s = e(f(o)); return h / 3 > s }, reduce: function () { var t, n, r = 0, i = 0, o = .01, s = [], u = [], a = this.extrema().values; for (-1 === a.indexOf(0) && (a = [0].concat(a)), -1 === a.indexOf(1) && a.push(1), r = a[0], t = 1; t < a.length; t++)i = a[t], n = this.split(r, i), n._t1 = r, n._t2 = i, s.push(n), r = i; return s.forEach(function (t) { for (r = 0, i = 0; 1 >= i;)for (i = r + o; 1 + o >= i; i += o)if (n = t.split(r, i), !n.simple()) { if (i -= o, e(r - i) < o) return []; n = t.split(r, i), n._t1 = y.map(r, 0, 1, t._t1, t._t2), n._t2 = y.map(i, 0, 1, t._t1, t._t2), u.push(n), r = i; break } 1 > r && (n = t.split(r, 1), n._t1 = y.map(r, 0, 1, t._t1, t._t2), n._t2 = t._t2, u.push(n)) }), u }, scale: function (t) { var n = this.order, r = !1; if ("function" == typeof t && (r = t), r && 2 === n) return this.raise().scale(r); var i = this.clockwise, e = r ? r(0) : t, o = r ? r(1) : t, s = [this.offset(0, 10), this.offset(1, 10)], u = y.lli4(s[0], s[0].c, s[1], s[1].c); if (!u) throw new Error("cannot scale this curve. Try reducing it first."); var a = this.points, f = []; return [0, 1].forEach(function (t) { var r = f[t * n] = y.copy(a[t * n]); r.x += (t ? o : e) * s[t].n.x, r.y += (t ? o : e) * s[t].n.y }.bind(this)), r ? ([0, 1].forEach(function (e) { if (2 !== this.order || !e) { var o = a[e + 1], s = { x: o.x - u.x, y: o.y - u.y }, h = r ? r((e + 1) / n) : t; r && !i && (h = -h); var x = c(s.x * s.x + s.y * s.y); s.x /= x, s.y /= x, f[e + 1] = { x: o.x + h * s.x, y: o.y + h * s.y } } }.bind(this)), new l(f)) : ([0, 1].forEach(function (t) { if (2 !== this.order || !t) { var r = f[t * n], i = this.derivative(t), e = { x: r.x + i.x, y: r.y + i.y }; f[t + 1] = y.lli4(r, e, u, a[t + 1]) } }.bind(this)), new l(f)) }, outline: function (t, n, r, i) { function e(t, n, r, i, e) { return function (o) { var s = i / r, u = (i + e) / r, a = n - t; return y.map(o, 0, 1, t + s * a, t + u * a) } } n = "undefined" == typeof n ? t : n; var o, s = this.reduce(), u = s.length, a = [], f = [], c = 0, h = this.length(), x = "undefined" != typeof r && "undefined" != typeof i; s.forEach(function (o) { _ = o.length(), x ? (a.push(o.scale(e(t, r, h, c, _))), f.push(o.scale(e(-n, -i, h, c, _)))) : (a.push(o.scale(t)), f.push(o.scale(-n))), c += _ }), f = f.map(function (t) { return o = t.points, o[3] ? t.points = [o[3], o[2], o[1], o[0]] : t.points = [o[2], o[1], o[0]], t }).reverse(); var l = a[0].points[0], v = a[u - 1].points[a[u - 1].points.length - 1], d = f[u - 1].points[f[u - 1].points.length - 1], m = f[0].points[0], g = y.makeline(d, l), z = y.makeline(v, m), b = [g].concat(a).concat([z]).concat(f), _ = b.length; return new p(b) }, outlineshapes: function (t, n, r) { n = n || t; for (var i = this.outline(t, n).curves, e = [], o = 1, s = i.length; s / 2 > o; o++) { var u = y.makeshape(i[o], i[s - o], r); u.startcap.virtual = o > 1, u.endcap.virtual = s / 2 - 1 > o, e.push(u) } return e }, intersects: function (t, n) { return t ? t.p1 && t.p2 ? this.lineIntersects(t) : (t instanceof l && (t = t.reduce()), this.curveintersects(this.reduce(), t, n)) : this.selfintersects(n) }, lineIntersects: function (t) { var n = o(t.p1.x, t.p2.x), r = o(t.p1.y, t.p2.y), i = s(t.p1.x, t.p2.x), e = s(t.p1.y, t.p2.y), u = this; return y.roots(this.points, t).filter(function (t) { var o = u.get(t); return y.between(o.x, n, i) && y.between(o.y, r, e) }) }, selfintersects: function (t) { var n, r, i, e, o = this.reduce(), s = o.length - 2, u = []; for (n = 0; s > n; n++)i = o.slice(n, n + 1), e = o.slice(n + 2), r = this.curveintersects(i, e, t), u = u.concat(r); return u }, curveintersects: function (t, n, r) { var i = []; t.forEach(function (t) { n.forEach(function (n) { t.overlaps(n) && i.push({ left: t, right: n }) }) }); var e = []; return i.forEach(function (t) { var n = y.pairiteration(t.left, t.right, r); n.length > 0 && (e = e.concat(n)) }), e }, arcs: function (t) { t = t || .5; var n = []; return this._iterate(t, n) }, _error: function (t, n, r, i) { var o = (i - r) / 4, s = this.get(r + o), u = this.get(i - o), a = y.dist(t, n), f = y.dist(t, s), c = y.dist(t, u); return e(f - a) + e(c - a) }, _iterate: function (t, n) { var r, i = 0, e = 1; do { r = 0, e = 1; var o, s, f, c, h, x = this.get(i), p = !1, l = !1, v = e, d = 1, m = 0; do { l = p, c = f, v = (i + e) / 2, m++, o = this.get(v), s = this.get(e), f = y.getccenter(x, o, s), f.interval = { start: i, end: e }; var g = this._error(f, x, i, e); if (p = t >= g, h = l && !p, h || (d = e), p) { if (e >= 1) { if (f.interval.end = d = 1, c = f, e > 1) { var z = { x: f.x + f.r * u(f.e), y: f.y + f.r * a(f.e) }; f.e += y.angle({ x: f.x, y: f.y }, z, this.get(1)) } break } e += (e - i) / 2 } else e = v } while (!h && r++ < 100); if (r >= 100) break; c = c ? c : f, n.push(c), i = d } while (1 > e); return n } }, t.exports = l }() }, function (t, n, r) { "use strict"; !function () { var n = Math.abs, i = Math.cos, e = Math.sin, o = Math.acos, s = Math.atan2, u = Math.sqrt, a = Math.pow, f = function (t) { return 0 > t ? -a(-t, 1 / 3) : a(t, 1 / 3) }, c = Math.PI, h = 2 * c, x = c / 2, y = 1e-6, p = Number.MAX_SAFE_INTEGER, l = Number.MIN_SAFE_INTEGER, v = { Tvalues: [-.06405689286260563, .06405689286260563, -.1911188674736163, .1911188674736163, -.3150426796961634, .3150426796961634, -.4337935076260451, .4337935076260451, -.5454214713888396, .5454214713888396, -.6480936519369755, .6480936519369755, -.7401241915785544, .7401241915785544, -.820001985973903, .820001985973903, -.8864155270044011, .8864155270044011, -.9382745520027328, .9382745520027328, -.9747285559713095, .9747285559713095, -.9951872199970213, .9951872199970213], Cvalues: [.12793819534675216, .12793819534675216, .1258374563468283, .1258374563468283, .12167047292780339, .12167047292780339, .1155056680537256, .1155056680537256, .10744427011596563, .10744427011596563, .09761865210411388, .09761865210411388, .08619016153195327, .08619016153195327, .0733464814110803, .0733464814110803, .05929858491543678, .05929858491543678, .04427743881741981, .04427743881741981, .028531388628933663, .028531388628933663, .0123412297999872, .0123412297999872], arcfn: function (t, n) { var r = n(t), i = r.x * r.x + r.y * r.y; return "undefined" != typeof r.z && (i += r.z * r.z), u(i) }, between: function (t, n, r) { return t >= n && r >= t || v.approximately(t, n) || v.approximately(t, r) }, approximately: function (t, r, i) { return n(t - r) <= (i || y) }, length: function (t) { var n, r, i = .5, e = 0, o = v.Tvalues.length; for (n = 0; o > n; n++)r = i * v.Tvalues[n] + i, e += v.Cvalues[n] * v.arcfn(r, t); return i * e }, map: function (t, n, r, i, e) { var o = r - n, s = e - i, u = t - n, a = u / o; return i + s * a }, lerp: function (t, n, r) { var i = { x: n.x + t * (r.x - n.x), y: n.y + t * (r.y - n.y) }; return n.z && r.z && (i.z = n.z + t * (r.z - n.z)), i }, pointToString: function (t) { var n = t.x + "/" + t.y; return "undefined" != typeof t.z && (n += "/" + t.z), n }, pointsToString: function (t) { return "[" + t.map(v.pointToString).join(", ") + "]" }, copy: function (t) { return JSON.parse(JSON.stringify(t)) }, angle: function (t, n, r) { var i = n.x - t.x, e = n.y - t.y, o = r.x - t.x, u = r.y - t.y, a = i * u - e * o, f = i * o + e * u; return s(a, f) }, round: function (t, n) { var r = "" + t, i = r.indexOf("."); return parseFloat(r.substring(0, i + 1 + n)) }, dist: function (t, n) { var r = t.x - n.x, i = t.y - n.y; return u(r * r + i * i) }, closest: function (t, n) { var r, i, e = a(2, 63); return t.forEach(function (t, o) { i = v.dist(n, t), e > i && (e = i, r = o) }), { mdist: e, mpos: r } }, abcratio: function (t, r) { if (2 !== r && 3 !== r) return !1; if ("undefined" == typeof t) t = .5; else if (0 === t || 1 === t) return t; var i = a(t, r) + a(1 - t, r), e = i - 1; return n(e / i) }, projectionratio: function (t, n) { if (2 !== n && 3 !== n) return !1; if ("undefined" == typeof t) t = .5; else if (0 === t || 1 === t) return t; var r = a(1 - t, n), i = a(t, n) + r; return r / i }, lli8: function (t, n, r, i, e, o, s, u) { var a = (t * i - n * r) * (e - s) - (t - r) * (e * u - o * s), f = (t * i - n * r) * (o - u) - (n - i) * (e * u - o * s), c = (t - r) * (o - u) - (n - i) * (e - s); return 0 == c ? !1 : { x: a / c, y: f / c } }, lli4: function (t, n, r, i) { var e = t.x, o = t.y, s = n.x, u = n.y, a = r.x, f = r.y, c = i.x, h = i.y; return v.lli8(e, o, s, u, a, f, c, h) }, lli: function (t, n) { return v.lli4(t, t.c, n, n.c) }, makeline: function (t, n) { var i = r(1), e = t.x, o = t.y, s = n.x, u = n.y, a = (s - e) / 3, f = (u - o) / 3; return new i(e, o, e + a, o + f, e + 2 * a, o + 2 * f, s, u) }, findbbox: function (t) { var n = p, r = p, i = l, e = l; return t.forEach(function (t) { var o = t.bbox(); n > o.x.min && (n = o.x.min), r > o.y.min && (r = o.y.min), i < o.x.max && (i = o.x.max), e < o.y.max && (e = o.y.max) }), { x: { min: n, mid: (n + i) / 2, max: i, size: i - n }, y: { min: r, mid: (r + e) / 2, max: e, size: e - r } } }, shapeintersections: function (t, n, r, i, e) { if (!v.bboxoverlap(n, i)) return []; var o = [], s = [t.startcap, t.forward, t.back, t.endcap], u = [r.startcap, r.forward, r.back, r.endcap]; return s.forEach(function (n) { n.virtual || u.forEach(function (i) { if (!i.virtual) { var s = n.intersects(i, e); s.length > 0 && (s.c1 = n, s.c2 = i, s.s1 = t, s.s2 = r, o.push(s)) } }) }), o }, makeshape: function (t, n, r) { var i = n.points.length, e = t.points.length, o = v.makeline(n.points[i - 1], t.points[0]), s = v.makeline(t.points[e - 1], n.points[0]), u = { startcap: o, forward: t, back: n, endcap: s, bbox: v.findbbox([o, t, n, s]) }, a = v; return u.intersections = function (t) { return a.shapeintersections(u, u.bbox, t, t.bbox, r) }, u }, getminmax: function (t, n, r) { if (!r) return { min: 0, max: 0 }; var i, e, o = p, s = l; -1 === r.indexOf(0) && (r = [0].concat(r)), -1 === r.indexOf(1) && r.push(1); for (var u = 0, a = r.length; a > u; u++)i = r[u], e = t.get(i), e[n] < o && (o = e[n]), e[n] > s && (s = e[n]); return { min: o, mid: (o + s) / 2, max: s, size: s - o } }, align: function (t, n) { var r = n.p1.x, o = n.p1.y, u = -s(n.p2.y - o, n.p2.x - r), a = function (t) { return { x: (t.x - r) * i(u) - (t.y - o) * e(u), y: (t.x - r) * e(u) + (t.y - o) * i(u) } }; return t.map(a) }, roots: function (t, n) { n = n || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } }; var r = t.length - 1, e = v.align(t, n), s = function (t) { return t >= 0 && 1 >= t }; if (2 === r) { var a = e[0].y, c = e[1].y, x = e[2].y, y = a - 2 * c + x; if (0 !== y) { var p = -u(c * c - a * x), l = -a + c, d = -(p + l) / y, m = -(-p + l) / y; return [d, m].filter(s) } return c !== x && 0 === y ? [(2 * c - x) / 2 * (c - x)].filter(s) : [] } var g, d, z, b, _, w = e[0].y, E = e[1].y, S = e[2].y, M = e[3].y, y = -w + 3 * E - 3 * S + M, a = (3 * w - 6 * E + 3 * S) / y, c = (-3 * w + 3 * E) / y, x = w / y, e = (3 * c - a * a) / 3, k = e / 3, O = (2 * a * a * a - 9 * a * c + 27 * x) / 27, T = O / 2, N = T * T + k * k * k; if (0 > N) { var j = -e / 3, I = j * j * j, A = u(I), C = -O / (2 * A), F = -1 > C ? -1 : C > 1 ? 1 : C, q = o(F), U = f(A), B = 2 * U; return z = B * i(q / 3) - a / 3, b = B * i((q + h) / 3) - a / 3, _ = B * i((q + 2 * h) / 3) - a / 3, [z, b, _].filter(s) } if (0 === N) return g = 0 > T ? f(-T) : -f(T), z = 2 * g - a / 3, b = -g - a / 3, [z, b].filter(s); var G = u(N); return g = f(-T + G), d = f(T + G), [g - d - a / 3].filter(s) }, droots: function (t) { if (3 === t.length) { var n = t[0], r = t[1], i = t[2], e = n - 2 * r + i; if (0 !== e) { var o = -u(r * r - n * i), s = -n + r, a = -(o + s) / e, f = -(-o + s) / e; return [a, f] } return r !== i && 0 === e ? [(2 * r - i) / (2 * (r - i))] : [] } if (2 === t.length) { var n = t[0], r = t[1]; return n !== r ? [n / (n - r)] : [] } }, inflections: function (t) { if (t.length < 4) return []; var n = v.align(t, { p1: t[0], p2: t.slice(-1)[0] }), r = n[2].x * n[1].y, i = n[3].x * n[1].y, e = n[1].x * n[2].y, o = n[3].x * n[2].y, s = 18 * (-3 * r + 2 * i + 3 * e - o), u = 18 * (3 * r - i - 3 * e), a = 18 * (e - r); if (v.approximately(s, 0)) { if (!v.approximately(u, 0)) { var f = -a / u; if (f >= 0 && 1 >= f) return [f] } return [] } var c = u * u - 4 * s * a, h = Math.sqrt(c), o = 2 * s; return v.approximately(o, 0) ? [] : [(h - u) / o, -(u + h) / o].filter(function (t) { return t >= 0 && 1 >= t }) }, bboxoverlap: function (t, r) { var i, e, o, s, u, a = ["x", "y"], f = a.length; for (i = 0; f > i; i++)if (e = a[i], o = t[e].mid, s = r[e].mid, u = (t[e].size + r[e].size) / 2, n(o - s) >= u) return !1; return !0 }, expandbox: function (t, n) { n.x.min < t.x.min && (t.x.min = n.x.min), n.y.min < t.y.min && (t.y.min = n.y.min), n.z && n.z.min < t.z.min && (t.z.min = n.z.min), n.x.max > t.x.max && (t.x.max = n.x.max), n.y.max > t.y.max && (t.y.max = n.y.max), n.z && n.z.max > t.z.max && (t.z.max = n.z.max), t.x.mid = (t.x.min + t.x.max) / 2, t.y.mid = (t.y.min + t.y.max) / 2, t.z && (t.z.mid = (t.z.min + t.z.max) / 2), t.x.size = t.x.max - t.x.min, t.y.size = t.y.max - t.y.min, t.z && (t.z.size = t.z.max - t.z.min) }, pairiteration: function (t, n, r) { var i = t.bbox(), e = n.bbox(), o = 1e5, s = r || .5; if (i.x.size + i.y.size < s && e.x.size + e.y.size < s) return [(o * (t._t1 + t._t2) / 2 | 0) / o + "/" + (o * (n._t1 + n._t2) / 2 | 0) / o]; var u = t.split(.5), a = n.split(.5), f = [{ left: u.left, right: a.left }, { left: u.left, right: a.right }, { left: u.right, right: a.right }, { left: u.right, right: a.left }]; f = f.filter(function (t) { return v.bboxoverlap(t.left.bbox(), t.right.bbox()) }); var c = []; return 0 === f.length ? c : (f.forEach(function (t) { c = c.concat(v.pairiteration(t.left, t.right, s)) }), c = c.filter(function (t, n) { return c.indexOf(t) === n })) }, getccenter: function (t, n, r) { var o, u = n.x - t.x, a = n.y - t.y, f = r.x - n.x, c = r.y - n.y, y = u * i(x) - a * e(x), p = u * e(x) + a * i(x), l = f * i(x) - c * e(x), d = f * e(x) + c * i(x), m = (t.x + n.x) / 2, g = (t.y + n.y) / 2, z = (n.x + r.x) / 2, b = (n.y + r.y) / 2, _ = m + y, w = g + p, E = z + l, S = b + d, M = v.lli8(m, g, _, w, z, b, E, S), k = v.dist(M, t), O = s(t.y - M.y, t.x - M.x), T = s(n.y - M.y, n.x - M.x), N = s(r.y - M.y, r.x - M.x); return N > O ? ((O > T || T > N) && (O += h), O > N && (o = N, N = O, O = o)) : T > N && O > T ? (o = N, N = O, O = o) : N += h, M.s = O, M.e = N, M.r = k, M } }; t.exports = v }() }, function (t, n, r) { "use strict"; !function () { var n = r(2), i = function (t) { this.curves = [], this._3d = !1, t && (this.curves = t, this._3d = this.curves[0]._3d) }; i.prototype = { valueOf: function () { return this.toString() }, toString: function () { return "[" + this.curves.map(function (t) { return n.pointsToString(t.points) }).join(", ") + "]" }, addCurve: function (t) { this.curves.push(t), this._3d = this._3d || t._3d }, length: function () { return this.curves.map(function (t) { return t.length() }).reduce(function (t, n) { return t + n }) }, curve: function (t) { return this.curves[t] }, bbox: function e() { for (var t = this.curves, e = t[0].bbox(), r = 1; r < t.length; r++)n.expandbox(e, t[r].bbox()); return e }, offset: function o(t) { var o = []; return this.curves.forEach(function (n) { o = o.concat(n.offset(t)) }), new i(o) } }, t.exports = i }() }]);
/**
 * bootbox.js v4.4.0
 *
 * http://bootboxjs.com/license.txt
 */
!function (a, b) { "use strict"; "function" == typeof define && define.amd ? define(["jquery"], b) : "object" == typeof exports ? module.exports = b(require("jquery")) : a.bootbox = b(a.jQuery) }(this, function a(b, c) { "use strict"; function d(a) { var b = q[o.locale]; return b ? b[a] : q.en[a] } function e(a, c, d) { a.stopPropagation(), a.preventDefault(); var e = b.isFunction(d) && d.call(c, a) === !1; e || c.modal("hide") } function f(a) { var b, c = 0; for (b in a) c++; return c } function g(a, c) { var d = 0; b.each(a, function (a, b) { c(a, b, d++) }) } function h(a) { var c, d; if ("object" != typeof a) throw new Error("Please supply an object of options"); if (!a.message) throw new Error("Please specify a message"); return a = b.extend({}, o, a), a.buttons || (a.buttons = {}), c = a.buttons, d = f(c), g(c, function (a, e, f) { if (b.isFunction(e) && (e = c[a] = { callback: e }), "object" !== b.type(e)) throw new Error("button with key " + a + " must be an object"); e.label || (e.label = a), e.className || (e.className = 2 >= d && f === d - 1 ? "btn-primary" : "btn-default") }), a } function i(a, b) { var c = a.length, d = {}; if (1 > c || c > 2) throw new Error("Invalid argument length"); return 2 === c || "string" == typeof a[0] ? (d[b[0]] = a[0], d[b[1]] = a[1]) : d = a[0], d } function j(a, c, d) { return b.extend(!0, {}, a, i(c, d)) } function k(a, b, c, d) { var e = { className: "bootbox-" + a, buttons: l.apply(null, b) }; return m(j(e, d, c), b) } function l() { for (var a = {}, b = 0, c = arguments.length; c > b; b++) { var e = arguments[b], f = e.toLowerCase(), g = e.toUpperCase(); a[f] = { label: d(g) } } return a } function m(a, b) { var d = {}; return g(b, function (a, b) { d[b] = !0 }), g(a.buttons, function (a) { if (d[a] === c) throw new Error("button key " + a + " is not allowed (options are " + b.join("\n") + ")") }), a } var n = { dialog: "<div class='bootbox modal' tabindex='-1' role='dialog'><div class='modal-dialog'><div class='modal-content'><div class='modal-body'><div class='bootbox-body'></div></div></div></div></div>", header: "<div class='modal-header'><h4 class='modal-title'></h4></div>", footer: "<div class='modal-footer'></div>", closeButton: "<button type='button' class='bootbox-close-button close' data-dismiss='modal' aria-hidden='true'>&times;</button>", form: "<form class='bootbox-form'></form>", inputs: { text: "<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text />", textarea: "<textarea class='bootbox-input bootbox-input-textarea form-control'></textarea>", email: "<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' />", select: "<select class='bootbox-input bootbox-input-select form-control'></select>", checkbox: "<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' /></label></div>", date: "<input class='bootbox-input bootbox-input-date form-control' autocomplete=off type='date' />", time: "<input class='bootbox-input bootbox-input-time form-control' autocomplete=off type='time' />", number: "<input class='bootbox-input bootbox-input-number form-control' autocomplete=off type='number' />", password: "<input class='bootbox-input bootbox-input-password form-control' autocomplete='off' type='password' />" } }, o = { locale: "en", backdrop: "static", animate: !0, className: null, closeButton: !0, show: !0, container: "#frameIdMercator" }, p = {}; p.alert = function () { var a; if (a = k("alert", ["ok"], ["message", "callback"], arguments), a.callback && !b.isFunction(a.callback)) throw new Error("alert requires callback property to be a function when provided"); return a.buttons.ok.callback = a.onEscape = function () { return b.isFunction(a.callback) ? a.callback.call(this) : !0 }, p.dialog(a) }, p.confirm = function () { var a; if (a = k("confirm", ["cancel", "confirm"], ["message", "callback"], arguments), a.buttons.cancel.callback = a.onEscape = function () { return a.callback.call(this, !1) }, a.buttons.confirm.callback = function () { return a.callback.call(this, !0) }, !b.isFunction(a.callback)) throw new Error("confirm requires a callback"); return p.dialog(a) }, p.prompt = function () { var a, d, e, f, h, i, k; if (f = b(n.form), d = { className: "bootbox-prompt", buttons: l("cancel", "confirm"), value: "", inputType: "text" }, a = m(j(d, arguments, ["title", "callback"]), ["cancel", "confirm"]), i = a.show === c ? !0 : a.show, a.message = f, a.buttons.cancel.callback = a.onEscape = function () { return a.callback.call(this, null) }, a.buttons.confirm.callback = function () { var c; switch (a.inputType) { case "text": case "textarea": case "email": case "select": case "date": case "time": case "number": case "password": c = h.val(); break; case "checkbox": var d = h.find("input:checked"); c = [], g(d, function (a, d) { c.push(b(d).val()) }) }return a.callback.call(this, c) }, a.show = !1, !a.title) throw new Error("prompt requires a title"); if (!b.isFunction(a.callback)) throw new Error("prompt requires a callback"); if (!n.inputs[a.inputType]) throw new Error("invalid prompt type"); switch (h = b(n.inputs[a.inputType]), a.inputType) { case "text": case "textarea": case "email": case "date": case "time": case "number": case "password": h.val(a.value); break; case "select": var o = {}; if (k = a.inputOptions || [], !b.isArray(k)) throw new Error("Please pass an array of input options"); if (!k.length) throw new Error("prompt with select requires options"); g(k, function (a, d) { var e = h; if (d.value === c || d.text === c) throw new Error("given options in wrong format"); d.group && (o[d.group] || (o[d.group] = b("<optgroup/>").attr("label", d.group)), e = o[d.group]), e.append("<option value='" + d.value + "'>" + d.text + "</option>") }), g(o, function (a, b) { h.append(b) }), h.val(a.value); break; case "checkbox": var q = b.isArray(a.value) ? a.value : [a.value]; if (k = a.inputOptions || [], !k.length) throw new Error("prompt with checkbox requires options"); if (!k[0].value || !k[0].text) throw new Error("given options in wrong format"); h = b("<div/>"), g(k, function (c, d) { var e = b(n.inputs[a.inputType]); e.find("input").attr("value", d.value), e.find("label").append(d.text), g(q, function (a, b) { b === d.value && e.find("input").prop("checked", !0) }), h.append(e) }) }return a.placeholder && h.attr("placeholder", a.placeholder), a.pattern && h.attr("pattern", a.pattern), a.maxlength && h.attr("maxlength", a.maxlength), f.append(h), f.on("submit", function (a) { a.preventDefault(), a.stopPropagation(), e.find(".btn-primary").click() }), e = p.dialog(a), e.off("shown.bs.modal"), e.on("shown.bs.modal", function () { h.focus() }), i === !0 && e.modal("show"), e }, p.dialog = function (a) { a = h(a); var d = b(n.dialog), f = d.find(".modal-dialog"), i = d.find(".modal-body"), j = a.buttons, k = "", l = { onEscape: a.onEscape }; if (b.fn.modal === c) throw new Error("$.fn.modal is not defined; please double check you have included the Bootstrap JavaScript library. See http://getbootstrap.com/javascript/ for more details."); if (g(j, function (a, b) { k += "<button data-bb-handler='" + a + "' type='button' class='btn " + b.className + "'>" + b.label + "</button>", l[a] = b.callback }), i.find(".bootbox-body").html(a.message), a.animate === !0 && d.addClass("fade"), a.className && d.addClass(a.className), "large" === a.size ? f.addClass("modal-lg") : "small" === a.size && f.addClass("modal-sm"), a.title && i.before(n.header), a.closeButton) { var m = b(n.closeButton); a.title ? d.find(".modal-header").prepend(m) : m.css("margin-top", "-10px").prependTo(i) } return a.title && d.find(".modal-title").html(a.title), k.length && (i.after(n.footer), d.find(".modal-footer").html(k)), d.on("hidden.bs.modal", function (a) { a.target === this && d.remove() }), d.on("shown.bs.modal", function () { d.find(".btn-primary:first").focus() }), "static" !== a.backdrop && d.on("click.dismiss.bs.modal", function (a) { d.children(".modal-backdrop").length && (a.currentTarget = d.children(".modal-backdrop").get(0)), a.target === a.currentTarget && d.trigger("escape.close.bb") }), d.on("escape.close.bb", function (a) { l.onEscape && e(a, d, l.onEscape) }), d.on("click", ".modal-footer button", function (a) { var c = b(this).data("bb-handler"); e(a, d, l[c]) }), d.on("click", ".bootbox-close-button", function (a) { e(a, d, l.onEscape) }), d.on("keyup", function (a) { 27 === a.which && d.trigger("escape.close.bb") }), b(a.container).append(d), d.modal({ backdrop: a.backdrop ? "static" : !1, keyboard: !1, show: !1 }), a.show && d.modal("show"), d }, p.setDefaults = function () { var a = {}; 2 === arguments.length ? a[arguments[0]] = arguments[1] : a = arguments[0], b.extend(o, a) }, p.hideAll = function () { return b(".bootbox").modal("hide"), p }; var q = { bg_BG: { OK: "Ок", CANCEL: "Отказ", CONFIRM: "Потвърждавам" }, br: { OK: "OK", CANCEL: "Cancelar", CONFIRM: "Sim" }, cs: { OK: "OK", CANCEL: "Zrušit", CONFIRM: "Potvrdit" }, da: { OK: "OK", CANCEL: "Annuller", CONFIRM: "Accepter" }, de: { OK: "OK", CANCEL: "Abbrechen", CONFIRM: "Akzeptieren" }, el: { OK: "Εντάξει", CANCEL: "Ακύρωση", CONFIRM: "Επιβεβαίωση" }, en: { OK: "OK", CANCEL: "Cancel", CONFIRM: "OK" }, es: { OK: "OK", CANCEL: "Cancelar", CONFIRM: "Aceptar" }, et: { OK: "OK", CANCEL: "Katkesta", CONFIRM: "OK" }, fa: { OK: "قبول", CANCEL: "لغو", CONFIRM: "تایید" }, fi: { OK: "OK", CANCEL: "Peruuta", CONFIRM: "OK" }, fr: { OK: "OK", CANCEL: "Annuler", CONFIRM: "D'accord" }, he: { OK: "אישור", CANCEL: "ביטול", CONFIRM: "אישור" }, hu: { OK: "OK", CANCEL: "Mégsem", CONFIRM: "Megerősít" }, hr: { OK: "OK", CANCEL: "Odustani", CONFIRM: "Potvrdi" }, id: { OK: "OK", CANCEL: "Batal", CONFIRM: "OK" }, it: { OK: "OK", CANCEL: "Annulla", CONFIRM: "Conferma" }, ja: { OK: "OK", CANCEL: "キャンセル", CONFIRM: "確認" }, lt: { OK: "Gerai", CANCEL: "Atšaukti", CONFIRM: "Patvirtinti" }, lv: { OK: "Labi", CANCEL: "Atcelt", CONFIRM: "Apstiprināt" }, nl: { OK: "OK", CANCEL: "Annuleren", CONFIRM: "Accepteren" }, no: { OK: "OK", CANCEL: "Avbryt", CONFIRM: "OK" }, pl: { OK: "OK", CANCEL: "Anuluj", CONFIRM: "Potwierdź" }, pt: { OK: "OK", CANCEL: "Cancelar", CONFIRM: "Confirmar" }, ru: { OK: "OK", CANCEL: "Отмена", CONFIRM: "Применить" }, sq: { OK: "OK", CANCEL: "Anulo", CONFIRM: "Prano" }, sv: { OK: "OK", CANCEL: "Avbryt", CONFIRM: "OK" }, th: { OK: "ตกลง", CANCEL: "ยกเลิก", CONFIRM: "ยืนยัน" }, tr: { OK: "Tamam", CANCEL: "İptal", CONFIRM: "Onayla" }, zh_CN: { OK: "OK", CANCEL: "取消", CONFIRM: "确认" }, zh_TW: { OK: "OK", CANCEL: "取消", CONFIRM: "確認" } }; return p.addLocale = function (a, c) { return b.each(["OK", "CANCEL", "CONFIRM"], function (a, b) { if (!c[b]) throw new Error("Please supply a translation for '" + b + "'") }), q[a] = { OK: c.OK, CANCEL: c.CANCEL, CONFIRM: c.CONFIRM }, p }, p.removeLocale = function (a) { return delete q[a], p }, p.setLocale = function (a) { return p.setDefaults("locale", a) }, p.init = function (c) { return a(c || b) }, p });
(function () {
    function n(n, t) { return n.set(t[0], t[1]), n } function t(n, t) { return n.add(t), n } function r(n, t, r) { var e = r.length; switch (e) { case 0: return n.call(t); case 1: return n.call(t, r[0]); case 2: return n.call(t, r[0], r[1]); case 3: return n.call(t, r[0], r[1], r[2]) }return n.apply(t, r) } function e(n, t, r, e) { for (var u = -1, i = n ? n.length : 0; ++u < i;) { var o = n[u]; t(e, o, r(o), n) } return e } function u(n, t) { for (var r = -1, e = n ? n.length : 0; ++r < e && t(n[r], r, n) !== !1;); return n } function i(n, t) { for (var r = n ? n.length : 0; r-- && t(n[r], r, n) !== !1;); return n } function o(n, t) { for (var r = -1, e = n ? n.length : 0; ++r < e;)if (!t(n[r], r, n)) return !1; return !0 } function f(n, t) { for (var r = -1, e = n ? n.length : 0, u = 0, i = []; ++r < e;) { var o = n[r]; t(o, r, n) && (i[u++] = o) } return i } function a(n, t) { var r = n ? n.length : 0; return !!r && y(n, t, 0) > -1 } function c(n, t, r) { for (var e = -1, u = n ? n.length : 0; ++e < u;)if (r(t, n[e])) return !0; return !1 } function l(n, t) { for (var r = -1, e = n ? n.length : 0, u = Array(e); ++r < e;)u[r] = t(n[r], r, n); return u } function s(n, t) { for (var r = -1, e = t.length, u = n.length; ++r < e;)n[u + r] = t[r]; return n } function h(n, t, r, e) { var u = -1, i = n ? n.length : 0; for (e && i && (r = n[++u]); ++u < i;)r = t(r, n[u], u, n); return r } function p(n, t, r, e) { var u = n ? n.length : 0; for (e && u && (r = n[--u]); u--;)r = t(r, n[u], u, n); return r } function v(n, t) { for (var r = -1, e = n ? n.length : 0; ++r < e;)if (t(n[r], r, n)) return !0; return !1 } function _(n, t, r) { var e; return r(n, function (n, r, u) { return t(n, r, u) ? (e = r, !1) : void 0 }), e } function g(n, t, r, e) { for (var u = n.length, i = r + (e ? 1 : -1); e ? i-- : ++i < u;)if (t(n[i], i, n)) return i; return -1 } function y(n, t, r) { if (t !== t) return z(n, r); for (var e = r - 1, u = n.length; ++e < u;)if (n[e] === t) return e; return -1 } function d(n, t, r, e) { for (var u = r - 1, i = n.length; ++u < i;)if (e(n[u], t)) return u; return -1 } function b(n, t) { var r = n ? n.length : 0; return r ? x(n, t) / r : xn } function w(n, t, r, e, u) { return u(n, function (n, u, i) { r = e ? (e = !1, n) : t(r, n, u, i) }), r } function m(n, t) { var r = n.length; for (n.sort(t); r--;)n[r] = n[r].value; return n } function x(n, t) { for (var r, e = -1, u = n.length; ++e < u;) { var i = t(n[e]); i !== K && (r = r === K ? i : r + i) } return r } function j(n, t) { for (var r = -1, e = Array(n); ++r < n;)e[r] = t(r); return e } function A(n, t) { return l(t, function (t) { return [t, n[t]] }) } function O(n) { return function (t) { return n(t) } } function k(n, t) { return l(t, function (t) { return n[t] }) } function I(n, t) { return n.has(t) } function R(n, t) { for (var r = -1, e = n.length; ++r < e && y(t, n[r], 0) > -1;); return r } function E(n, t) { for (var r = n.length; r-- && y(t, n[r], 0) > -1;); return r } function S(n) { return n && n.Object === Object ? n : null } function W(n, t) { for (var r = n.length, e = 0; r--;)n[r] === t && e++; return e } function L(n) { return Ar[n] } function C(n) { return Or[n] } function B(n) { return "\\" + Ir[n] } function $(n, t) { return null == n ? K : n[t] } function z(n, t, r) { for (var e = n.length, u = t + (r ? 1 : -1); r ? u-- : ++u < e;) { var i = n[u]; if (i !== i) return u } return -1 } function U(n) { var t = !1; if (null != n && "function" != typeof n.toString) try { t = !!(n + "") } catch (r) { } return t } function F(n) { for (var t, r = []; !(t = n.next()).done;)r.push(t.value); return r } function M(n) { var t = -1, r = Array(n.size); return n.forEach(function (n, e) { r[++t] = [e, n] }), r } function D(n, t) { for (var r = -1, e = n.length, u = 0, i = []; ++r < e;) { var o = n[r]; o !== t && o !== Q || (n[r] = Q, i[u++] = r) } return i } function P(n) { var t = -1, r = Array(n.size); return n.forEach(function (n) { r[++t] = n }), r } function N(n) { var t = -1, r = Array(n.size); return n.forEach(function (n) { r[++t] = [n, n] }), r } function q(n) { if (!n || !dr.test(n)) return n.length; for (var t = gr.lastIndex = 0; gr.test(n);)t++; return t } function T(n) { return n.match(gr) } function Z(n) { return kr[n] } function V(S) {
        function Wt(n) { if (bf(n) && !ys(n) && !(n instanceof Bt)) { if (n instanceof Ct) return n; if (Sc.call(n, "__wrapped__")) return si(n) } return new Ct(n) } function Lt() { } function Ct(n, t) { this.__wrapped__ = n, this.__actions__ = [], this.__chain__ = !!t, this.__index__ = 0, this.__values__ = K } function Bt(n) { this.__wrapped__ = n, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = jn, this.__views__ = [] } function $t() { var n = new Bt(this.__wrapped__); return n.__actions__ = ru(this.__actions__), n.__dir__ = this.__dir__, n.__filtered__ = this.__filtered__, n.__iteratees__ = ru(this.__iteratees__), n.__takeCount__ = this.__takeCount__, n.__views__ = ru(this.__views__), n } function zt() { if (this.__filtered__) { var n = new Bt(this); n.__dir__ = -1, n.__filtered__ = !0 } else n = this.clone(), n.__dir__ *= -1; return n } function Ut() { var n = this.__wrapped__.value(), t = this.__dir__, r = ys(n), e = 0 > t, u = r ? n.length : 0, i = Nu(0, u, this.__views__), o = i.start, f = i.end, a = f - o, c = e ? f : o - 1, l = this.__iteratees__, s = l.length, h = 0, p = nl(a, this.__takeCount__); if (!r || J > u || u == a && p == a) return Ue(n, this.__actions__); var v = []; n: for (; a-- && p > h;) { c += t; for (var _ = -1, g = n[c]; ++_ < s;) { var y = l[_], d = y.iteratee, b = y.type, w = d(g); if (b == yn) g = w; else if (!w) { if (b == gn) continue n; break n } } v[h++] = g } return v } function Ft(n) { var t = -1, r = n ? n.length : 0; for (this.clear(); ++t < r;) { var e = n[t]; this.set(e[0], e[1]) } } function Mt() { this.__data__ = sl ? sl(null) : {} } function Dt(n) { return this.has(n) && delete this.__data__[n] } function Pt(n) { var t = this.__data__; if (sl) { var r = t[n]; return r === H ? K : r } return Sc.call(t, n) ? t[n] : K } function Nt(n) { var t = this.__data__; return sl ? t[n] !== K : Sc.call(t, n) } function qt(n, t) { var r = this.__data__; return r[n] = sl && t === K ? H : t, this } function Tt(n) { var t = -1, r = n ? n.length : 0; for (this.clear(); ++t < r;) { var e = n[t]; this.set(e[0], e[1]) } } function Zt() { this.__data__ = [] } function Vt(n) { var t = this.__data__, r = gr(t, n); if (0 > r) return !1; var e = t.length - 1; return r == e ? t.pop() : Zc.call(t, r, 1), !0 } function Kt(n) { var t = this.__data__, r = gr(t, n); return 0 > r ? K : t[r][1] } function Gt(n) { return gr(this.__data__, n) > -1 } function Jt(n, t) { var r = this.__data__, e = gr(r, n); return 0 > e ? r.push([n, t]) : r[e][1] = t, this } function Yt(n) { var t = -1, r = n ? n.length : 0; for (this.clear(); ++t < r;) { var e = n[t]; this.set(e[0], e[1]) } } function Ht() { this.__data__ = { hash: new Ft, map: new (fl || Tt), string: new Ft } } function Qt(n) { return zu(this, n)["delete"](n) } function Xt(n) { return zu(this, n).get(n) } function nr(n) { return zu(this, n).has(n) } function tr(n, t) { return zu(this, n).set(n, t), this } function rr(n) { var t = -1, r = n ? n.length : 0; for (this.__data__ = new Yt; ++t < r;)this.add(n[t]) } function er(n) { return this.__data__.set(n, H), this } function ur(n) { return this.__data__.has(n) } function ir(n) { this.__data__ = new Tt(n) } function or() { this.__data__ = new Tt } function fr(n) { return this.__data__["delete"](n) } function ar(n) { return this.__data__.get(n) } function cr(n) { return this.__data__.has(n) } function lr(n, t) { var r = this.__data__; return r instanceof Tt && r.__data__.length == J && (r = this.__data__ = new Yt(r.__data__)), r.set(n, t), this } function sr(n, t, r, e) { return n === K || tf(n, Oc[r]) && !Sc.call(e, r) ? t : n } function hr(n, t, r) { (r === K || tf(n[t], r)) && ("number" != typeof t || r !== K || t in n) || (n[t] = r) } function pr(n, t, r) { var e = n[t]; Sc.call(n, t) && tf(e, r) && (r !== K || t in n) || (n[t] = r) } function gr(n, t) { for (var r = n.length; r--;)if (tf(n[r][0], t)) return r; return -1 } function Ar(n, t, r, e) { return jl(n, function (n, u, i) { t(e, n, r(n), i) }), e } function Or(n, t) { return n && eu(t, ua(t), n) } function kr(n, t) { for (var r = -1, e = null == n, u = t.length, i = Array(u); ++r < u;)i[r] = e ? K : ta(n, t[r]); return i } function Ir(n, t, r) { return n === n && (r !== K && (n = r >= n ? n : r), t !== K && (n = n >= t ? n : t)), n } function Sr(n, t, r, e, i, o, f) { var a; if (e && (a = o ? e(n, i, o, f) : e(n)), a !== K) return a; if (!df(n)) return n; var c = ys(n); if (c) { if (a = Tu(n), !t) return ru(n, a) } else { var l = Pu(n), s = l == Wn || l == Ln; if (ds(n)) return Te(n, t); if (l == $n || l == kn || s && !o) { if (U(n)) return o ? n : {}; if (a = Zu(s ? {} : n), !t) return uu(n, Or(a, n)) } else { if (!jr[l]) return o ? n : {}; a = Vu(n, l, Sr, t) } } f || (f = new ir); var h = f.get(n); if (h) return h; if (f.set(n, a), !c) var p = r ? Wu(n) : ua(n); return u(p || n, function (u, i) { p && (i = u, u = n[i]), pr(a, i, Sr(u, t, r, e, i, n, f)) }), a } function Wr(n) { var t = ua(n), r = t.length; return function (e) { if (null == e) return !r; for (var u = r; u--;) { var i = t[u], o = n[i], f = e[i]; if (f === K && !(i in Object(e)) || !o(f)) return !1 } return !0 } } function Cr(n) { return df(n) ? qc(n) : {} } function Br(n, t, r) { if ("function" != typeof n) throw new jc(Y); return Vc(function () { n.apply(K, r) }, t) } function $r(n, t, r, e) { var u = -1, i = a, o = !0, f = n.length, s = [], h = t.length; if (!f) return s; r && (t = l(t, O(r))), e ? (i = c, o = !1) : t.length >= J && (i = I, o = !1, t = new rr(t)); n: for (; ++u < f;) { var p = n[u], v = r ? r(p) : p; if (p = e || 0 !== p ? p : 0, o && v === v) { for (var _ = h; _--;)if (t[_] === v) continue n; s.push(p) } else i(t, v, e) || s.push(p) } return s } function Fr(n, t) { var r = !0; return jl(n, function (n, e, u) { return r = !!t(n, e, u) }), r } function Mr(n, t, r) { for (var e = -1, u = n.length; ++e < u;) { var i = n[e], o = t(i); if (null != o && (f === K ? o === o && !Cf(o) : r(o, f))) var f = o, a = i } return a } function Dr(n, t, r, e) { var u = n.length; for (r = Df(r), 0 > r && (r = -r > u ? 0 : u + r), e = e === K || e > u ? u : Df(e), 0 > e && (e += u), e = r > e ? 0 : Pf(e); e > r;)n[r++] = t; return n } function Pr(n, t) { var r = []; return jl(n, function (n, e, u) { t(n, e, u) && r.push(n) }), r } function Nr(n, t, r, e, u) { var i = -1, o = n.length; for (r || (r = Gu), u || (u = []); ++i < o;) { var f = n[i]; t > 0 && r(f) ? t > 1 ? Nr(f, t - 1, r, e, u) : s(u, f) : e || (u[u.length] = f) } return u } function qr(n, t) { return n && Ol(n, t, ua) } function Tr(n, t) { return n && kl(n, t, ua) } function Zr(n, t) { return f(t, function (t) { return _f(n[t]) }) } function Vr(n, t) { t = Qu(t, n) ? [t] : Ne(t); for (var r = 0, e = t.length; null != n && e > r;)n = n[ci(t[r++])]; return r && r == e ? n : K } function Kr(n, t, r) { var e = t(n); return ys(n) ? e : s(e, r(n)) } function Gr(n, t) { return n > t } function Jr(n, t) { return null != n && (Sc.call(n, t) || "object" == typeof n && t in n && null === Mu(n)) } function Yr(n, t) { return null != n && t in Object(n) } function Hr(n, t, r) { return n >= nl(t, r) && n < Xc(t, r) } function Qr(n, t, r) { for (var e = r ? c : a, u = n[0].length, i = n.length, o = i, f = Array(i), s = 1 / 0, h = []; o--;) { var p = n[o]; o && t && (p = l(p, O(t))), s = nl(p.length, s), f[o] = !r && (t || u >= 120 && p.length >= 120) ? new rr(o && p) : K } p = n[0]; var v = -1, _ = f[0]; n: for (; ++v < u && h.length < s;) { var g = p[v], y = t ? t(g) : g; if (g = r || 0 !== g ? g : 0, !(_ ? I(_, y) : e(h, y, r))) { for (o = i; --o;) { var d = f[o]; if (!(d ? I(d, y) : e(n[o], y, r))) continue n } _ && _.push(y), h.push(g) } } return h } function Xr(n, t, r, e) { return qr(n, function (n, u, i) { t(e, r(n), u, i) }), e } function ne(n, t, e) { Qu(t, n) || (t = Ne(t), n = fi(n, t), t = Si(t)); var u = null == n ? n : n[ci(t)]; return null == u ? K : r(u, n, e) } function te(n, t, r, e, u) { return n === t ? !0 : null == n || null == t || !df(n) && !bf(t) ? n !== n && t !== t : re(n, t, te, r, e, u) } function re(n, t, r, e, u, i) { var o = ys(n), f = ys(t), a = In, c = In; o || (a = Pu(n), a = a == kn ? $n : a), f || (c = Pu(t), c = c == kn ? $n : c); var l = a == $n && !U(n), s = c == $n && !U(t), h = a == c; if (h && !l) return i || (i = new ir), o || Bf(n) ? Ru(n, t, r, e, u, i) : Eu(n, t, a, r, e, u, i); if (!(u & sn)) { var p = l && Sc.call(n, "__wrapped__"), v = s && Sc.call(t, "__wrapped__"); if (p || v) { var _ = p ? n.value() : n, g = v ? t.value() : t; return i || (i = new ir), r(_, g, e, u, i) } } return h ? (i || (i = new ir), Su(n, t, r, e, u, i)) : !1 } function ee(n, t, r, e) { var u = r.length, i = u, o = !e; if (null == n) return !i; for (n = Object(n); u--;) { var f = r[u]; if (o && f[2] ? f[1] !== n[f[0]] : !(f[0] in n)) return !1 } for (; ++u < i;) { f = r[u]; var a = f[0], c = n[a], l = f[1]; if (o && f[2]) { if (c === K && !(a in n)) return !1 } else { var s = new ir; if (e) var h = e(c, l, a, n, t, s); if (!(h === K ? te(l, c, e, ln | sn, s) : h)) return !1 } } return !0 } function ue(n) { if (!df(n) || ti(n)) return !1; var t = _f(n) || U(n) ? $c : Ot; return t.test(li(n)) } function ie(n) { return "function" == typeof n ? n : null == n ? Ka : "object" == typeof n ? ys(n) ? se(n[0], n[1]) : le(n) : tc(n) } function oe(n) { return Qc(Object(n)) } function fe(n) { n = null == n ? n : Object(n); var t = []; for (var r in n) t.push(r); return t } function ae(n, t) { return t > n } function ce(n, t) { var r = -1, e = uf(n) ? Array(n.length) : []; return jl(n, function (n, u, i) { e[++r] = t(n, u, i) }), e } function le(n) { var t = Uu(n); return 1 == t.length && t[0][2] ? ui(t[0][0], t[0][1]) : function (r) { return r === n || ee(r, n, t) } } function se(n, t) { return Qu(n) && ei(t) ? ui(ci(n), t) : function (r) { var e = ta(r, n); return e === K && e === t ? ea(r, n) : te(t, e, K, ln | sn) } } function he(n, t, r, e, i) { if (n !== t) { if (!ys(t) && !Bf(t)) var o = ia(t); u(o || t, function (u, f) { if (o && (f = u, u = t[f]), df(u)) i || (i = new ir), pe(n, t, f, r, he, e, i); else { var a = e ? e(n[f], u, f + "", n, t, i) : K; a === K && (a = u), hr(n, f, a) } }) } } function pe(n, t, r, e, u, i, o) { var f = n[r], a = t[r], c = o.get(a); if (c) return void hr(n, r, c); var l = i ? i(f, a, r + "", n, t, o) : K, s = l === K; s && (l = a, ys(a) || Bf(a) ? ys(f) ? l = f : of(f) ? l = ru(f) : (s = !1, l = Sr(a, !0)) : Rf(a) || rf(a) ? rf(f) ? l = qf(f) : !df(f) || e && _f(f) ? (s = !1, l = Sr(a, !0)) : l = f : s = !1), o.set(a, l), s && u(l, a, e, i, o), o["delete"](a), hr(n, r, l) } function ve(n, t) { var r = n.length; if (r) return t += 0 > t ? r : 0, Yu(t, r) ? n[t] : K } function _e(n, t, r) { var e = -1; t = l(t.length ? t : [Ka], O($u())); var u = ce(n, function (n, r, u) { var i = l(t, function (t) { return t(n) }); return { criteria: i, index: ++e, value: n } }); return m(u, function (n, t) { return Xe(n, t, r) }) } function ge(n, t) { return n = Object(n), h(t, function (t, r) { return r in n && (t[r] = n[r]), t }, {}) } function ye(n, t) { for (var r = -1, e = Lu(n), u = e.length, i = {}; ++r < u;) { var o = e[r], f = n[o]; t(f, o) && (i[o] = f) } return i } function de(n) { return function (t) { return null == t ? K : t[n] } } function be(n) { return function (t) { return Vr(t, n) } } function we(n, t, r, e) { var u = e ? d : y, i = -1, o = t.length, f = n; for (n === t && (t = ru(t)), r && (f = l(n, O(r))); ++i < o;)for (var a = 0, c = t[i], s = r ? r(c) : c; (a = u(f, s, a, e)) > -1;)f !== n && Zc.call(f, a, 1), Zc.call(n, a, 1); return n } function me(n, t) { for (var r = n ? t.length : 0, e = r - 1; r--;) { var u = t[r]; if (r == e || u !== i) { var i = u; if (Yu(u)) Zc.call(n, u, 1); else if (Qu(u, n)) delete n[ci(u)]; else { var o = Ne(u), f = fi(n, o); null != f && delete f[ci(Si(o))] } } } return n } function xe(n, t) { return n + Gc(rl() * (t - n + 1)) } function je(n, t, r, e) { for (var u = -1, i = Xc(Kc((t - n) / (r || 1)), 0), o = Array(i); i--;)o[e ? i : ++u] = n, n += r; return o } function Ae(n, t) { var r = ""; if (!n || 1 > t || t > wn) return r; do t % 2 && (r += n), t = Gc(t / 2), t && (n += n); while (t); return r } function Oe(n, t, r, e) { t = Qu(t, n) ? [t] : Ne(t); for (var u = -1, i = t.length, o = i - 1, f = n; null != f && ++u < i;) { var a = ci(t[u]); if (df(f)) { var c = r; if (u != o) { var l = f[a]; c = e ? e(l, a, f) : K, c === K && (c = null == l ? Yu(t[u + 1]) ? [] : {} : l) } pr(f, a, c) } f = f[a] } return n } function ke(n, t, r) { var e = -1, u = n.length; 0 > t && (t = -t > u ? 0 : u + t), r = r > u ? u : r, 0 > r && (r += u), u = t > r ? 0 : r - t >>> 0, t >>>= 0; for (var i = Array(u); ++e < u;)i[e] = n[e + t]; return i } function Ie(n, t) { var r; return jl(n, function (n, e, u) { return r = t(n, e, u), !r }), !!r } function Re(n, t, r) { var e = 0, u = n ? n.length : e; if ("number" == typeof t && t === t && On >= u) { for (; u > e;) { var i = e + u >>> 1, o = n[i]; null !== o && !Cf(o) && (r ? t >= o : t > o) ? e = i + 1 : u = i } return u } return Ee(n, t, Ka, r) } function Ee(n, t, r, e) { t = r(t); for (var u = 0, i = n ? n.length : 0, o = t !== t, f = null === t, a = Cf(t), c = t === K; i > u;) { var l = Gc((u + i) / 2), s = r(n[l]), h = s !== K, p = null === s, v = s === s, _ = Cf(s); if (o) var g = e || v; else g = c ? v && (e || h) : f ? v && h && (e || !p) : a ? v && h && !p && (e || !_) : p || _ ? !1 : e ? t >= s : t > s; g ? u = l + 1 : i = l } return nl(i, An) } function Se(n, t) { for (var r = -1, e = n.length, u = 0, i = []; ++r < e;) { var o = n[r], f = t ? t(o) : o; if (!r || !tf(f, a)) { var a = f; i[u++] = 0 === o ? 0 : o } } return i } function We(n) { return "number" == typeof n ? n : Cf(n) ? xn : +n } function Le(n) { if ("string" == typeof n) return n; if (Cf(n)) return xl ? xl.call(n) : ""; var t = n + ""; return "0" == t && 1 / n == -bn ? "-0" : t } function Ce(n, t, r) { var e = -1, u = a, i = n.length, o = !0, f = [], l = f; if (r) o = !1, u = c; else if (i >= J) { var s = t ? null : Rl(n); if (s) return P(s); o = !1, u = I, l = new rr } else l = t ? [] : f; n: for (; ++e < i;) { var h = n[e], p = t ? t(h) : h; if (h = r || 0 !== h ? h : 0, o && p === p) { for (var v = l.length; v--;)if (l[v] === p) continue n; t && l.push(p), f.push(h) } else u(l, p, r) || (l !== f && l.push(p), f.push(h)) } return f } function Be(n, t) { t = Qu(t, n) ? [t] : Ne(t), n = fi(n, t); var r = ci(Si(t)); return !(null != n && Jr(n, r)) || delete n[r] } function $e(n, t, r, e) { return Oe(n, t, r(Vr(n, t)), e) } function ze(n, t, r, e) { for (var u = n.length, i = e ? u : -1; (e ? i-- : ++i < u) && t(n[i], i, n);); return r ? ke(n, e ? 0 : i, e ? i + 1 : u) : ke(n, e ? i + 1 : 0, e ? u : i) } function Ue(n, t) { var r = n; return r instanceof Bt && (r = r.value()), h(t, function (n, t) { return t.func.apply(t.thisArg, s([n], t.args)) }, r) } function Fe(n, t, r) { for (var e = -1, u = n.length; ++e < u;)var i = i ? s($r(i, n[e], t, r), $r(n[e], i, t, r)) : n[e]; return i && i.length ? Ce(i, t, r) : [] } function Me(n, t, r) { for (var e = -1, u = n.length, i = t.length, o = {}; ++e < u;) { var f = i > e ? t[e] : K; r(o, n[e], f) } return o } function De(n) { return of(n) ? n : [] } function Pe(n) { return "function" == typeof n ? n : Ka } function Ne(n) { return ys(n) ? n : Bl(n) } function qe(n, t, r) { var e = n.length; return r = r === K ? e : r, !t && r >= e ? n : ke(n, t, r) } function Te(n, t) { if (t) return n.slice(); var r = new n.constructor(n.length); return n.copy(r), r } function Ze(n) { var t = new n.constructor(n.byteLength); return new Mc(t).set(new Mc(n)), t } function Ve(n, t) { var r = t ? Ze(n.buffer) : n.buffer; return new n.constructor(r, n.byteOffset, n.byteLength) } function Ke(t, r, e) { var u = r ? e(M(t), !0) : M(t); return h(u, n, new t.constructor) } function Ge(n) { var t = new n.constructor(n.source, mt.exec(n)); return t.lastIndex = n.lastIndex, t } function Je(n, r, e) { var u = r ? e(P(n), !0) : P(n); return h(u, t, new n.constructor) } function Ye(n) { return ml ? Object(ml.call(n)) : {} } function He(n, t) { var r = t ? Ze(n.buffer) : n.buffer; return new n.constructor(r, n.byteOffset, n.length) } function Qe(n, t) { if (n !== t) { var r = n !== K, e = null === n, u = n === n, i = Cf(n), o = t !== K, f = null === t, a = t === t, c = Cf(t); if (!f && !c && !i && n > t || i && o && a && !f && !c || e && o && a || !r && a || !u) return 1; if (!e && !i && !c && t > n || c && r && u && !e && !i || f && r && u || !o && u || !a) return -1 } return 0 } function Xe(n, t, r) { for (var e = -1, u = n.criteria, i = t.criteria, o = u.length, f = r.length; ++e < o;) { var a = Qe(u[e], i[e]); if (a) { if (e >= f) return a; var c = r[e]; return a * ("desc" == c ? -1 : 1) } } return n.index - t.index } function nu(n, t, r, e) { for (var u = -1, i = n.length, o = r.length, f = -1, a = t.length, c = Xc(i - o, 0), l = Array(a + c), s = !e; ++f < a;)l[f] = t[f]; for (; ++u < o;)(s || i > u) && (l[r[u]] = n[u]); for (; c--;)l[f++] = n[u++]; return l } function tu(n, t, r, e) { for (var u = -1, i = n.length, o = -1, f = r.length, a = -1, c = t.length, l = Xc(i - f, 0), s = Array(l + c), h = !e; ++u < l;)s[u] = n[u]; for (var p = u; ++a < c;)s[p + a] = t[a]; for (; ++o < f;)(h || i > u) && (s[p + r[o]] = n[u++]); return s } function ru(n, t) { var r = -1, e = n.length; for (t || (t = Array(e)); ++r < e;)t[r] = n[r]; return t } function eu(n, t, r, e) { r || (r = {}); for (var u = -1, i = t.length; ++u < i;) { var o = t[u], f = e ? e(r[o], n[o], o, r, n) : n[o]; pr(r, o, f) } return r } function uu(n, t) { return eu(n, Du(n), t) } function iu(n, t) { return function (r, u) { var i = ys(r) ? e : Ar, o = t ? t() : {}; return i(r, n, $u(u), o) } } function ou(n) { return Zo(function (t, r) { var e = -1, u = r.length, i = u > 1 ? r[u - 1] : K, o = u > 2 ? r[2] : K; for (i = n.length > 3 && "function" == typeof i ? (u--, i) : K, o && Hu(r[0], r[1], o) && (i = 3 > u ? K : i, u = 1), t = Object(t); ++e < u;) { var f = r[e]; f && n(t, f, e, i) } return t }) } function fu(n, t) { return function (r, e) { if (null == r) return r; if (!uf(r)) return n(r, e); for (var u = r.length, i = t ? u : -1, o = Object(r); (t ? i-- : ++i < u) && e(o[i], i, o) !== !1;); return r } } function au(n) { return function (t, r, e) { for (var u = -1, i = Object(t), o = e(t), f = o.length; f--;) { var a = o[n ? f : ++u]; if (r(i[a], a, i) === !1) break } return t } } function cu(n, t, r) { function e() { var t = this && this !== zr && this instanceof e ? i : n; return t.apply(u ? r : this, arguments) } var u = t & X, i = hu(n); return e } function lu(n) { return function (t) { t = Zf(t); var r = dr.test(t) ? T(t) : K, e = r ? r[0] : t.charAt(0), u = r ? qe(r, 1).join("") : t.slice(1); return e[n]() + u } } function su(n) { return function (t) { return h(qa(ja(t).replace(vr, "")), n, "") } } function hu(n) { return function () { var t = arguments; switch (t.length) { case 0: return new n; case 1: return new n(t[0]); case 2: return new n(t[0], t[1]); case 3: return new n(t[0], t[1], t[2]); case 4: return new n(t[0], t[1], t[2], t[3]); case 5: return new n(t[0], t[1], t[2], t[3], t[4]); case 6: return new n(t[0], t[1], t[2], t[3], t[4], t[5]); case 7: return new n(t[0], t[1], t[2], t[3], t[4], t[5], t[6]) }var r = Cr(n.prototype), e = n.apply(r, t); return df(e) ? e : r } } function pu(n, t, e) { function u() { for (var o = arguments.length, f = Array(o), a = o, c = Bu(u); a--;)f[a] = arguments[a]; var l = 3 > o && f[0] !== c && f[o - 1] !== c ? [] : D(f, c); if (o -= l.length, e > o) return Au(n, t, gu, u.placeholder, K, f, l, K, K, e - o); var s = this && this !== zr && this instanceof u ? i : n; return r(s, this, f) } var i = hu(n); return u } function vu(n) { return function (t, r, e) { var u = Object(t); if (r = $u(r, 3), !uf(t)) var i = ua(t); var o = n(i || t, function (n, t) { return i && (t = n, n = u[t]), r(n, t, u) }, e); return o > -1 ? t[i ? i[o] : o] : K } } function _u(n) { return Zo(function (t) { t = Nr(t, 1); var r = t.length, e = r, u = Ct.prototype.thru; for (n && t.reverse(); e--;) { var i = t[e]; if ("function" != typeof i) throw new jc(Y); if (u && !o && "wrapper" == Cu(i)) var o = new Ct([], !0) } for (e = o ? e : r; ++e < r;) { i = t[e]; var f = Cu(i), a = "wrapper" == f ? El(i) : K; o = a && ni(a[0]) && a[1] == (fn | rn | un | an) && !a[4].length && 1 == a[9] ? o[Cu(a[0])].apply(o, a[3]) : 1 == i.length && ni(i) ? o[f]() : o.thru(i) } return function () { var n = arguments, e = n[0]; if (o && 1 == n.length && ys(e) && e.length >= J) return o.plant(e).value(); for (var u = 0, i = r ? t[u].apply(this, n) : e; ++u < r;)i = t[u].call(this, i); return i } }) } function gu(n, t, r, e, u, i, o, f, a, c) { function l() { for (var y = arguments.length, d = Array(y), b = y; b--;)d[b] = arguments[b]; if (v) var w = Bu(l), m = W(d, w); if (e && (d = nu(d, e, u, v)), i && (d = tu(d, i, o, v)), y -= m, v && c > y) { var x = D(d, w); return Au(n, t, gu, l.placeholder, r, d, x, f, a, c - y) } var j = h ? r : this, A = p ? j[n] : n; return y = d.length, f ? d = ai(d, f) : _ && y > 1 && d.reverse(), s && y > a && (d.length = a), this && this !== zr && this instanceof l && (A = g || hu(A)), A.apply(j, d) } var s = t & fn, h = t & X, p = t & nn, v = t & (rn | en), _ = t & cn, g = p ? K : hu(n); return l } function yu(n, t) { return function (r, e) { return Xr(r, n, t(e), {}) } } function du(n) { return function (t, r) { var e; if (t === K && r === K) return 0; if (t !== K && (e = t), r !== K) { if (e === K) return r; "string" == typeof t || "string" == typeof r ? (t = Le(t), r = Le(r)) : (t = We(t), r = We(r)), e = n(t, r) } return e } } function bu(n) { return Zo(function (t) { return t = 1 == t.length && ys(t[0]) ? l(t[0], O($u())) : l(Nr(t, 1, Ju), O($u())), Zo(function (e) { var u = this; return n(t, function (n) { return r(n, u, e) }) }) }) } function wu(n, t) { t = t === K ? " " : Le(t); var r = t.length; if (2 > r) return r ? Ae(t, n) : t; var e = Ae(t, Kc(n / q(t))); return dr.test(t) ? qe(T(e), 0, n).join("") : e.slice(0, n) } function mu(n, t, e, u) { function i() { for (var t = -1, a = arguments.length, c = -1, l = u.length, s = Array(l + a), h = this && this !== zr && this instanceof i ? f : n; ++c < l;)s[c] = u[c]; for (; a--;)s[c++] = arguments[++t]; return r(h, o ? e : this, s) } var o = t & X, f = hu(n); return i } function xu(n) { return function (t, r, e) { return e && "number" != typeof e && Hu(t, r, e) && (r = e = K), t = Nf(t), t = t === t ? t : 0, r === K ? (r = t, t = 0) : r = Nf(r) || 0, e = e === K ? r > t ? 1 : -1 : Nf(e) || 0, je(t, r, e, n) } } function ju(n) { return function (t, r) { return "string" == typeof t && "string" == typeof r || (t = Nf(t), r = Nf(r)), n(t, r) } } function Au(n, t, r, e, u, i, o, f, a, c) { var l = t & rn, s = l ? o : K, h = l ? K : o, p = l ? i : K, v = l ? K : i; t |= l ? un : on, t &= ~(l ? on : un), t & tn || (t &= ~(X | nn)); var _ = [n, t, u, p, s, v, h, f, a, c], g = r.apply(K, _); return ni(n) && Cl(g, _), g.placeholder = e, g } function Ou(n) { var t = mc[n]; return function (n, r) { if (n = Nf(n), r = nl(Df(r), 292)) { var e = (Zf(n) + "e").split("e"), u = t(e[0] + "e" + (+e[1] + r)); return e = (Zf(u) + "e").split("e"), +(e[0] + "e" + (+e[1] - r)) } return t(n) } } function ku(n) { return function (t) { var r = Pu(t); return r == Cn ? M(t) : r == Fn ? N(t) : A(t, n(t)) } } function Iu(n, t, r, e, u, i, o, f) { var a = t & nn; if (!a && "function" != typeof n) throw new jc(Y); var c = e ? e.length : 0; if (c || (t &= ~(un | on), e = u = K), o = o === K ? o : Xc(Df(o), 0), f = f === K ? f : Df(f), c -= u ? u.length : 0, t & on) { var l = e, s = u; e = u = K } var h = a ? K : El(n), p = [n, t, r, e, u, l, s, i, o, f]; if (h && ii(p, h), n = p[0], t = p[1], r = p[2], e = p[3], u = p[4], f = p[9] = null == p[9] ? a ? 0 : n.length : Xc(p[9] - c, 0), !f && t & (rn | en) && (t &= ~(rn | en)), t && t != X) v = t == rn || t == en ? pu(n, t, f) : t != un && t != (X | un) || u.length ? gu.apply(K, p) : mu(n, t, r, e); else var v = cu(n, t, r); var _ = h ? Il : Cl; return _(v, p) } function Ru(n, t, r, e, u, i) { var o = u & sn, f = n.length, a = t.length; if (f != a && !(o && a > f)) return !1; var c = i.get(n); if (c) return c == t; var l = -1, s = !0, h = u & ln ? new rr : K; for (i.set(n, t); ++l < f;) { var p = n[l], _ = t[l]; if (e) var g = o ? e(_, p, l, t, n, i) : e(p, _, l, n, t, i); if (g !== K) { if (g) continue; s = !1; break } if (h) { if (!v(t, function (n, t) { return h.has(t) || p !== n && !r(p, n, e, u, i) ? void 0 : h.add(t) })) { s = !1; break } } else if (p !== _ && !r(p, _, e, u, i)) { s = !1; break } } return i["delete"](n), s } function Eu(n, t, r, e, u, i, o) { switch (r) { case Tn: if (n.byteLength != t.byteLength || n.byteOffset != t.byteOffset) return !1; n = n.buffer, t = t.buffer; case qn: return !(n.byteLength != t.byteLength || !e(new Mc(n), new Mc(t))); case Rn: case En: return +n == +t; case Sn: return n.name == t.name && n.message == t.message; case Bn: return n != +n ? t != +t : n == +t; case Un: case Mn: return n == t + ""; case Cn: var f = M; case Fn: var a = i & sn; if (f || (f = P), n.size != t.size && !a) return !1; var c = o.get(n); return c ? c == t : (i |= ln, o.set(n, t), Ru(f(n), f(t), e, u, i, o)); case Dn: if (ml) return ml.call(n) == ml.call(t) }return !1 } function Su(n, t, r, e, u, i) { var o = u & sn, f = ua(n), a = f.length, c = ua(t), l = c.length; if (a != l && !o) return !1; for (var s = a; s--;) { var h = f[s]; if (!(o ? h in t : Jr(t, h))) return !1 } var p = i.get(n); if (p) return p == t; var v = !0; i.set(n, t); for (var _ = o; ++s < a;) { h = f[s]; var g = n[h], y = t[h]; if (e) var d = o ? e(y, g, h, t, n, i) : e(g, y, h, n, t, i); if (!(d === K ? g === y || r(g, y, e, u, i) : d)) { v = !1; break } _ || (_ = "constructor" == h) } if (v && !_) { var b = n.constructor, w = t.constructor; b != w && "constructor" in n && "constructor" in t && !("function" == typeof b && b instanceof b && "function" == typeof w && w instanceof w) && (v = !1) } return i["delete"](n), v } function Wu(n) { return Kr(n, ua, Du) } function Lu(n) { return Kr(n, ia, Wl) } function Cu(n) { for (var t = n.name + "", r = vl[t], e = Sc.call(vl, t) ? r.length : 0; e--;) { var u = r[e], i = u.func; if (null == i || i == n) return u.name } return t } function Bu(n) { var t = Sc.call(Wt, "placeholder") ? Wt : n; return t.placeholder } function $u() { var n = Wt.iteratee || Ga; return n = n === Ga ? ie : n, arguments.length ? n(arguments[0], arguments[1]) : n } function zu(n, t) { var r = n.__data__; return Xu(t) ? r["string" == typeof t ? "string" : "hash"] : r.map } function Uu(n) { for (var t = ua(n), r = t.length; r--;) { var e = t[r], u = n[e]; t[r] = [e, u, ei(u)] } return t } function Fu(n, t) { var r = $(n, t); return ue(r) ? r : K } function Mu(n) { return Jc(Object(n)) } function Du(n) { return Pc(Object(n)) } function Pu(n) { return Cc.call(n) } function Nu(n, t, r) { for (var e = -1, u = r.length; ++e < u;) { var i = r[e], o = i.size; switch (i.type) { case "drop": n += o; break; case "dropRight": t -= o; break; case "take": t = nl(t, n + o); break; case "takeRight": n = Xc(n, t - o) } } return { start: n, end: t } } function qu(n, t, r) { t = Qu(t, n) ? [t] : Ne(t); for (var e, u = -1, i = t.length; ++u < i;) { var o = ci(t[u]); if (!(e = null != n && r(n, o))) break; n = n[o] } if (e) return e; var i = n ? n.length : 0; return !!i && yf(i) && Yu(o, i) && (ys(n) || Lf(n) || rf(n)) } function Tu(n) { var t = n.length, r = n.constructor(t); return t && "string" == typeof n[0] && Sc.call(n, "index") && (r.index = n.index, r.input = n.input), r } function Zu(n) { return "function" != typeof n.constructor || ri(n) ? {} : Cr(Mu(n)) } function Vu(n, t, r, e) { var u = n.constructor; switch (t) { case qn: return Ze(n); case Rn: case En: return new u(+n); case Tn: return Ve(n, e); case Zn: case Vn: case Kn: case Gn: case Jn: case Yn: case Hn: case Qn: case Xn: return He(n, e); case Cn: return Ke(n, e, r); case Bn: case Mn: return new u(n); case Un: return Ge(n); case Fn: return Je(n, e, r); case Dn: return Ye(n) } } function Ku(n) { var t = n ? n.length : K; return yf(t) && (ys(n) || Lf(n) || rf(n)) ? j(t, String) : null } function Gu(n) { return ys(n) || rf(n) } function Ju(n) { return ys(n) && !(2 == n.length && !_f(n[0])) } function Yu(n, t) { return t = null == t ? wn : t, !!t && ("number" == typeof n || It.test(n)) && n > -1 && n % 1 == 0 && t > n } function Hu(n, t, r) { if (!df(r)) return !1; var e = typeof t; return ("number" == e ? uf(r) && Yu(t, r.length) : "string" == e && t in r) ? tf(r[t], n) : !1 } function Qu(n, t) { if (ys(n)) return !1; var r = typeof n; return "number" == r || "symbol" == r || "boolean" == r || null == n || Cf(n) ? !0 : st.test(n) || !lt.test(n) || null != t && n in Object(t) } function Xu(n) { var t = typeof n; return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== n : null === n } function ni(n) { var t = Cu(n), r = Wt[t]; if ("function" != typeof r || !(t in Bt.prototype)) return !1; if (n === r) return !0; var e = El(r); return !!e && n === e[0] } function ti(n) { return !!Rc && Rc in n } function ri(n) { var t = n && n.constructor, r = "function" == typeof t && t.prototype || Oc; return n === r } function ei(n) { return n === n && !df(n) } function ui(n, t) { return function (r) { return null == r ? !1 : r[n] === t && (t !== K || n in Object(r)) } } function ii(n, t) { var r = n[1], e = t[1], u = r | e, i = (X | nn | fn) > u, o = e == fn && r == rn || e == fn && r == an && n[7].length <= t[8] || e == (fn | an) && t[7].length <= t[8] && r == rn; if (!i && !o) return n; e & X && (n[2] = t[2], u |= r & X ? 0 : tn); var f = t[3]; if (f) { var a = n[3]; n[3] = a ? nu(a, f, t[4]) : f, n[4] = a ? D(n[3], Q) : t[4] } return f = t[5], f && (a = n[5], n[5] = a ? tu(a, f, t[6]) : f, n[6] = a ? D(n[5], Q) : t[6]), f = t[7], f && (n[7] = f), e & fn && (n[8] = null == n[8] ? t[8] : nl(n[8], t[8])), null == n[9] && (n[9] = t[9]), n[0] = t[0], n[1] = u, n } function oi(n, t, r, e, u, i) { return df(n) && df(t) && he(n, t, K, oi, i.set(t, n)), n } function fi(n, t) { return 1 == t.length ? n : Vr(n, ke(t, 0, -1)) } function ai(n, t) { for (var r = n.length, e = nl(t.length, r), u = ru(n); e--;) { var i = t[e]; n[e] = Yu(i, r) ? u[i] : K } return n } function ci(n) { if ("string" == typeof n || Cf(n)) return n; var t = n + ""; return "0" == t && 1 / n == -bn ? "-0" : t } function li(n) { if (null != n) { try { return Ec.call(n) } catch (t) { } try { return n + "" } catch (t) { } } return "" } function si(n) { if (n instanceof Bt) return n.clone(); var t = new Ct(n.__wrapped__, n.__chain__); return t.__actions__ = ru(n.__actions__), t.__index__ = n.__index__, t.__values__ = n.__values__, t } function hi(n, t, r) { t = (r ? Hu(n, t, r) : t === K) ? 1 : Xc(Df(t), 0); var e = n ? n.length : 0; if (!e || 1 > t) return []; for (var u = 0, i = 0, o = Array(Kc(e / t)); e > u;)o[i++] = ke(n, u, u += t); return o } function pi(n) { for (var t = -1, r = n ? n.length : 0, e = 0, u = []; ++t < r;) { var i = n[t]; i && (u[e++] = i) } return u } function vi() { for (var n = arguments.length, t = Array(n ? n - 1 : 0), r = arguments[0], e = n; e--;)t[e - 1] = arguments[e]; return n ? s(ys(r) ? ru(r) : [r], Nr(t, 1)) : [] } function _i(n, t, r) { var e = n ? n.length : 0; return e ? (t = r || t === K ? 1 : Df(t), ke(n, 0 > t ? 0 : t, e)) : [] } function gi(n, t, r) { var e = n ? n.length : 0; return e ? (t = r || t === K ? 1 : Df(t), t = e - t, ke(n, 0, 0 > t ? 0 : t)) : [] } function yi(n, t) { return n && n.length ? ze(n, $u(t, 3), !0, !0) : [] } function di(n, t) { return n && n.length ? ze(n, $u(t, 3), !0) : [] } function bi(n, t, r, e) { var u = n ? n.length : 0; return u ? (r && "number" != typeof r && Hu(n, t, r) && (r = 0, e = u), Dr(n, t, r, e)) : [] } function wi(n, t, r) { var e = n ? n.length : 0; if (!e) return -1; var u = null == r ? 0 : Df(r); return 0 > u && (u = Xc(e + u, 0)), g(n, $u(t, 3), u) } function mi(n, t, r) { var e = n ? n.length : 0; if (!e) return -1; var u = e - 1; return r !== K && (u = Df(r), u = 0 > r ? Xc(e + u, 0) : nl(u, e - 1)), g(n, $u(t, 3), u, !0) } function xi(n) { var t = n ? n.length : 0; return t ? Nr(n, 1) : [] } function ji(n) { var t = n ? n.length : 0; return t ? Nr(n, bn) : [] } function Ai(n, t) { var r = n ? n.length : 0; return r ? (t = t === K ? 1 : Df(t), Nr(n, t)) : [] } function Oi(n) { for (var t = -1, r = n ? n.length : 0, e = {}; ++t < r;) { var u = n[t]; e[u[0]] = u[1] } return e } function ki(n) { return n && n.length ? n[0] : K } function Ii(n, t, r) { var e = n ? n.length : 0; if (!e) return -1; var u = null == r ? 0 : Df(r); return 0 > u && (u = Xc(e + u, 0)), y(n, t, u) } function Ri(n) { return gi(n, 1) } function Ei(n, t) { return n ? Hc.call(n, t) : "" } function Si(n) { var t = n ? n.length : 0; return t ? n[t - 1] : K } function Wi(n, t, r) { var e = n ? n.length : 0; if (!e) return -1; var u = e; if (r !== K && (u = Df(r), u = (0 > u ? Xc(e + u, 0) : nl(u, e - 1)) + 1), t !== t) return z(n, u - 1, !0); for (; u--;)if (n[u] === t) return u; return -1 } function Li(n, t) { return n && n.length ? ve(n, Df(t)) : K } function Ci(n, t) { return n && n.length && t && t.length ? we(n, t) : n } function Bi(n, t, r) { return n && n.length && t && t.length ? we(n, t, $u(r)) : n } function $i(n, t, r) { return n && n.length && t && t.length ? we(n, t, K, r) : n } function zi(n, t) { var r = []; if (!n || !n.length) return r; var e = -1, u = [], i = n.length; for (t = $u(t, 3); ++e < i;) { var o = n[e]; t(o, e, n) && (r.push(o), u.push(e)) } return me(n, u), r } function Ui(n) { return n ? ul.call(n) : n } function Fi(n, t, r) { var e = n ? n.length : 0; return e ? (r && "number" != typeof r && Hu(n, t, r) ? (t = 0, r = e) : (t = null == t ? 0 : Df(t), r = r === K ? e : Df(r)), ke(n, t, r)) : [] } function Mi(n, t) { return Re(n, t) } function Di(n, t, r) { return Ee(n, t, $u(r)) } function Pi(n, t) { var r = n ? n.length : 0; if (r) { var e = Re(n, t); if (r > e && tf(n[e], t)) return e } return -1 } function Ni(n, t) { return Re(n, t, !0) } function qi(n, t, r) { return Ee(n, t, $u(r), !0) } function Ti(n, t) { var r = n ? n.length : 0; if (r) { var e = Re(n, t, !0) - 1; if (tf(n[e], t)) return e } return -1 } function Zi(n) { return n && n.length ? Se(n) : [] } function Vi(n, t) { return n && n.length ? Se(n, $u(t)) : [] } function Ki(n) { return _i(n, 1) } function Gi(n, t, r) { return n && n.length ? (t = r || t === K ? 1 : Df(t), ke(n, 0, 0 > t ? 0 : t)) : [] } function Ji(n, t, r) { var e = n ? n.length : 0; return e ? (t = r || t === K ? 1 : Df(t), t = e - t, ke(n, 0 > t ? 0 : t, e)) : [] } function Yi(n, t) { return n && n.length ? ze(n, $u(t, 3), !1, !0) : [] } function Hi(n, t) { return n && n.length ? ze(n, $u(t, 3)) : [] } function Qi(n) { return n && n.length ? Ce(n) : [] } function Xi(n, t) { return n && n.length ? Ce(n, $u(t)) : [] } function no(n, t) { return n && n.length ? Ce(n, K, t) : [] } function to(n) { if (!n || !n.length) return []; var t = 0; return n = f(n, function (n) { return of(n) ? (t = Xc(n.length, t), !0) : void 0 }), j(t, function (t) { return l(n, de(t)) }) } function ro(n, t) { if (!n || !n.length) return []; var e = to(n); return null == t ? e : l(e, function (n) { return r(t, K, n) }) } function eo(n, t) { return Me(n || [], t || [], pr) } function uo(n, t) { return Me(n || [], t || [], Oe) } function io(n) { var t = Wt(n); return t.__chain__ = !0, t } function oo(n, t) { return t(n), n } function fo(n, t) { return t(n) } function ao() { return io(this) } function co() { return new Ct(this.value(), this.__chain__) } function lo() { this.__values__ === K && (this.__values__ = Ff(this.value())); var n = this.__index__ >= this.__values__.length, t = n ? K : this.__values__[this.__index__++]; return { done: n, value: t } } function so() { return this } function ho(n) { for (var t, r = this; r instanceof Lt;) { var e = si(r); e.__index__ = 0, e.__values__ = K, t ? u.__wrapped__ = e : t = e; var u = e; r = r.__wrapped__ } return u.__wrapped__ = n, t } function po() { var n = this.__wrapped__; if (n instanceof Bt) { var t = n; return this.__actions__.length && (t = new Bt(this)), t = t.reverse(), t.__actions__.push({ func: fo, args: [Ui], thisArg: K }), new Ct(t, this.__chain__) } return this.thru(Ui) } function vo() { return Ue(this.__wrapped__, this.__actions__) } function _o(n, t, r) { var e = ys(n) ? o : Fr; return r && Hu(n, t, r) && (t = K), e(n, $u(t, 3)) } function go(n, t) {
            var r = ys(n) ? f : Pr; return r(n, $u(t, 3));
        } function yo(n, t) { return Nr(Ao(n, t), 1) } function bo(n, t) { return Nr(Ao(n, t), bn) } function wo(n, t, r) { return r = r === K ? 1 : Df(r), Nr(Ao(n, t), r) } function mo(n, t) { var r = ys(n) ? u : jl; return r(n, $u(t, 3)) } function xo(n, t) { var r = ys(n) ? i : Al; return r(n, $u(t, 3)) } function jo(n, t, r, e) { n = uf(n) ? n : ya(n), r = r && !e ? Df(r) : 0; var u = n.length; return 0 > r && (r = Xc(u + r, 0)), Lf(n) ? u >= r && n.indexOf(t, r) > -1 : !!u && y(n, t, r) > -1 } function Ao(n, t) { var r = ys(n) ? l : ce; return r(n, $u(t, 3)) } function Oo(n, t, r, e) { return null == n ? [] : (ys(t) || (t = null == t ? [] : [t]), r = e ? K : r, ys(r) || (r = null == r ? [] : [r]), _e(n, t, r)) } function ko(n, t, r) { var e = ys(n) ? h : w, u = arguments.length < 3; return e(n, $u(t, 4), r, u, jl) } function Io(n, t, r) { var e = ys(n) ? p : w, u = arguments.length < 3; return e(n, $u(t, 4), r, u, Al) } function Ro(n, t) { var r = ys(n) ? f : Pr; return t = $u(t, 3), r(n, function (n, r, e) { return !t(n, r, e) }) } function Eo(n) { var t = uf(n) ? n : ya(n), r = t.length; return r > 0 ? t[xe(0, r - 1)] : K } function So(n, t, r) { var e = -1, u = Ff(n), i = u.length, o = i - 1; for (t = (r ? Hu(n, t, r) : t === K) ? 1 : Ir(Df(t), 0, i); ++e < t;) { var f = xe(e, o), a = u[f]; u[f] = u[e], u[e] = a } return u.length = t, u } function Wo(n) { return So(n, jn) } function Lo(n) { if (null == n) return 0; if (uf(n)) { var t = n.length; return t && Lf(n) ? q(n) : t } if (bf(n)) { var r = Pu(n); if (r == Cn || r == Fn) return n.size } return ua(n).length } function Co(n, t, r) { var e = ys(n) ? v : Ie; return r && Hu(n, t, r) && (t = K), e(n, $u(t, 3)) } function Bo() { return bc.now() } function $o(n, t) { if ("function" != typeof t) throw new jc(Y); return n = Df(n), function () { return --n < 1 ? t.apply(this, arguments) : void 0 } } function zo(n, t, r) { return t = r ? K : t, t = n && null == t ? n.length : t, Iu(n, fn, K, K, K, K, t) } function Uo(n, t) { var r; if ("function" != typeof t) throw new jc(Y); return n = Df(n), function () { return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = K), r } } function Fo(n, t, r) { t = r ? K : t; var e = Iu(n, rn, K, K, K, K, K, t); return e.placeholder = Fo.placeholder, e } function Mo(n, t, r) { t = r ? K : t; var e = Iu(n, en, K, K, K, K, K, t); return e.placeholder = Mo.placeholder, e } function Do(n, t, r) { function e(t) { var r = h, e = p; return h = p = K, d = t, _ = n.apply(e, r) } function u(n) { return d = n, g = Vc(f, t), b ? e(n) : _ } function i(n) { var r = n - y, e = n - d, u = t - r; return w ? nl(u, v - e) : u } function o(n) { var r = n - y, e = n - d; return y === K || r >= t || 0 > r || w && e >= v } function f() { var n = Bo(); return o(n) ? a(n) : void (g = Vc(f, i(n))) } function a(n) { return g = K, m && h ? e(n) : (h = p = K, _) } function c() { d = 0, h = y = p = g = K } function l() { return g === K ? _ : a(Bo()) } function s() { var n = Bo(), r = o(n); if (h = arguments, p = this, y = n, r) { if (g === K) return u(y); if (w) return g = Vc(f, t), e(y) } return g === K && (g = Vc(f, t)), _ } var h, p, v, _, g, y, d = 0, b = !1, w = !1, m = !0; if ("function" != typeof n) throw new jc(Y); return t = Nf(t) || 0, df(r) && (b = !!r.leading, w = "maxWait" in r, v = w ? Xc(Nf(r.maxWait) || 0, t) : v, m = "trailing" in r ? !!r.trailing : m), s.cancel = c, s.flush = l, s } function Po(n) { return Iu(n, cn) } function No(n, t) { if ("function" != typeof n || t && "function" != typeof t) throw new jc(Y); var r = function () { var e = arguments, u = t ? t.apply(this, e) : e[0], i = r.cache; if (i.has(u)) return i.get(u); var o = n.apply(this, e); return r.cache = i.set(u, o), o }; return r.cache = new (No.Cache || Yt), r } function qo(n) { if ("function" != typeof n) throw new jc(Y); return function () { return !n.apply(this, arguments) } } function To(n) { return Uo(2, n) } function Zo(n, t) { if ("function" != typeof n) throw new jc(Y); return t = Xc(t === K ? n.length - 1 : Df(t), 0), function () { for (var e = arguments, u = -1, i = Xc(e.length - t, 0), o = Array(i); ++u < i;)o[u] = e[t + u]; switch (t) { case 0: return n.call(this, o); case 1: return n.call(this, e[0], o); case 2: return n.call(this, e[0], e[1], o) }var f = Array(t + 1); for (u = -1; ++u < t;)f[u] = e[u]; return f[t] = o, r(n, this, f) } } function Vo(n, t) { if ("function" != typeof n) throw new jc(Y); return t = t === K ? 0 : Xc(Df(t), 0), Zo(function (e) { var u = e[t], i = qe(e, 0, t); return u && s(i, u), r(n, this, i) }) } function Ko(n, t, r) { var e = !0, u = !0; if ("function" != typeof n) throw new jc(Y); return df(r) && (e = "leading" in r ? !!r.leading : e, u = "trailing" in r ? !!r.trailing : u), Do(n, t, { leading: e, maxWait: t, trailing: u }) } function Go(n) { return zo(n, 1) } function Jo(n, t) { return t = null == t ? Ka : t, hs(t, n) } function Yo() { if (!arguments.length) return []; var n = arguments[0]; return ys(n) ? n : [n] } function Ho(n) { return Sr(n, !1, !0) } function Qo(n, t) { return Sr(n, !1, !0, t) } function Xo(n) { return Sr(n, !0, !0) } function nf(n, t) { return Sr(n, !0, !0, t) } function tf(n, t) { return n === t || n !== n && t !== t } function rf(n) { return of(n) && Sc.call(n, "callee") && (!Tc.call(n, "callee") || Cc.call(n) == kn) } function ef(n) { return bf(n) && Cc.call(n) == qn } function uf(n) { return null != n && yf(Sl(n)) && !_f(n) } function of(n) { return bf(n) && uf(n) } function ff(n) { return n === !0 || n === !1 || bf(n) && Cc.call(n) == Rn } function af(n) { return bf(n) && Cc.call(n) == En } function cf(n) { return !!n && 1 === n.nodeType && bf(n) && !Rf(n) } function lf(n) { if (uf(n) && (ys(n) || Lf(n) || _f(n.splice) || rf(n) || ds(n))) return !n.length; if (bf(n)) { var t = Pu(n); if (t == Cn || t == Fn) return !n.size } for (var r in n) if (Sc.call(n, r)) return !1; return !(pl && ua(n).length) } function sf(n, t) { return te(n, t) } function hf(n, t, r) { r = "function" == typeof r ? r : K; var e = r ? r(n, t) : K; return e === K ? te(n, t, r) : !!e } function pf(n) { return bf(n) ? Cc.call(n) == Sn || "string" == typeof n.message && "string" == typeof n.name : !1 } function vf(n) { return "number" == typeof n && Yc(n) } function _f(n) { var t = df(n) ? Cc.call(n) : ""; return t == Wn || t == Ln } function gf(n) { return "number" == typeof n && n == Df(n) } function yf(n) { return "number" == typeof n && n > -1 && n % 1 == 0 && wn >= n } function df(n) { var t = typeof n; return !!n && ("object" == t || "function" == t) } function bf(n) { return !!n && "object" == typeof n } function wf(n) { return bf(n) && Pu(n) == Cn } function mf(n, t) { return n === t || ee(n, t, Uu(t)) } function xf(n, t, r) { return r = "function" == typeof r ? r : K, ee(n, t, Uu(t), r) } function jf(n) { return If(n) && n != +n } function Af(n) { if (Ll(n)) throw new wc("This method is not supported with `core-js`. Try https://github.com/es-shims."); return ue(n) } function Of(n) { return null === n } function kf(n) { return null == n } function If(n) { return "number" == typeof n || bf(n) && Cc.call(n) == Bn } function Rf(n) { if (!bf(n) || Cc.call(n) != $n || U(n)) return !1; var t = Mu(n); if (null === t) return !0; var r = Sc.call(t, "constructor") && t.constructor; return "function" == typeof r && r instanceof r && Ec.call(r) == Lc } function Ef(n) { return df(n) && Cc.call(n) == Un } function Sf(n) { return gf(n) && n >= -wn && wn >= n } function Wf(n) { return bf(n) && Pu(n) == Fn } function Lf(n) { return "string" == typeof n || !ys(n) && bf(n) && Cc.call(n) == Mn } function Cf(n) { return "symbol" == typeof n || bf(n) && Cc.call(n) == Dn } function Bf(n) { return bf(n) && yf(n.length) && !!xr[Cc.call(n)] } function $f(n) { return n === K } function zf(n) { return bf(n) && Pu(n) == Pn } function Uf(n) { return bf(n) && Cc.call(n) == Nn } function Ff(n) { if (!n) return []; if (uf(n)) return Lf(n) ? T(n) : ru(n); if (Nc && n[Nc]) return F(n[Nc]()); var t = Pu(n), r = t == Cn ? M : t == Fn ? P : ya; return r(n) } function Mf(n) { if (!n) return 0 === n ? n : 0; if (n = Nf(n), n === bn || n === -bn) { var t = 0 > n ? -1 : 1; return t * mn } return n === n ? n : 0 } function Df(n) { var t = Mf(n), r = t % 1; return t === t ? r ? t - r : t : 0 } function Pf(n) { return n ? Ir(Df(n), 0, jn) : 0 } function Nf(n) { if ("number" == typeof n) return n; if (Cf(n)) return xn; if (df(n)) { var t = _f(n.valueOf) ? n.valueOf() : n; n = df(t) ? t + "" : t } if ("string" != typeof n) return 0 === n ? n : +n; n = n.replace(_t, ""); var r = At.test(n); return r || kt.test(n) ? Er(n.slice(2), r ? 2 : 8) : jt.test(n) ? xn : +n } function qf(n) { return eu(n, ia(n)) } function Tf(n) { return Ir(Df(n), -wn, wn) } function Zf(n) { return null == n ? "" : Le(n) } function Vf(n, t) { var r = Cr(n); return t ? Or(r, t) : r } function Kf(n, t) { return _(n, $u(t, 3), qr) } function Gf(n, t) { return _(n, $u(t, 3), Tr) } function Jf(n, t) { return null == n ? n : Ol(n, $u(t, 3), ia) } function Yf(n, t) { return null == n ? n : kl(n, $u(t, 3), ia) } function Hf(n, t) { return n && qr(n, $u(t, 3)) } function Qf(n, t) { return n && Tr(n, $u(t, 3)) } function Xf(n) { return null == n ? [] : Zr(n, ua(n)) } function na(n) { return null == n ? [] : Zr(n, ia(n)) } function ta(n, t, r) { var e = null == n ? K : Vr(n, t); return e === K ? r : e } function ra(n, t) { return null != n && qu(n, t, Jr) } function ea(n, t) { return null != n && qu(n, t, Yr) } function ua(n) { var t = ri(n); if (!t && !uf(n)) return oe(n); var r = Ku(n), e = !!r, u = r || [], i = u.length; for (var o in n) !Jr(n, o) || e && ("length" == o || Yu(o, i)) || t && "constructor" == o || u.push(o); return u } function ia(n) { for (var t = -1, r = ri(n), e = fe(n), u = e.length, i = Ku(n), o = !!i, f = i || [], a = f.length; ++t < u;) { var c = e[t]; o && ("length" == c || Yu(c, a)) || "constructor" == c && (r || !Sc.call(n, c)) || f.push(c) } return f } function oa(n, t) { var r = {}; return t = $u(t, 3), qr(n, function (n, e, u) { r[t(n, e, u)] = n }), r } function fa(n, t) { var r = {}; return t = $u(t, 3), qr(n, function (n, e, u) { r[e] = t(n, e, u) }), r } function aa(n, t) { return t = $u(t), ye(n, function (n, r) { return !t(n, r) }) } function ca(n, t) { return null == n ? {} : ye(n, $u(t)) } function la(n, t, r) { t = Qu(t, n) ? [t] : Ne(t); var e = -1, u = t.length; for (u || (n = K, u = 1); ++e < u;) { var i = null == n ? K : n[ci(t[e])]; i === K && (e = u, i = r), n = _f(i) ? i.call(n) : i } return n } function sa(n, t, r) { return null == n ? n : Oe(n, t, r) } function ha(n, t, r, e) { return e = "function" == typeof e ? e : K, null == n ? n : Oe(n, t, r, e) } function pa(n, t, r) { var e = ys(n) || Bf(n); if (t = $u(t, 4), null == r) if (e || df(n)) { var i = n.constructor; r = e ? ys(n) ? new i : [] : _f(i) ? Cr(Mu(n)) : {} } else r = {}; return (e ? u : qr)(n, function (n, e, u) { return t(r, n, e, u) }), r } function va(n, t) { return null == n ? !0 : Be(n, t) } function _a(n, t, r) { return null == n ? n : $e(n, t, Pe(r)) } function ga(n, t, r, e) { return e = "function" == typeof e ? e : K, null == n ? n : $e(n, t, Pe(r), e) } function ya(n) { return n ? k(n, ua(n)) : [] } function da(n) { return null == n ? [] : k(n, ia(n)) } function ba(n, t, r) { return r === K && (r = t, t = K), r !== K && (r = Nf(r), r = r === r ? r : 0), t !== K && (t = Nf(t), t = t === t ? t : 0), Ir(Nf(n), t, r) } function wa(n, t, r) { return t = Nf(t) || 0, r === K ? (r = t, t = 0) : r = Nf(r) || 0, n = Nf(n), Hr(n, t, r) } function ma(n, t, r) { if (r && "boolean" != typeof r && Hu(n, t, r) && (t = r = K), r === K && ("boolean" == typeof t ? (r = t, t = K) : "boolean" == typeof n && (r = n, n = K)), n === K && t === K ? (n = 0, t = 1) : (n = Nf(n) || 0, t === K ? (t = n, n = 0) : t = Nf(t) || 0), n > t) { var e = n; n = t, t = e } if (r || n % 1 || t % 1) { var u = rl(); return nl(n + u * (t - n + Rr("1e-" + ((u + "").length - 1))), t) } return xe(n, t) } function xa(n) { return Ts(Zf(n).toLowerCase()) } function ja(n) { return n = Zf(n), n && n.replace(Rt, L).replace(_r, "") } function Aa(n, t, r) { n = Zf(n), t = Le(t); var e = n.length; return r = r === K ? e : Ir(Df(r), 0, e), r -= t.length, r >= 0 && n.indexOf(t, r) == r } function Oa(n) { return n = Zf(n), n && ot.test(n) ? n.replace(ut, C) : n } function ka(n) { return n = Zf(n), n && vt.test(n) ? n.replace(pt, "\\$&") : n } function Ia(n, t, r) { n = Zf(n), t = Df(t); var e = t ? q(n) : 0; if (!t || e >= t) return n; var u = (t - e) / 2; return wu(Gc(u), r) + n + wu(Kc(u), r) } function Ra(n, t, r) { n = Zf(n), t = Df(t); var e = t ? q(n) : 0; return t && t > e ? n + wu(t - e, r) : n } function Ea(n, t, r) { n = Zf(n), t = Df(t); var e = t ? q(n) : 0; return t && t > e ? wu(t - e, r) + n : n } function Sa(n, t, r) { return r || null == t ? t = 0 : t && (t = +t), n = Zf(n).replace(_t, ""), tl(n, t || (xt.test(n) ? 16 : 10)) } function Wa(n, t, r) { return t = (r ? Hu(n, t, r) : t === K) ? 1 : Df(t), Ae(Zf(n), t) } function La() { var n = arguments, t = Zf(n[0]); return n.length < 3 ? t : el.call(t, n[1], n[2]) } function Ca(n, t, r) { return r && "number" != typeof r && Hu(n, t, r) && (t = r = K), (r = r === K ? jn : r >>> 0) ? (n = Zf(n), n && ("string" == typeof t || null != t && !Ef(t)) && (t = Le(t), "" == t && dr.test(n)) ? qe(T(n), 0, r) : il.call(n, t, r)) : [] } function Ba(n, t, r) { return n = Zf(n), r = Ir(Df(r), 0, n.length), n.lastIndexOf(Le(t), r) == r } function $a(n, t, r) { var e = Wt.templateSettings; r && Hu(n, t, r) && (t = K), n = Zf(n), t = js({}, t, e, sr); var u, i, o = js({}, t.imports, e.imports, sr), f = ua(o), a = k(o, f), c = 0, l = t.interpolate || Et, s = "__p += '", h = xc((t.escape || Et).source + "|" + l.source + "|" + (l === ct ? wt : Et).source + "|" + (t.evaluate || Et).source + "|$", "g"), p = "//# sourceURL=" + ("sourceURL" in t ? t.sourceURL : "lodash.templateSources[" + ++mr + "]") + "\n"; n.replace(h, function (t, r, e, o, f, a) { return e || (e = o), s += n.slice(c, a).replace(St, B), r && (u = !0, s += "' +\n__e(" + r + ") +\n'"), f && (i = !0, s += "';\n" + f + ";\n__p += '"), e && (s += "' +\n((__t = (" + e + ")) == null ? '' : __t) +\n'"), c = a + t.length, t }), s += "';\n"; var v = t.variable; v || (s = "with (obj) {\n" + s + "\n}\n"), s = (i ? s.replace(nt, "") : s).replace(tt, "$1").replace(rt, "$1;"), s = "function(" + (v || "obj") + ") {\n" + (v ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (u ? ", __e = _.escape" : "") + (i ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + s + "return __p\n}"; var _ = Zs(function () { return Function(f, p + "return " + s).apply(K, a) }); if (_.source = s, pf(_)) throw _; return _ } function za(n) { return Zf(n).toLowerCase() } function Ua(n) { return Zf(n).toUpperCase() } function Fa(n, t, r) { if (n = Zf(n), n && (r || t === K)) return n.replace(_t, ""); if (!n || !(t = Le(t))) return n; var e = T(n), u = T(t), i = R(e, u), o = E(e, u) + 1; return qe(e, i, o).join("") } function Ma(n, t, r) { if (n = Zf(n), n && (r || t === K)) return n.replace(yt, ""); if (!n || !(t = Le(t))) return n; var e = T(n), u = E(e, T(t)) + 1; return qe(e, 0, u).join("") } function Da(n, t, r) { if (n = Zf(n), n && (r || t === K)) return n.replace(gt, ""); if (!n || !(t = Le(t))) return n; var e = T(n), u = R(e, T(t)); return qe(e, u).join("") } function Pa(n, t) { var r = hn, e = pn; if (df(t)) { var u = "separator" in t ? t.separator : u; r = "length" in t ? Df(t.length) : r, e = "omission" in t ? Le(t.omission) : e } n = Zf(n); var i = n.length; if (dr.test(n)) { var o = T(n); i = o.length } if (r >= i) return n; var f = r - q(e); if (1 > f) return e; var a = o ? qe(o, 0, f).join("") : n.slice(0, f); if (u === K) return a + e; if (o && (f += a.length - f), Ef(u)) { if (n.slice(f).search(u)) { var c, l = a; for (u.global || (u = xc(u.source, Zf(mt.exec(u)) + "g")), u.lastIndex = 0; c = u.exec(l);)var s = c.index; a = a.slice(0, s === K ? f : s) } } else if (n.indexOf(Le(u), f) != f) { var h = a.lastIndexOf(u); h > -1 && (a = a.slice(0, h)) } return a + e } function Na(n) { return n = Zf(n), n && it.test(n) ? n.replace(et, Z) : n } function qa(n, t, r) { return n = Zf(n), t = r ? K : t, t === K && (t = br.test(n) ? yr : dt), n.match(t) || [] } function Ta(n) { var t = n ? n.length : 0, e = $u(); return n = t ? l(n, function (n) { if ("function" != typeof n[1]) throw new jc(Y); return [e(n[0]), n[1]] }) : [], Zo(function (e) { for (var u = -1; ++u < t;) { var i = n[u]; if (r(i[0], this, e)) return r(i[1], this, e) } }) } function Za(n) { return Wr(Sr(n, !0)) } function Va(n) { return function () { return n } } function Ka(n) { return n } function Ga(n) { return ie("function" == typeof n ? n : Sr(n, !0)) } function Ja(n) { return le(Sr(n, !0)) } function Ya(n, t) { return se(n, Sr(t, !0)) } function Ha(n, t, r) { var e = ua(t), i = Zr(t, e); null != r || df(t) && (i.length || !e.length) || (r = t, t = n, n = this, i = Zr(t, ua(t))); var o = !(df(r) && "chain" in r && !r.chain), f = _f(n); return u(i, function (r) { var e = t[r]; n[r] = e, f && (n.prototype[r] = function () { var t = this.__chain__; if (o || t) { var r = n(this.__wrapped__), u = r.__actions__ = ru(this.__actions__); return u.push({ func: e, args: arguments, thisArg: n }), r.__chain__ = t, r } return e.apply(n, s([this.value()], arguments)) }) }), n } function Qa() { return zr._ === this && (zr._ = Bc), this } function Xa() { } function nc(n) { return n = Df(n), Zo(function (t) { return ve(t, n) }) } function tc(n) { return Qu(n) ? de(ci(n)) : be(n) } function rc(n) { return function (t) { return null == n ? K : Vr(n, t) } } function ec() { return [] } function uc() { return !1 } function ic() { return {} } function oc() { return "" } function fc() { return !0 } function ac(n, t) { if (n = Df(n), 1 > n || n > wn) return []; var r = jn, e = nl(n, jn); t = $u(t), n -= jn; for (var u = j(e, t); ++r < n;)t(r); return u } function cc(n) { return ys(n) ? l(n, ci) : Cf(n) ? [n] : ru(Bl(n)) } function lc(n) { var t = ++Wc; return Zf(n) + t } function sc(n) { return n && n.length ? Mr(n, Ka, Gr) : K } function hc(n, t) { return n && n.length ? Mr(n, $u(t), Gr) : K } function pc(n) { return b(n, Ka) } function vc(n, t) { return b(n, $u(t)) } function _c(n) { return n && n.length ? Mr(n, Ka, ae) : K } function gc(n, t) { return n && n.length ? Mr(n, $u(t), ae) : K } function yc(n) { return n && n.length ? x(n, Ka) : 0 } function dc(n, t) { return n && n.length ? x(n, $u(t)) : 0 } S = S ? Ur.defaults({}, S, Ur.pick(zr, wr)) : zr; var bc = S.Date, wc = S.Error, mc = S.Math, xc = S.RegExp, jc = S.TypeError, Ac = S.Array.prototype, Oc = S.Object.prototype, kc = S.String.prototype, Ic = S["__core-js_shared__"], Rc = function () { var n = /[^.]+$/.exec(Ic && Ic.keys && Ic.keys.IE_PROTO || ""); return n ? "Symbol(src)_1." + n : "" }(), Ec = S.Function.prototype.toString, Sc = Oc.hasOwnProperty, Wc = 0, Lc = Ec.call(Object), Cc = Oc.toString, Bc = zr._, $c = xc("^" + Ec.call(Sc).replace(pt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), zc = Lr ? S.Buffer : K, Uc = S.Reflect, Fc = S.Symbol, Mc = S.Uint8Array, Dc = Uc ? Uc.enumerate : K, Pc = Object.getOwnPropertySymbols, Nc = "symbol" == typeof (Nc = Fc && Fc.iterator) ? Nc : K, qc = Object.create, Tc = Oc.propertyIsEnumerable, Zc = Ac.splice, Vc = function (n, t) { return S.setTimeout.call(zr, n, t) }, Kc = mc.ceil, Gc = mc.floor, Jc = Object.getPrototypeOf, Yc = S.isFinite, Hc = Ac.join, Qc = Object.keys, Xc = mc.max, nl = mc.min, tl = S.parseInt, rl = mc.random, el = kc.replace, ul = Ac.reverse, il = kc.split, ol = Fu(S, "DataView"), fl = Fu(S, "Map"), al = Fu(S, "Promise"), cl = Fu(S, "Set"), ll = Fu(S, "WeakMap"), sl = Fu(Object, "create"), hl = ll && new ll, pl = !Tc.call({ valueOf: 1 }, "valueOf"), vl = {}, _l = li(ol), gl = li(fl), yl = li(al), dl = li(cl), bl = li(ll), wl = Fc ? Fc.prototype : K, ml = wl ? wl.valueOf : K, xl = wl ? wl.toString : K; Wt.templateSettings = { escape: ft, evaluate: at, interpolate: ct, variable: "", imports: { _: Wt } }, Wt.prototype = Lt.prototype, Wt.prototype.constructor = Wt, Ct.prototype = Cr(Lt.prototype), Ct.prototype.constructor = Ct, Bt.prototype = Cr(Lt.prototype), Bt.prototype.constructor = Bt, Ft.prototype.clear = Mt, Ft.prototype["delete"] = Dt, Ft.prototype.get = Pt, Ft.prototype.has = Nt, Ft.prototype.set = qt, Tt.prototype.clear = Zt, Tt.prototype["delete"] = Vt, Tt.prototype.get = Kt, Tt.prototype.has = Gt, Tt.prototype.set = Jt, Yt.prototype.clear = Ht, Yt.prototype["delete"] = Qt, Yt.prototype.get = Xt, Yt.prototype.has = nr, Yt.prototype.set = tr, rr.prototype.add = rr.prototype.push = er, rr.prototype.has = ur, ir.prototype.clear = or, ir.prototype["delete"] = fr, ir.prototype.get = ar, ir.prototype.has = cr, ir.prototype.set = lr; var jl = fu(qr), Al = fu(Tr, !0), Ol = au(), kl = au(!0); Dc && !Tc.call({ valueOf: 1 }, "valueOf") && (fe = function (n) { return F(Dc(n)) }); var Il = hl ? function (n, t) { return hl.set(n, t), n } : Ka, Rl = cl && 1 / P(new cl([, -0]))[1] == bn ? function (n) { return new cl(n) } : Xa, El = hl ? function (n) { return hl.get(n) } : Xa, Sl = de("length"); Pc || (Du = ec); var Wl = Pc ? function (n) { for (var t = []; n;)s(t, Du(n)), n = Mu(n); return t } : Du; (ol && Pu(new ol(new ArrayBuffer(1))) != Tn || fl && Pu(new fl) != Cn || al && Pu(al.resolve()) != zn || cl && Pu(new cl) != Fn || ll && Pu(new ll) != Pn) && (Pu = function (n) { var t = Cc.call(n), r = t == $n ? n.constructor : K, e = r ? li(r) : K; if (e) switch (e) { case _l: return Tn; case gl: return Cn; case yl: return zn; case dl: return Fn; case bl: return Pn }return t }); var Ll = Ic ? _f : uc, Cl = function () { var n = 0, t = 0; return function (r, e) { var u = Bo(), i = _n - (u - t); if (t = u, i > 0) { if (++n >= vn) return r } else n = 0; return Il(r, e) } }(), Bl = No(function (n) { var t = []; return Zf(n).replace(ht, function (n, r, e, u) { t.push(e ? u.replace(bt, "$1") : r || n) }), t }), $l = Zo(function (n, t) { return of(n) ? $r(n, Nr(t, 1, of, !0)) : [] }), zl = Zo(function (n, t) { var r = Si(t); return of(r) && (r = K), of(n) ? $r(n, Nr(t, 1, of, !0), $u(r)) : [] }), Ul = Zo(function (n, t) { var r = Si(t); return of(r) && (r = K), of(n) ? $r(n, Nr(t, 1, of, !0), K, r) : [] }), Fl = Zo(function (n) { var t = l(n, De); return t.length && t[0] === n[0] ? Qr(t) : [] }), Ml = Zo(function (n) { var t = Si(n), r = l(n, De); return t === Si(r) ? t = K : r.pop(), r.length && r[0] === n[0] ? Qr(r, $u(t)) : [] }), Dl = Zo(function (n) { var t = Si(n), r = l(n, De); return t === Si(r) ? t = K : r.pop(), r.length && r[0] === n[0] ? Qr(r, K, t) : [] }), Pl = Zo(Ci), Nl = Zo(function (n, t) { t = Nr(t, 1); var r = n ? n.length : 0, e = kr(n, t); return me(n, l(t, function (n) { return Yu(n, r) ? +n : n }).sort(Qe)), e }), ql = Zo(function (n) { return Ce(Nr(n, 1, of, !0)) }), Tl = Zo(function (n) { var t = Si(n); return of(t) && (t = K), Ce(Nr(n, 1, of, !0), $u(t)) }), Zl = Zo(function (n) { var t = Si(n); return of(t) && (t = K), Ce(Nr(n, 1, of, !0), K, t) }), Vl = Zo(function (n, t) { return of(n) ? $r(n, t) : [] }), Kl = Zo(function (n) { return Fe(f(n, of)) }), Gl = Zo(function (n) { var t = Si(n); return of(t) && (t = K), Fe(f(n, of), $u(t)) }), Jl = Zo(function (n) { var t = Si(n); return of(t) && (t = K), Fe(f(n, of), K, t) }), Yl = Zo(to), Hl = Zo(function (n) { var t = n.length, r = t > 1 ? n[t - 1] : K; return r = "function" == typeof r ? (n.pop(), r) : K, ro(n, r) }), Ql = Zo(function (n) { n = Nr(n, 1); var t = n.length, r = t ? n[0] : 0, e = this.__wrapped__, u = function (t) { return kr(t, n) }; return !(t > 1 || this.__actions__.length) && e instanceof Bt && Yu(r) ? (e = e.slice(r, +r + (t ? 1 : 0)), e.__actions__.push({ func: fo, args: [u], thisArg: K }), new Ct(e, this.__chain__).thru(function (n) { return t && !n.length && n.push(K), n })) : this.thru(u) }), Xl = iu(function (n, t, r) { Sc.call(n, r) ? ++n[r] : n[r] = 1 }), ns = vu(wi), ts = vu(mi), rs = iu(function (n, t, r) { Sc.call(n, r) ? n[r].push(t) : n[r] = [t] }), es = Zo(function (n, t, e) { var u = -1, i = "function" == typeof t, o = Qu(t), f = uf(n) ? Array(n.length) : []; return jl(n, function (n) { var a = i ? t : o && null != n ? n[t] : K; f[++u] = a ? r(a, n, e) : ne(n, t, e) }), f }), us = iu(function (n, t, r) { n[r] = t }), is = iu(function (n, t, r) { n[r ? 0 : 1].push(t) }, function () { return [[], []] }), os = Zo(function (n, t) { if (null == n) return []; var r = t.length; return r > 1 && Hu(n, t[0], t[1]) ? t = [] : r > 2 && Hu(t[0], t[1], t[2]) && (t = [t[0]]), t = 1 == t.length && ys(t[0]) ? t[0] : Nr(t, 1, Ju), _e(n, t, []) }), fs = Zo(function (n, t, r) { var e = X; if (r.length) { var u = D(r, Bu(fs)); e |= un } return Iu(n, e, t, r, u) }), as = Zo(function (n, t, r) { var e = X | nn; if (r.length) { var u = D(r, Bu(as)); e |= un } return Iu(t, e, n, r, u) }), cs = Zo(function (n, t) { return Br(n, 1, t) }), ls = Zo(function (n, t, r) { return Br(n, Nf(t) || 0, r) }); No.Cache = Yt; var ss = Zo(function (n, t) { t = 1 == t.length && ys(t[0]) ? l(t[0], O($u())) : l(Nr(t, 1, Ju), O($u())); var e = t.length; return Zo(function (u) { for (var i = -1, o = nl(u.length, e); ++i < o;)u[i] = t[i].call(this, u[i]); return r(n, this, u) }) }), hs = Zo(function (n, t) { var r = D(t, Bu(hs)); return Iu(n, un, K, t, r) }), ps = Zo(function (n, t) { var r = D(t, Bu(ps)); return Iu(n, on, K, t, r) }), vs = Zo(function (n, t) { return Iu(n, an, K, K, K, Nr(t, 1)) }), _s = ju(Gr), gs = ju(function (n, t) { return n >= t }), ys = Array.isArray, ds = zc ? function (n) { return n instanceof zc } : uc, bs = ju(ae), ws = ju(function (n, t) { return t >= n }), ms = ou(function (n, t) { if (pl || ri(t) || uf(t)) return void eu(t, ua(t), n); for (var r in t) Sc.call(t, r) && pr(n, r, t[r]) }), xs = ou(function (n, t) { if (pl || ri(t) || uf(t)) return void eu(t, ia(t), n); for (var r in t) pr(n, r, t[r]) }), js = ou(function (n, t, r, e) { eu(t, ia(t), n, e) }), As = ou(function (n, t, r, e) { eu(t, ua(t), n, e) }), Os = Zo(function (n, t) { return kr(n, Nr(t, 1)) }), ks = Zo(function (n) { return n.push(K, sr), r(js, K, n) }), Is = Zo(function (n) { return n.push(K, oi), r(Ls, K, n) }), Rs = yu(function (n, t, r) { n[t] = r }, Va(Ka)), Es = yu(function (n, t, r) { Sc.call(n, t) ? n[t].push(r) : n[t] = [r] }, $u), Ss = Zo(ne), Ws = ou(function (n, t, r) { he(n, t, r) }), Ls = ou(function (n, t, r, e) { he(n, t, r, e) }), Cs = Zo(function (n, t) { return null == n ? {} : (t = l(Nr(t, 1), ci), ge(n, $r(Lu(n), t))) }), Bs = Zo(function (n, t) { return null == n ? {} : ge(n, l(Nr(t, 1), ci)) }), $s = ku(ua), zs = ku(ia), Us = su(function (n, t, r) { return t = t.toLowerCase(), n + (r ? xa(t) : t) }), Fs = su(function (n, t, r) { return n + (r ? "-" : "") + t.toLowerCase() }), Ms = su(function (n, t, r) { return n + (r ? " " : "") + t.toLowerCase() }), Ds = lu("toLowerCase"), Ps = su(function (n, t, r) { return n + (r ? "_" : "") + t.toLowerCase() }), Ns = su(function (n, t, r) { return n + (r ? " " : "") + Ts(t) }), qs = su(function (n, t, r) { return n + (r ? " " : "") + t.toUpperCase() }), Ts = lu("toUpperCase"), Zs = Zo(function (n, t) { try { return r(n, K, t) } catch (e) { return pf(e) ? e : new wc(e) } }), Vs = Zo(function (n, t) { return u(Nr(t, 1), function (t) { t = ci(t), n[t] = fs(n[t], n) }), n }), Ks = _u(), Gs = _u(!0), Js = Zo(function (n, t) { return function (r) { return ne(r, n, t) } }), Ys = Zo(function (n, t) { return function (r) { return ne(n, r, t) } }), Hs = bu(l), Qs = bu(o), Xs = bu(v), nh = xu(), th = xu(!0), rh = du(function (n, t) { return n + t }), eh = Ou("ceil"), uh = du(function (n, t) { return n / t }), ih = Ou("floor"), oh = du(function (n, t) { return n * t }), fh = Ou("round"), ah = du(function (n, t) { return n - t }); return Wt.after = $o, Wt.ary = zo, Wt.assign = ms, Wt.assignIn = xs, Wt.assignInWith = js, Wt.assignWith = As, Wt.at = Os, Wt.before = Uo, Wt.bind = fs, Wt.bindAll = Vs, Wt.bindKey = as, Wt.castArray = Yo, Wt.chain = io, Wt.chunk = hi, Wt.compact = pi, Wt.concat = vi, Wt.cond = Ta, Wt.conforms = Za, Wt.constant = Va, Wt.countBy = Xl, Wt.create = Vf, Wt.curry = Fo, Wt.curryRight = Mo, Wt.debounce = Do, Wt.defaults = ks, Wt.defaultsDeep = Is, Wt.defer = cs, Wt.delay = ls, Wt.difference = $l, Wt.differenceBy = zl, Wt.differenceWith = Ul, Wt.drop = _i, Wt.dropRight = gi, Wt.dropRightWhile = yi, Wt.dropWhile = di, Wt.fill = bi, Wt.filter = go, Wt.flatMap = yo, Wt.flatMapDeep = bo, Wt.flatMapDepth = wo, Wt.flatten = xi, Wt.flattenDeep = ji, Wt.flattenDepth = Ai, Wt.flip = Po, Wt.flow = Ks, Wt.flowRight = Gs, Wt.fromPairs = Oi, Wt.functions = Xf, Wt.functionsIn = na, Wt.groupBy = rs, Wt.initial = Ri, Wt.intersection = Fl, Wt.intersectionBy = Ml, Wt.intersectionWith = Dl, Wt.invert = Rs, Wt.invertBy = Es, Wt.invokeMap = es, Wt.iteratee = Ga, Wt.keyBy = us, Wt.keys = ua, Wt.keysIn = ia, Wt.map = Ao, Wt.mapKeys = oa, Wt.mapValues = fa, Wt.matches = Ja, Wt.matchesProperty = Ya, Wt.memoize = No, Wt.merge = Ws, Wt.mergeWith = Ls, Wt.method = Js, Wt.methodOf = Ys, Wt.mixin = Ha, Wt.negate = qo, Wt.nthArg = nc, Wt.omit = Cs, Wt.omitBy = aa, Wt.once = To, Wt.orderBy = Oo, Wt.over = Hs, Wt.overArgs = ss, Wt.overEvery = Qs, Wt.overSome = Xs, Wt.partial = hs, Wt.partialRight = ps, Wt.partition = is, Wt.pick = Bs, Wt.pickBy = ca, Wt.property = tc, Wt.propertyOf = rc, Wt.pull = Pl, Wt.pullAll = Ci, Wt.pullAllBy = Bi, Wt.pullAllWith = $i, Wt.pullAt = Nl, Wt.range = nh, Wt.rangeRight = th, Wt.rearg = vs, Wt.reject = Ro, Wt.remove = zi, Wt.rest = Zo, Wt.reverse = Ui, Wt.sampleSize = So, Wt.set = sa, Wt.setWith = ha, Wt.shuffle = Wo, Wt.slice = Fi, Wt.sortBy = os, Wt.sortedUniq = Zi, Wt.sortedUniqBy = Vi, Wt.split = Ca, Wt.spread = Vo, Wt.tail = Ki, Wt.take = Gi, Wt.takeRight = Ji, Wt.takeRightWhile = Yi, Wt.takeWhile = Hi, Wt.tap = oo, Wt.throttle = Ko, Wt.thru = fo, Wt.toArray = Ff, Wt.toPairs = $s, Wt.toPairsIn = zs, Wt.toPath = cc, Wt.toPlainObject = qf, Wt.transform = pa, Wt.unary = Go, Wt.union = ql, Wt.unionBy = Tl, Wt.unionWith = Zl, Wt.uniq = Qi, Wt.uniqBy = Xi, Wt.uniqWith = no, Wt.unset = va, Wt.unzip = to, Wt.unzipWith = ro, Wt.update = _a, Wt.updateWith = ga, Wt.values = ya, Wt.valuesIn = da, Wt.without = Vl, Wt.words = qa, Wt.wrap = Jo, Wt.xor = Kl, Wt.xorBy = Gl, Wt.xorWith = Jl, Wt.zip = Yl, Wt.zipObject = eo, Wt.zipObjectDeep = uo, Wt.zipWith = Hl, Wt.entries = $s, Wt.entriesIn = zs, Wt.extend = xs, Wt.extendWith = js, Ha(Wt, Wt), Wt.add = rh, Wt.attempt = Zs, Wt.camelCase = Us, Wt.capitalize = xa, Wt.ceil = eh, Wt.clamp = ba, Wt.clone = Ho, Wt.cloneDeep = Xo, Wt.cloneDeepWith = nf, Wt.cloneWith = Qo, Wt.deburr = ja, Wt.divide = uh, Wt.endsWith = Aa, Wt.eq = tf, Wt.escape = Oa, Wt.escapeRegExp = ka, Wt.every = _o, Wt.find = ns, Wt.findIndex = wi, Wt.findKey = Kf, Wt.findLast = ts, Wt.findLastIndex = mi, Wt.findLastKey = Gf, Wt.floor = ih, Wt.forEach = mo, Wt.forEachRight = xo, Wt.forIn = Jf, Wt.forInRight = Yf, Wt.forOwn = Hf, Wt.forOwnRight = Qf, Wt.get = ta, Wt.gt = _s, Wt.gte = gs, Wt.has = ra, Wt.hasIn = ea, Wt.head = ki, Wt.identity = Ka, Wt.includes = jo, Wt.indexOf = Ii, Wt.inRange = wa, Wt.invoke = Ss, Wt.isArguments = rf, Wt.isArray = ys, Wt.isArrayBuffer = ef, Wt.isArrayLike = uf, Wt.isArrayLikeObject = of, Wt.isBoolean = ff, Wt.isBuffer = ds, Wt.isDate = af, Wt.isElement = cf, Wt.isEmpty = lf, Wt.isEqual = sf, Wt.isEqualWith = hf, Wt.isError = pf, Wt.isFinite = vf, Wt.isFunction = _f, Wt.isInteger = gf, Wt.isLength = yf, Wt.isMap = wf, Wt.isMatch = mf, Wt.isMatchWith = xf, Wt.isNaN = jf, Wt.isNative = Af, Wt.isNil = kf, Wt.isNull = Of, Wt.isNumber = If, Wt.isObject = df, Wt.isObjectLike = bf, Wt.isPlainObject = Rf, Wt.isRegExp = Ef, Wt.isSafeInteger = Sf, Wt.isSet = Wf, Wt.isString = Lf, Wt.isSymbol = Cf, Wt.isTypedArray = Bf, Wt.isUndefined = $f, Wt.isWeakMap = zf, Wt.isWeakSet = Uf, Wt.join = Ei, Wt.kebabCase = Fs, Wt.last = Si, Wt.lastIndexOf = Wi, Wt.lowerCase = Ms, Wt.lowerFirst = Ds, Wt.lt = bs, Wt.lte = ws, Wt.max = sc, Wt.maxBy = hc, Wt.mean = pc, Wt.meanBy = vc, Wt.min = _c, Wt.minBy = gc, Wt.stubArray = ec, Wt.stubFalse = uc, Wt.stubObject = ic, Wt.stubString = oc, Wt.stubTrue = fc, Wt.multiply = oh, Wt.nth = Li, Wt.noConflict = Qa, Wt.noop = Xa, Wt.now = Bo, Wt.pad = Ia, Wt.padEnd = Ra, Wt.padStart = Ea, Wt.parseInt = Sa, Wt.random = ma, Wt.reduce = ko, Wt.reduceRight = Io, Wt.repeat = Wa, Wt.replace = La, Wt.result = la, Wt.round = fh, Wt.runInContext = V, Wt.sample = Eo, Wt.size = Lo, Wt.snakeCase = Ps, Wt.some = Co, Wt.sortedIndex = Mi, Wt.sortedIndexBy = Di, Wt.sortedIndexOf = Pi, Wt.sortedLastIndex = Ni, Wt.sortedLastIndexBy = qi, Wt.sortedLastIndexOf = Ti, Wt.startCase = Ns, Wt.startsWith = Ba, Wt.subtract = ah, Wt.sum = yc, Wt.sumBy = dc, Wt.template = $a, Wt.times = ac, Wt.toFinite = Mf, Wt.toInteger = Df, Wt.toLength = Pf, Wt.toLower = za, Wt.toNumber = Nf, Wt.toSafeInteger = Tf, Wt.toString = Zf, Wt.toUpper = Ua, Wt.trim = Fa, Wt.trimEnd = Ma, Wt.trimStart = Da, Wt.truncate = Pa, Wt.unescape = Na, Wt.uniqueId = lc, Wt.upperCase = qs, Wt.upperFirst = Ts, Wt.each = mo, Wt.eachRight = xo, Wt.first = ki, Ha(Wt, function () { var n = {}; return qr(Wt, function (t, r) { Sc.call(Wt.prototype, r) || (n[r] = t) }), n }(), { chain: !1 }), Wt.VERSION = G, u(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (n) { Wt[n].placeholder = Wt }), u(["drop", "take"], function (n, t) { Bt.prototype[n] = function (r) { var e = this.__filtered__; if (e && !t) return new Bt(this); r = r === K ? 1 : Xc(Df(r), 0); var u = this.clone(); return e ? u.__takeCount__ = nl(r, u.__takeCount__) : u.__views__.push({ size: nl(r, jn), type: n + (u.__dir__ < 0 ? "Right" : "") }), u }, Bt.prototype[n + "Right"] = function (t) { return this.reverse()[n](t).reverse() } }), u(["filter", "map", "takeWhile"], function (n, t) { var r = t + 1, e = r == gn || r == dn; Bt.prototype[n] = function (n) { var t = this.clone(); return t.__iteratees__.push({ iteratee: $u(n, 3), type: r }), t.__filtered__ = t.__filtered__ || e, t } }), u(["head", "last"], function (n, t) { var r = "take" + (t ? "Right" : ""); Bt.prototype[n] = function () { return this[r](1).value()[0] } }), u(["initial", "tail"], function (n, t) { var r = "drop" + (t ? "" : "Right"); Bt.prototype[n] = function () { return this.__filtered__ ? new Bt(this) : this[r](1) } }), Bt.prototype.compact = function () { return this.filter(Ka) }, Bt.prototype.find = function (n) { return this.filter(n).head() }, Bt.prototype.findLast = function (n) { return this.reverse().find(n) }, Bt.prototype.invokeMap = Zo(function (n, t) { return "function" == typeof n ? new Bt(this) : this.map(function (r) { return ne(r, n, t) }) }), Bt.prototype.reject = function (n) { return n = $u(n, 3), this.filter(function (t) { return !n(t) }) }, Bt.prototype.slice = function (n, t) { n = Df(n); var r = this; return r.__filtered__ && (n > 0 || 0 > t) ? new Bt(r) : (0 > n ? r = r.takeRight(-n) : n && (r = r.drop(n)), t !== K && (t = Df(t), r = 0 > t ? r.dropRight(-t) : r.take(t - n)), r) }, Bt.prototype.takeRightWhile = function (n) { return this.reverse().takeWhile(n).reverse() }, Bt.prototype.toArray = function () { return this.take(jn) }, qr(Bt.prototype, function (n, t) { var r = /^(?:filter|find|map|reject)|While$/.test(t), e = /^(?:head|last)$/.test(t), u = Wt[e ? "take" + ("last" == t ? "Right" : "") : t], i = e || /^find/.test(t); u && (Wt.prototype[t] = function () { var t = this.__wrapped__, o = e ? [1] : arguments, f = t instanceof Bt, a = o[0], c = f || ys(t), l = function (n) { var t = u.apply(Wt, s([n], o)); return e && h ? t[0] : t }; c && r && "function" == typeof a && 1 != a.length && (f = c = !1); var h = this.__chain__, p = !!this.__actions__.length, v = i && !h, _ = f && !p; if (!i && c) { t = _ ? t : new Bt(this); var g = n.apply(t, o); return g.__actions__.push({ func: fo, args: [l], thisArg: K }), new Ct(g, h) } return v && _ ? n.apply(this, o) : (g = this.thru(l), v ? e ? g.value()[0] : g.value() : g) }) }), u(["pop", "push", "shift", "sort", "splice", "unshift"], function (n) { var t = Ac[n], r = /^(?:push|sort|unshift)$/.test(n) ? "tap" : "thru", e = /^(?:pop|shift)$/.test(n); Wt.prototype[n] = function () { var n = arguments; if (e && !this.__chain__) { var u = this.value(); return t.apply(ys(u) ? u : [], n) } return this[r](function (r) { return t.apply(ys(r) ? r : [], n) }) } }), qr(Bt.prototype, function (n, t) { var r = Wt[t]; if (r) { var e = r.name + "", u = vl[e] || (vl[e] = []); u.push({ name: t, func: r }) } }), vl[gu(K, nn).name] = [{ name: "wrapper", func: K }], Bt.prototype.clone = $t, Bt.prototype.reverse = zt, Bt.prototype.value = Ut, Wt.prototype.at = Ql, Wt.prototype.chain = ao, Wt.prototype.commit = co, Wt.prototype.next = lo, Wt.prototype.plant = ho, Wt.prototype.reverse = po, Wt.prototype.toJSON = Wt.prototype.valueOf = Wt.prototype.value = vo, Nc && (Wt.prototype[Nc] = so), Wt
    } var K, G = "4.13.1", J = 200, Y = "Expected a function", H = "__lodash_hash_undefined__", Q = "__lodash_placeholder__", X = 1, nn = 2, tn = 4, rn = 8, en = 16, un = 32, on = 64, fn = 128, an = 256, cn = 512, ln = 1, sn = 2, hn = 30, pn = "...", vn = 150, _n = 16, gn = 1, yn = 2, dn = 3, bn = 1 / 0, wn = 9007199254740991, mn = 1.7976931348623157e308, xn = NaN, jn = 4294967295, An = jn - 1, On = jn >>> 1, kn = "[object Arguments]", In = "[object Array]", Rn = "[object Boolean]", En = "[object Date]", Sn = "[object Error]", Wn = "[object Function]", Ln = "[object GeneratorFunction]", Cn = "[object Map]", Bn = "[object Number]", $n = "[object Object]", zn = "[object Promise]", Un = "[object RegExp]", Fn = "[object Set]", Mn = "[object String]", Dn = "[object Symbol]", Pn = "[object WeakMap]", Nn = "[object WeakSet]", qn = "[object ArrayBuffer]", Tn = "[object DataView]", Zn = "[object Float32Array]", Vn = "[object Float64Array]", Kn = "[object Int8Array]", Gn = "[object Int16Array]", Jn = "[object Int32Array]", Yn = "[object Uint8Array]", Hn = "[object Uint8ClampedArray]", Qn = "[object Uint16Array]", Xn = "[object Uint32Array]", nt = /\b__p \+= '';/g, tt = /\b(__p \+=) '' \+/g, rt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, et = /&(?:amp|lt|gt|quot|#39|#96);/g, ut = /[&<>"'`]/g, it = RegExp(et.source), ot = RegExp(ut.source), ft = /<%-([\s\S]+?)%>/g, at = /<%([\s\S]+?)%>/g, ct = /<%=([\s\S]+?)%>/g, lt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, st = /^\w*$/, ht = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(\.|\[\])(?:\4|$))/g, pt = /[\\^$.*+?()[\]{}|]/g, vt = RegExp(pt.source), _t = /^\s+|\s+$/g, gt = /^\s+/, yt = /\s+$/, dt = /[a-zA-Z0-9]+/g, bt = /\\(\\)?/g, wt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, mt = /\w*$/, xt = /^0x/i, jt = /^[-+]0x[0-9a-f]+$/i, At = /^0b[01]+$/i, Ot = /^\[object .+?Constructor\]$/, kt = /^0o[0-7]+$/i, It = /^(?:0|[1-9]\d*)$/, Rt = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g, Et = /($^)/, St = /['\n\r\u2028\u2029\\]/g, Wt = "\\ud800-\\udfff", Lt = "\\u0300-\\u036f\\ufe20-\\ufe23", Ct = "\\u20d0-\\u20f0", Bt = "\\u2700-\\u27bf", $t = "a-z\\xdf-\\xf6\\xf8-\\xff", zt = "\\xac\\xb1\\xd7\\xf7", Ut = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ft = "\\u2000-\\u206f", Mt = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Dt = "A-Z\\xc0-\\xd6\\xd8-\\xde", Pt = "\\ufe0e\\ufe0f", Nt = zt + Ut + Ft + Mt, qt = "['’]", Tt = "[" + Wt + "]", Zt = "[" + Nt + "]", Vt = "[" + Lt + Ct + "]", Kt = "\\d+", Gt = "[" + Bt + "]", Jt = "[" + $t + "]", Yt = "[^" + Wt + Nt + Kt + Bt + $t + Dt + "]", Ht = "\\ud83c[\\udffb-\\udfff]", Qt = "(?:" + Vt + "|" + Ht + ")", Xt = "[^" + Wt + "]", nr = "(?:\\ud83c[\\udde6-\\uddff]){2}", tr = "[\\ud800-\\udbff][\\udc00-\\udfff]", rr = "[" + Dt + "]", er = "\\u200d", ur = "(?:" + Jt + "|" + Yt + ")", ir = "(?:" + rr + "|" + Yt + ")", or = "(?:" + qt + "(?:d|ll|m|re|s|t|ve))?", fr = "(?:" + qt + "(?:D|LL|M|RE|S|T|VE))?", ar = Qt + "?", cr = "[" + Pt + "]?", lr = "(?:" + er + "(?:" + [Xt, nr, tr].join("|") + ")" + cr + ar + ")*", sr = cr + ar + lr, hr = "(?:" + [Gt, nr, tr].join("|") + ")" + sr, pr = "(?:" + [Xt + Vt + "?", Vt, nr, tr, Tt].join("|") + ")", vr = RegExp(qt, "g"), _r = RegExp(Vt, "g"), gr = RegExp(Ht + "(?=" + Ht + ")|" + pr + sr, "g"), yr = RegExp([rr + "?" + Jt + "+" + or + "(?=" + [Zt, rr, "$"].join("|") + ")", ir + "+" + fr + "(?=" + [Zt, rr + ur, "$"].join("|") + ")", rr + "?" + ur + "+" + or, rr + "+" + fr, Kt, hr].join("|"), "g"), dr = RegExp("[" + er + Wt + Lt + Ct + Pt + "]"), br = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, wr = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "Reflect", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "isFinite", "parseInt", "setTimeout"], mr = -1, xr = {};
    xr[Zn] = xr[Vn] = xr[Kn] = xr[Gn] = xr[Jn] = xr[Yn] = xr[Hn] = xr[Qn] = xr[Xn] = !0, xr[kn] = xr[In] = xr[qn] = xr[Rn] = xr[Tn] = xr[En] = xr[Sn] = xr[Wn] = xr[Cn] = xr[Bn] = xr[$n] = xr[Un] = xr[Fn] = xr[Mn] = xr[Pn] = !1; var jr = {}; jr[kn] = jr[In] = jr[qn] = jr[Tn] = jr[Rn] = jr[En] = jr[Zn] = jr[Vn] = jr[Kn] = jr[Gn] = jr[Jn] = jr[Cn] = jr[Bn] = jr[$n] = jr[Un] = jr[Fn] = jr[Mn] = jr[Dn] = jr[Yn] = jr[Hn] = jr[Qn] = jr[Xn] = !0, jr[Sn] = jr[Wn] = jr[Pn] = !1; var Ar = { "À": "A", "Á": "A", "Â": "A", "Ã": "A", "Ä": "A", "Å": "A", "à": "a", "á": "a", "â": "a", "ã": "a", "ä": "a", "å": "a", "Ç": "C", "ç": "c", "Ð": "D", "ð": "d", "È": "E", "É": "E", "Ê": "E", "Ë": "E", "è": "e", "é": "e", "ê": "e", "ë": "e", "Ì": "I", "Í": "I", "Î": "I", "Ï": "I", "ì": "i", "í": "i", "î": "i", "ï": "i", "Ñ": "N", "ñ": "n", "Ò": "O", "Ó": "O", "Ô": "O", "Õ": "O", "Ö": "O", "Ø": "O", "ò": "o", "ó": "o", "ô": "o", "õ": "o", "ö": "o", "ø": "o", "Ù": "U", "Ú": "U", "Û": "U", "Ü": "U", "ù": "u", "ú": "u", "û": "u", "ü": "u", "Ý": "Y", "ý": "y", "ÿ": "y", "Æ": "Ae", "æ": "ae", "Þ": "Th", "þ": "th", "ß": "ss" }, Or = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "`": "&#96;" }, kr = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'", "&#96;": "`" }, Ir = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Rr = parseFloat, Er = parseInt, Sr = "object" == typeof exports && exports, Wr = Sr && "object" == typeof module && module, Lr = Wr && Wr.exports === Sr, Cr = S("object" == typeof global && global), Br = S("object" == typeof self && self), $r = S("object" == typeof this && this), zr = Cr || Br || $r || Function("return this")(), Ur = V(); (Br || {})._ = Ur, "function" == typeof define && "object" == typeof define.amd && define.amd ? define(function () { return Ur }) : Wr ? ((Wr.exports = Ur)._ = Ur, Sr._ = Ur) : zr._ = Ur
}).call(this);
//# sourceMappingURL=lodash.min.js.map

if ("undefined" == typeof net) { var net = {} } if (!net.brehaut) { net.brehaut = {} } (function () { "use strict"; function p(e, t) { e = e.toString(); var n = []; for (var r = 0, i = Math.max(t - e.length, 0); r < i; r++) { n.push("0") } n.push(e); return n.join("") } function d(e) { return e.slice(0, 1).toUpperCase() + e.slice(1) } function v(e) { return e.replace(/^\s+|\s+$/g, "") } function m(e) { return function () { var t = this.clone(); e.apply(t, arguments); return t } } function g(e, t) { function s(e) { return function () { return e.apply(this[i](), arguments) } } function v() { } function m() { return new v } var n = h(f); var r = []; var i = "to" + d(e); for (var o in t) if (t.hasOwnProperty(o)) { n[o] = t[o]; var u = n[o]; if (o.slice(0, 1) == "_") { continue } if (!(o in f) && "function" == typeof u) { f[o] = s(u) } else if ("function" != typeof u) { r.push(o); var a = "get" + d(o); var p = "set" + d(o); f[a] = s(n[a] = function (e) { return function () { return this[e] } }(o)); f[p] = s(n[p] = function (e) { return function (t) { var n = this.clone(); n[e] = t; return n } }(o)) } } v.prototype = n; c[e] = m; n.clone = function () { var e = m(); for (var t = 0, n = r.length; t < n; t++) { var i = r[t]; e[i] = this[i] } return e }; f[i] = function () { return m() }; l.push(n); return n } function b(e) { return f.fromObject(e) } var e = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#00FFFF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blue: "#0000FF", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#FF00FF", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#00FF00", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370D8", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#D87093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", red: "#FF0000", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFFFFF", whitesmoke: "#F5F5F5", yellow: "#FFFF00", yellowgreen: '#9ACD32"' }; var t = "(?:\\+|-)?\\d+"; var n = "(?:\\+|-)?\\d*\\.\\d+"; var r = "(?:" + t + ")|(?:" + n + ")"; t = "(" + t + ")"; n = "(" + n + ")"; r = "(" + r + ")"; var i = r + "%"; var s = "\\s*?"; var o = new RegExp(["^hsl(a?)\\(", r, ",", i, ",", i, "(,(", r, "))?\\)$"].join(s)); var u = new RegExp(["^rgb(a?)\\(", t, ",", t, ",", t, "(,(", r, "))?\\)$"].join(s)); var a = new RegExp(["^rgb(a?)\\(", i, ",", i, ",", i, "(,(", r, "))?\\)$"].join(s)); var f; var l = []; var c = {}; if (!this.object) { this.object = function (e) { function t() { } t.prototype = e; return new t } } var h = this.object; f = { fromObject: function (e) { if (!e) { return h(f) } for (var t = 0, n = l.length; t < n; t++) { var r = l[t].fromObject(e); if (r) { return r } } return h(f) }, toString: function () { return this.toCSS() } }; var y = null; g("RGB", { red: 0, green: 0, blue: 0, alpha: 0, getLuminance: function () { return this.red * .2126 + this.green * .7152 + this.blue * .0722 }, blend: function (e, t) { e = e.toRGB(); t = Math.min(Math.max(t, 0), 1); var n = this.clone(); n.red = n.red * (1 - t) + e.red * t; n.green = n.green * (1 - t) + e.green * t; n.blue = n.blue * (1 - t) + e.blue * t; n.alpha = n.alpha * (1 - t) + e.alpha * t; return n }, fromObject: function (e) { if (e instanceof Array) { return this._fromRGBArray(e) } if ("string" == typeof e) { return this._fromCSS(v(e)) } if (e.hasOwnProperty("red") && e.hasOwnProperty("green") && e.hasOwnProperty("blue")) { return this._fromRGB(e) } }, _stringParsers: [function (e) { function n(t, n) { var r = e.match(t); if (!r || !!r[1] + !!r[5] === 1) { return null } var i = c.RGB(); i.red = Math.min(1, Math.max(0, r[2] / n)); i.green = Math.min(1, Math.max(0, r[3] / n)); i.blue = Math.min(1, Math.max(0, r[4] / n)); i.alpha = !!r[5] ? Math.min(Math.max(parseFloat(r[6]), 0), 1) : 1; return i } e = v(e); var t = n(u, 255); if (t) { return t } return n(a, 100) }, function (t) { var n = t.toLowerCase(); if (n in e) { t = e[n] } if (!t.match(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/)) { return } t = t.replace(/^#/, ""); var r = t.length / 3; var i = Math.pow(16, r) - 1; var s = c.RGB(); s.red = parseInt(t.slice(0, r), 16) / i; s.green = parseInt(t.slice(r * 1, r * 2), 16) / i; s.blue = parseInt(t.slice(r * 2), 16) / i; s.alpha = 1; return s }, function (e) { if (e.toLowerCase() !== "transparent") return; return y }], _fromCSS: function (e) { var t = null; for (var n = 0, r = this._stringParsers.length; n < r; n++) { t = this._stringParsers[n](e); if (t) return t } }, _fromRGB: function (e) { var t = c.RGB(); t.red = e.red; t.green = e.green; t.blue = e.blue; t.alpha = e.hasOwnProperty("alpha") ? e.alpha : 1; return t }, _fromRGBArray: function (e) { var t = c.RGB(); t.red = Math.max(0, Math.min(1, e[0] / 255)); t.green = Math.max(0, Math.min(1, e[1] / 255)); t.blue = Math.max(0, Math.min(1, e[2] / 255)); t.alpha = e[3] !== undefined ? Math.max(0, Math.min(1, e[3])) : 1; return t }, toCSSHex: function (e) { e = e || 2; var t = Math.pow(16, e) - 1; var n = ["#", p(Math.round(this.red * t).toString(16).toUpperCase(), e), p(Math.round(this.green * t).toString(16).toUpperCase(), e), p(Math.round(this.blue * t).toString(16).toUpperCase(), e)]; return n.join("") }, toCSS: function (e) { if (this.alpha === 1) return this.toCSSHex(e); var t = 255; var n = ["rgba(", Math.max(0, Math.min(t, Math.round(this.red * t))), ",", Math.max(0, Math.min(t, Math.round(this.green * t))), ",", Math.max(0, Math.min(t, Math.round(this.blue * t))), ",", Math.max(0, Math.min(1, this.alpha)), ")"]; return n.join("") }, toHSV: function () { var e = c.HSV(); var t, n, r; t = Math.min(this.red, this.green, this.blue); n = Math.max(this.red, this.green, this.blue); e.value = n; r = n - t; if (r == 0) { e.hue = e.saturation = 0 } else { e.saturation = r / n; if (this.red == n) { e.hue = (this.green - this.blue) / r } else if (this.green == n) { e.hue = 2 + (this.blue - this.red) / r } else { e.hue = 4 + (this.red - this.green) / r } e.hue = (e.hue * 60 + 360) % 360 } e.alpha = this.alpha; return e }, toHSL: function () { return this.toHSV().toHSL() }, toRGB: function () { return this.clone() } }); y = f.fromObject({ red: 0, blue: 0, green: 0, alpha: 0 }); g("HSV", { hue: 0, saturation: 0, value: 1, alpha: 1, shiftHue: m(function (e) { var t = (this.hue + e) % 360; if (t < 0) { t = (360 + t) % 360 } this.hue = t }), devalueByAmount: m(function (e) { this.value = Math.min(1, Math.max(this.value - e, 0)) }), devalueByRatio: m(function (e) { this.value = Math.min(1, Math.max(this.value * (1 - e), 0)) }), valueByAmount: m(function (e) { this.value = Math.min(1, Math.max(this.value + e, 0)) }), valueByRatio: m(function (e) { this.value = Math.min(1, Math.max(this.value * (1 + e), 0)) }), desaturateByAmount: m(function (e) { this.saturation = Math.min(1, Math.max(this.saturation - e, 0)) }), desaturateByRatio: m(function (e) { this.saturation = Math.min(1, Math.max(this.saturation * (1 - e), 0)) }), saturateByAmount: m(function (e) { this.saturation = Math.min(1, Math.max(this.saturation + e, 0)) }), saturateByRatio: m(function (e) { this.saturation = Math.min(1, Math.max(this.saturation * (1 + e), 0)) }), schemeFromDegrees: function (e) { var t = []; for (var n = 0, r = e.length; n < r; n++) { var i = this.clone(); i.hue = (this.hue + e[n]) % 360; t.push(i) } return t }, complementaryScheme: function () { return this.schemeFromDegrees([0, 180]) }, splitComplementaryScheme: function () { return this.schemeFromDegrees([0, 150, 320]) }, splitComplementaryCWScheme: function () { return this.schemeFromDegrees([0, 150, 300]) }, splitComplementaryCCWScheme: function () { return this.schemeFromDegrees([0, 60, 210]) }, triadicScheme: function () { return this.schemeFromDegrees([0, 120, 240]) }, clashScheme: function () { return this.schemeFromDegrees([0, 90, 270]) }, tetradicScheme: function () { return this.schemeFromDegrees([0, 90, 180, 270]) }, fourToneCWScheme: function () { return this.schemeFromDegrees([0, 60, 180, 240]) }, fourToneCCWScheme: function () { return this.schemeFromDegrees([0, 120, 180, 300]) }, fiveToneAScheme: function () { return this.schemeFromDegrees([0, 115, 155, 205, 245]) }, fiveToneBScheme: function () { return this.schemeFromDegrees([0, 40, 90, 130, 245]) }, fiveToneCScheme: function () { return this.schemeFromDegrees([0, 50, 90, 205, 320]) }, fiveToneDScheme: function () { return this.schemeFromDegrees([0, 40, 155, 270, 310]) }, fiveToneEScheme: function () { return this.schemeFromDegrees([0, 115, 230, 270, 320]) }, sixToneCWScheme: function () { return this.schemeFromDegrees([0, 30, 120, 150, 240, 270]) }, sixToneCCWScheme: function () { return this.schemeFromDegrees([0, 90, 120, 210, 240, 330]) }, neutralScheme: function () { return this.schemeFromDegrees([0, 15, 30, 45, 60, 75]) }, analogousScheme: function () { return this.schemeFromDegrees([0, 30, 60, 90, 120, 150]) }, fromObject: function (e) { if (e.hasOwnProperty("hue") && e.hasOwnProperty("saturation") && e.hasOwnProperty("value")) { var t = c.HSV(); t.hue = e.hue; t.saturation = e.saturation; t.value = e.value; t.alpha = e.hasOwnProperty("alpha") ? e.alpha : 1; return t } return null }, _normalise: function () { this.hue %= 360; this.saturation = Math.min(Math.max(0, this.saturation), 1); this.value = Math.min(Math.max(0, this.value)); this.alpha = Math.min(1, Math.max(0, this.alpha)) }, toRGB: function () { this._normalise(); var e = c.RGB(); var t; var n, r, i, s; if (this.saturation === 0) { e.red = this.value; e.green = this.value; e.blue = this.value; e.alpha = this.alpha; return e } var o = this.hue / 60; t = Math.floor(o); n = o - t; r = this.value * (1 - this.saturation); i = this.value * (1 - this.saturation * n); s = this.value * (1 - this.saturation * (1 - n)); switch (t) { case 0: e.red = this.value; e.green = s; e.blue = r; break; case 1: e.red = i; e.green = this.value; e.blue = r; break; case 2: e.red = r; e.green = this.value; e.blue = s; break; case 3: e.red = r; e.green = i; e.blue = this.value; break; case 4: e.red = s; e.green = r; e.blue = this.value; break; default: e.red = this.value; e.green = r; e.blue = i; break }e.alpha = this.alpha; return e }, toHSL: function () { this._normalise(); var e = c.HSL(); e.hue = this.hue; var t = (2 - this.saturation) * this.value, n = this.saturation * this.value; if (t && 2 - t) { n /= t <= 1 ? t : 2 - t } t /= 2; e.saturation = n; e.lightness = t; e.alpha = this.alpha; return e }, toHSV: function () { return this.clone() } }); g("HSL", { hue: 0, saturation: 0, lightness: 0, alpha: 1, darkenByAmount: m(function (e) { this.lightness = Math.min(1, Math.max(this.lightness - e, 0)) }), darkenByRatio: m(function (e) { this.lightness = Math.min(1, Math.max(this.lightness * (1 - e), 0)) }), lightenByAmount: m(function (e) { this.lightness = Math.min(1, Math.max(this.lightness + e, 0)) }), lightenByRatio: m(function (e) { this.lightness = Math.min(1, Math.max(this.lightness * (1 + e), 0)) }), fromObject: function (e) { if ("string" == typeof e) { return this._fromCSS(e) } if (e.hasOwnProperty("hue") && e.hasOwnProperty("saturation") && e.hasOwnProperty("lightness")) { return this._fromHSL(e) } }, _fromCSS: function (e) { var t = v(e).match(o); if (!t || !!t[1] + !!t[5] === 1) { return null } var n = c.HSL(); n.hue = (t[2] % 360 + 360) % 360; n.saturation = Math.max(0, Math.min(parseInt(t[3], 10) / 100, 1)); n.lightness = Math.max(0, Math.min(parseInt(t[4], 10) / 100, 1)); n.alpha = !!t[5] ? Math.max(0, Math.min(1, parseFloat(t[6]))) : 1; return n }, _fromHSL: function (e) { var t = c.HSL(); t.hue = e.hue; t.saturation = e.saturation; t.lightness = e.lightness; t.alpha = e.hasOwnProperty("alpha") ? e.alpha : 1; return t }, _normalise: function () { this.hue = (this.hue % 360 + 360) % 360; this.saturation = Math.min(Math.max(0, this.saturation), 1); this.lightness = Math.min(Math.max(0, this.lightness)); this.alpha = Math.min(1, Math.max(0, this.alpha)) }, toHSL: function () { return this.clone() }, toHSV: function () { this._normalise(); var e = c.HSV(); e.hue = this.hue; var t = 2 * this.lightness, n = this.saturation * (t <= 1 ? t : 2 - t); e.value = (t + n) / 2; e.saturation = 2 * n / (t + n) || 0; e.alpha = this.alpha; return e }, toRGB: function () { return this.toHSV().toRGB() } }); b.isValid = function (e) { var t, n = b(e); var r = 0; for (t in n) { if (n.hasOwnProperty(t)) { r++ } } return r > 0 }; net.brehaut.Color = b }).call(net.brehaut);
//     (c) 2012 Airbnb, Inc.
//
//     polyglot.js may be freely distributed under the terms of the BSD
//     license. For all licensing information, details, and documention:
//     http://airbnb.github.com/polyglot.js
//
//
// Polyglot.js is an I18n helper library written in JavaScript, made to
// work both in the browser and in Node. It provides a simple solution for
// interpolation and pluralization, based off of Airbnb's
// experience adding I18n functionality to its Backbone.js and Node apps.
//
// Polylglot is agnostic to your translation backend. It doesn't perform any
// translation; it simply gives you a way to manage translated phrases from
// your client- or server-side JavaScript application.
//
(function (e, t) { typeof define == "function" && define.amd ? define([], function () { return t(e) }) : typeof exports == "object" ? module.exports = t(e) : e.Polyglot = t(e) })(this, function (e) { "use strict"; function t(e) { e = e || {}, this.phrases = {}, this.extend(e.phrases || {}), this.currentLocale = e.locale || "en", this.allowMissing = !!e.allowMissing, this.warn = e.warn || c } function s(e) { var t, n, r, i = {}; for (t in e) if (e.hasOwnProperty(t)) { n = e[t]; for (r in n) i[n[r]] = t } return i } function o(e) { var t = /^\s+|\s+$/g; return e.replace(t, "") } function u(e, t, r) { var i, s, u; return r != null && e ? (s = e.split(n), u = s[f(t, r)] || s[0], i = o(u)) : i = e, i } function a(e) { var t = s(i); return t[e] || t.en } function f(e, t) { return r[a(e)](t) } function l(e, t) { for (var n in t) n !== "_" && t.hasOwnProperty(n) && (e = e.replace(new RegExp("%\\{" + n + "\\}", "g"), t[n])); return e } function c(t) { e.console && e.console.warn && e.console.warn("WARNING: " + t) } function h(e) { var t = {}; for (var n in e) t[n] = e[n]; return t } t.VERSION = "0.4.3", t.prototype.locale = function (e) { return e && (this.currentLocale = e), this.currentLocale }, t.prototype.extend = function (e, t) { var n; for (var r in e) e.hasOwnProperty(r) && (n = e[r], t && (r = t + "." + r), typeof n == "object" ? this.extend(n, r) : this.phrases[r] = n) }, t.prototype.clear = function () { this.phrases = {} }, t.prototype.replace = function (e) { this.clear(), this.extend(e) }, t.prototype.t = function (e, t) { var n, r; return t = t == null ? {} : t, typeof t == "number" && (t = { smart_count: t }), typeof this.phrases[e] == "string" ? n = this.phrases[e] : typeof t._ == "string" ? n = t._ : this.allowMissing ? n = e : (this.warn('Missing translation for key: "' + e + '"'), r = e), typeof n == "string" && (t = h(t), r = u(n, this.currentLocale, t.smart_count), r = l(r, t)), r }, t.prototype.has = function (e) { return e in this.phrases }; var n = "||||", r = { chinese: function (e) { return 0 }, german: function (e) { return e !== 1 ? 1 : 0 }, french: function (e) { return e > 1 ? 1 : 0 }, russian: function (e) { return e % 10 === 1 && e % 100 !== 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2 }, czech: function (e) { return e === 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2 }, polish: function (e) { return e === 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2 }, icelandic: function (e) { return e % 10 !== 1 || e % 100 === 11 ? 1 : 0 } }, i = { chinese: ["fa", "id", "ja", "ko", "lo", "ms", "th", "tr", "zh"], german: ["da", "de", "en", "es", "fi", "el", "he", "hu", "it", "nl", "no", "pt", "sv"], french: ["fr", "tl", "pt-br"], russian: ["hr", "ru"], czech: ["cs"], polish: ["pl"], icelandic: ["is"] }; return t });
/*****************************************************************************
 *                                                                            *
 *  SVG Path Rounding Function                                                *
 *  Copyright (C) 2014 Yona Appletree                                         *
 *                                                                            *
 *  Licensed under the Apache License, Version 2.0 (the "License");           *
 *  you may not use this file except in compliance with the License.          *
 *  You may obtain a copy of the License at                                   *
 *                                                                            *
 *      http://www.apache.org/licenses/LICENSE-2.0                            *
 *                                                                            *
 *  Unless required by applicable law or agreed to in writing, software       *
 *  distributed under the License is distributed on an "AS IS" BASIS,         *
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *
 *  See the License for the specific language governing permissions and       *
 *  limitations under the License.                                            *
 *                                                                            *
 *****************************************************************************/

/**
 * SVG Path rounding function. Takes an input path string and outputs a path
 * string where all line-line corners have been rounded. Only supports absolute
 * commands at the moment.
 *
 * @param pathString The SVG input path
 * @param radius The amount to round the corners, either a value in the SVG
 *               coordinate space, or, if useFractionalRadius is true, a value
 *               from 0 to 1.
 * @param useFractionalRadius If true, the curve radius is expressed as a
 *               fraction of the distance between the point being curved and
 *               the previous and next points.
 * @returns A new SVG path string with the rounding
 */
function roundPathCorners(pathString, radius, useFractionalRadius) {
    function moveTowardsLength(movingPoint, targetPoint, amount) {
        var width = (targetPoint.x - movingPoint.x);
        var height = (targetPoint.y - movingPoint.y);

        var distance = Math.sqrt(width * width + height * height);

        return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance));
    }
    function moveTowardsFractional(movingPoint, targetPoint, fraction) {
        return {
            x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,
            y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction
        };
    }

    // Adjusts the ending position of a command
    function adjustCommand(cmd, newPoint) {
        if (cmd.length > 2) {
            cmd[cmd.length - 2] = newPoint.x;
            cmd[cmd.length - 1] = newPoint.y;
        }
    }

    // Gives an {x, y} object for a command's ending position
    function pointForCommand(cmd) {
        return {
            x: parseFloat(cmd[cmd.length - 2]),
            y: parseFloat(cmd[cmd.length - 1])
        };
    }

    // Split apart the path, handing concatonated letters and numbers
    var pathParts = pathString
        .split(/[,\s]/)
        .reduce(function (parts, part) {
            var match = part.match("([a-zA-Z])(.+)");
            if (match) {
                parts.push(match[1]);
                parts.push(match[2]);
            } else {
                parts.push(part);
            }

            return parts;
        }, []);

    // Group the commands with their arguments for easier handling
    var commands = pathParts.reduce(function (commands, part) {
        if (parseFloat(part) == part && commands.length) {
            commands[commands.length - 1].push(part);
        } else {
            commands.push([part]);
        }

        return commands;
    }, []);

    // The resulting commands, also grouped
    var resultCommands = [];

    if (commands.length > 1) {
        var startPoint = pointForCommand(commands[0]);

        // Handle the close path case with a "virtual" closing line
        var virtualCloseLine = null;
        if (commands[commands.length - 1][0] == "Z" && commands[0].length > 2) {
            virtualCloseLine = ["L", startPoint.x, startPoint.y];
            commands[commands.length - 1] = virtualCloseLine;
        }

        // We always use the first command (but it may be mutated)
        resultCommands.push(commands[0]);

        for (var cmdIndex = 1; cmdIndex < commands.length; cmdIndex++) {
            var prevCmd = resultCommands[resultCommands.length - 1];

            var curCmd = commands[cmdIndex];

            // Handle closing case
            var nextCmd = (curCmd == virtualCloseLine)
                ? commands[1]
                : commands[cmdIndex + 1];

            // Nasty logic to decide if this path is a candidite.
            if (nextCmd && prevCmd && (prevCmd.length > 2) && curCmd[0] == "L" && nextCmd.length > 2 && nextCmd[0] == "L") {
                // Calc the points we're dealing with
                var prevPoint = pointForCommand(prevCmd);
                var curPoint = pointForCommand(curCmd);
                var nextPoint = pointForCommand(nextCmd);

                // The start and end of the cuve are just our point moved towards the previous and next points, respectivly
                var curveStart, curveEnd;

                if (useFractionalRadius) {
                    curveStart = moveTowardsFractional(curPoint, prevCmd.origPoint || prevPoint, radius);
                    curveEnd = moveTowardsFractional(curPoint, nextCmd.origPoint || nextPoint, radius);
                } else {
                    curveStart = moveTowardsLength(curPoint, prevPoint, radius);
                    curveEnd = moveTowardsLength(curPoint, nextPoint, radius);
                }

                // Adjust the current command and add it
                adjustCommand(curCmd, curveStart);
                curCmd.origPoint = curPoint;
                resultCommands.push(curCmd);

                // The curve control points are halfway between the start/end of the curve and
                // the original point
                var startControl = moveTowardsFractional(curveStart, curPoint, .5);
                var endControl = moveTowardsFractional(curPoint, curveEnd, .5);

                // Create the curve
                var curveCmd = ["C", startControl.x, startControl.y, endControl.x, endControl.y, curveEnd.x, curveEnd.y];
                // Save the original point for fractional calculations
                curveCmd.origPoint = curPoint;
                resultCommands.push(curveCmd);
            } else {
                // Pass through commands that don't qualify
                resultCommands.push(curCmd);
            }
        }

        // Fix up the starting point and restore the close path if the path was orignally closed
        if (virtualCloseLine) {
            var newStartPoint = pointForCommand(resultCommands[resultCommands.length - 1]);
            resultCommands.push(["Z"]);
            adjustCommand(resultCommands[0], newStartPoint);
        }
    } else {
        resultCommands = commands;
    }

    return resultCommands.reduce(function (str, c) { return str + c.join(" ") + " "; }, "");
}

!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.moment = t() }(this, function () { "use strict"; function e() { return Qe.apply(null, arguments) } function t(e) { return e instanceof Array || "[object Array]" === Object.prototype.toString.call(e) } function n(e) { return null != e && "[object Object]" === Object.prototype.toString.call(e) } function s(e) { return void 0 === e } function i(e) { return "number" == typeof e || "[object Number]" === Object.prototype.toString.call(e) } function r(e) { return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e) } function a(e, t) { var n, s = []; for (n = 0; n < e.length; ++n)s.push(t(e[n], n)); return s } function o(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function u(e, t) { for (var n in t) o(t, n) && (e[n] = t[n]); return o(t, "toString") && (e.toString = t.toString), o(t, "valueOf") && (e.valueOf = t.valueOf), e } function l(e, t, n, s) { return ge(e, t, n, s, !0).utc() } function d(e) { return null == e._pf && (e._pf = { empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1, parsedDateParts: [], meridiem: null, rfc2822: !1, weekdayMismatch: !1 }), e._pf } function h(e) { if (null == e._isValid) { var t = d(e), n = Xe.call(t.parsedDateParts, function (e) { return null != e }), s = !isNaN(e._d.getTime()) && t.overflow < 0 && !t.empty && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n); if (e._strict && (s = s && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour), null != Object.isFrozen && Object.isFrozen(e)) return s; e._isValid = s } return e._isValid } function c(e) { var t = l(NaN); return null != e ? u(d(t), e) : d(t).userInvalidated = !0, t } function f(e, t) { var n, i, r; if (s(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), s(t._i) || (e._i = t._i), s(t._f) || (e._f = t._f), s(t._l) || (e._l = t._l), s(t._strict) || (e._strict = t._strict), s(t._tzm) || (e._tzm = t._tzm), s(t._isUTC) || (e._isUTC = t._isUTC), s(t._offset) || (e._offset = t._offset), s(t._pf) || (e._pf = d(t)), s(t._locale) || (e._locale = t._locale), Ke.length > 0) for (n = 0; n < Ke.length; n++)s(r = t[i = Ke[n]]) || (e[i] = r); return e } function m(t) { f(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === et && (et = !0, e.updateOffset(this), et = !1) } function _(e) { return e instanceof m || null != e && null != e._isAMomentObject } function y(e) { return e < 0 ? Math.ceil(e) || 0 : Math.floor(e) } function g(e) { var t = +e, n = 0; return 0 !== t && isFinite(t) && (n = y(t)), n } function p(e, t, n) { var s, i = Math.min(e.length, t.length), r = Math.abs(e.length - t.length), a = 0; for (s = 0; s < i; s++)(n && e[s] !== t[s] || !n && g(e[s]) !== g(t[s])) && a++; return a + r } function w(t) { !1 === e.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t) } function v(t, n) { var s = !0; return u(function () { if (null != e.deprecationHandler && e.deprecationHandler(null, t), s) { for (var i, r = [], a = 0; a < arguments.length; a++) { if (i = "", "object" == typeof arguments[a]) { i += "\n[" + a + "] "; for (var o in arguments[0]) i += o + ": " + arguments[0][o] + ", "; i = i.slice(0, -2) } else i = arguments[a]; r.push(i) } w(t + "\nArguments: " + Array.prototype.slice.call(r).join("") + "\n" + (new Error).stack), s = !1 } return n.apply(this, arguments) }, n) } function M(t, n) { null != e.deprecationHandler && e.deprecationHandler(t, n), tt[t] || (w(n), tt[t] = !0) } function k(e) { return e instanceof Function || "[object Function]" === Object.prototype.toString.call(e) } function S(e, t) { var s, i = u({}, e); for (s in t) o(t, s) && (n(e[s]) && n(t[s]) ? (i[s] = {}, u(i[s], e[s]), u(i[s], t[s])) : null != t[s] ? i[s] = t[s] : delete i[s]); for (s in e) o(e, s) && !o(t, s) && n(e[s]) && (i[s] = u({}, i[s])); return i } function D(e) { null != e && this.set(e) } function Y(e, t) { var n = e.toLowerCase(); st[n] = st[n + "s"] = st[t] = e } function O(e) { return "string" == typeof e ? st[e] || st[e.toLowerCase()] : void 0 } function x(e) { var t, n, s = {}; for (n in e) o(e, n) && (t = O(n)) && (s[t] = e[n]); return s } function T(e, t) { it[e] = t } function b(e, t, n) { var s = "" + Math.abs(e), i = t - s.length; return (e >= 0 ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + s } function P(e, t, n, s) { var i = s; "string" == typeof s && (i = function () { return this[s]() }), e && (ut[e] = i), t && (ut[t[0]] = function () { return b(i.apply(this, arguments), t[1], t[2]) }), n && (ut[n] = function () { return this.localeData().ordinal(i.apply(this, arguments), e) }) } function W(e) { return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "") } function R(e, t) { return e.isValid() ? (t = C(t, e.localeData()), ot[t] = ot[t] || function (e) { var t, n, s = e.match(rt); for (t = 0, n = s.length; t < n; t++)ut[s[t]] ? s[t] = ut[s[t]] : s[t] = W(s[t]); return function (t) { var i, r = ""; for (i = 0; i < n; i++)r += k(s[i]) ? s[i].call(t, e) : s[i]; return r } }(t), ot[t](e)) : e.localeData().invalidDate() } function C(e, t) { function n(e) { return t.longDateFormat(e) || e } var s = 5; for (at.lastIndex = 0; s >= 0 && at.test(e);)e = e.replace(at, n), at.lastIndex = 0, s -= 1; return e } function F(e, t, n) { Yt[e] = k(t) ? t : function (e, s) { return e && n ? n : t } } function U(e, t) { return o(Yt, e) ? Yt[e](t._strict, t._locale) : new RegExp(function (e) { return N(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (e, t, n, s, i) { return t || n || s || i })) }(e)) } function N(e) { return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") } function H(e, t) { var n, s = t; for ("string" == typeof e && (e = [e]), i(t) && (s = function (e, n) { n[t] = g(e) }), n = 0; n < e.length; n++)Ot[e[n]] = s } function L(e, t) { H(e, function (e, n, s, i) { s._w = s._w || {}, t(e, s._w, s, i) }) } function G(e, t, n) { null != t && o(Ot, e) && Ot[e](t, n._a, n, e) } function V(e) { return j(e) ? 366 : 365 } function j(e) { return e % 4 == 0 && e % 100 != 0 || e % 400 == 0 } function I(t, n) { return function (s) { return null != s ? (A(this, t, s), e.updateOffset(this, n), this) : E(this, t) } } function E(e, t) { return e.isValid() ? e._d["get" + (e._isUTC ? "UTC" : "") + t]() : NaN } function A(e, t, n) { e.isValid() && !isNaN(n) && ("FullYear" === t && j(e.year()) && 1 === e.month() && 29 === e.date() ? e._d["set" + (e._isUTC ? "UTC" : "") + t](n, e.month(), z(n, e.month())) : e._d["set" + (e._isUTC ? "UTC" : "") + t](n)) } function z(e, t) { if (isNaN(e) || isNaN(t)) return NaN; var n = function (e, t) { return (e % t + t) % t }(t, 12); return e += (t - n) / 12, 1 === n ? j(e) ? 29 : 28 : 31 - n % 7 % 2 } function Z(e, t) { var n; if (!e.isValid()) return e; if ("string" == typeof t) if (/^\d+$/.test(t)) t = g(t); else if (t = e.localeData().monthsParse(t), !i(t)) return e; return n = Math.min(e.date(), z(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n), e } function $(t) { return null != t ? (Z(this, t), e.updateOffset(this, !0), this) : E(this, "Month") } function q() { function e(e, t) { return t.length - e.length } var t, n, s = [], i = [], r = []; for (t = 0; t < 12; t++)n = l([2e3, t]), s.push(this.monthsShort(n, "")), i.push(this.months(n, "")), r.push(this.months(n, "")), r.push(this.monthsShort(n, "")); for (s.sort(e), i.sort(e), r.sort(e), t = 0; t < 12; t++)s[t] = N(s[t]), i[t] = N(i[t]); for (t = 0; t < 24; t++)r[t] = N(r[t]); this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i") } function J(e) { var t = new Date(Date.UTC.apply(null, arguments)); return e < 100 && e >= 0 && isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e), t } function B(e, t, n) { var s = 7 + t - n; return -((7 + J(e, 0, s).getUTCDay() - t) % 7) + s - 1 } function Q(e, t, n, s, i) { var r, a, o = 1 + 7 * (t - 1) + (7 + n - s) % 7 + B(e, s, i); return o <= 0 ? a = V(r = e - 1) + o : o > V(e) ? (r = e + 1, a = o - V(e)) : (r = e, a = o), { year: r, dayOfYear: a } } function X(e, t, n) { var s, i, r = B(e.year(), t, n), a = Math.floor((e.dayOfYear() - r - 1) / 7) + 1; return a < 1 ? s = a + K(i = e.year() - 1, t, n) : a > K(e.year(), t, n) ? (s = a - K(e.year(), t, n), i = e.year() + 1) : (i = e.year(), s = a), { week: s, year: i } } function K(e, t, n) { var s = B(e, t, n), i = B(e + 1, t, n); return (V(e) - s + i) / 7 } function ee() { function e(e, t) { return t.length - e.length } var t, n, s, i, r, a = [], o = [], u = [], d = []; for (t = 0; t < 7; t++)n = l([2e3, 1]).day(t), s = this.weekdaysMin(n, ""), i = this.weekdaysShort(n, ""), r = this.weekdays(n, ""), a.push(s), o.push(i), u.push(r), d.push(s), d.push(i), d.push(r); for (a.sort(e), o.sort(e), u.sort(e), d.sort(e), t = 0; t < 7; t++)o[t] = N(o[t]), u[t] = N(u[t]), d[t] = N(d[t]); this._weekdaysRegex = new RegExp("^(" + d.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + a.join("|") + ")", "i") } function te() { return this.hours() % 12 || 12 } function ne(e, t) { P(e, 0, 0, function () { return this.localeData().meridiem(this.hours(), this.minutes(), t) }) } function se(e, t) { return t._meridiemParse } function ie(e) { return e ? e.toLowerCase().replace("_", "-") : e } function re(e) { var t = null; if (!Xt[e] && "undefined" != typeof module && module && module.exports) try { t = Jt._abbr; require("./locale/" + e), ae(t) } catch (e) { } return Xt[e] } function ae(e, t) { var n; return e && (n = s(t) ? ue(e) : oe(e, t)) && (Jt = n), Jt._abbr } function oe(e, t) { if (null !== t) { var n = Qt; if (t.abbr = e, null != Xt[e]) M("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n = Xt[e]._config; else if (null != t.parentLocale) { if (null == Xt[t.parentLocale]) return Kt[t.parentLocale] || (Kt[t.parentLocale] = []), Kt[t.parentLocale].push({ name: e, config: t }), null; n = Xt[t.parentLocale]._config } return Xt[e] = new D(S(n, t)), Kt[e] && Kt[e].forEach(function (e) { oe(e.name, e.config) }), ae(e), Xt[e] } return delete Xt[e], null } function ue(e) { var n; if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e) return Jt; if (!t(e)) { if (n = re(e)) return n; e = [e] } return function (e) { for (var t, n, s, i, r = 0; r < e.length;) { for (t = (i = ie(e[r]).split("-")).length, n = (n = ie(e[r + 1])) ? n.split("-") : null; t > 0;) { if (s = re(i.slice(0, t).join("-"))) return s; if (n && n.length >= t && p(i, n, !0) >= t - 1) break; t-- } r++ } return null }(e) } function le(e) { var t, n = e._a; return n && -2 === d(e).overflow && (t = n[Tt] < 0 || n[Tt] > 11 ? Tt : n[bt] < 1 || n[bt] > z(n[xt], n[Tt]) ? bt : n[Pt] < 0 || n[Pt] > 24 || 24 === n[Pt] && (0 !== n[Wt] || 0 !== n[Rt] || 0 !== n[Ct]) ? Pt : n[Wt] < 0 || n[Wt] > 59 ? Wt : n[Rt] < 0 || n[Rt] > 59 ? Rt : n[Ct] < 0 || n[Ct] > 999 ? Ct : -1, d(e)._overflowDayOfYear && (t < xt || t > bt) && (t = bt), d(e)._overflowWeeks && -1 === t && (t = Ft), d(e)._overflowWeekday && -1 === t && (t = Ut), d(e).overflow = t), e } function de(e, t, n) { return null != e ? e : null != t ? t : n } function he(t) { var n, s, i, r, a, o = []; if (!t._d) { for (i = function (t) { var n = new Date(e.now()); return t._useUTC ? [n.getUTCFullYear(), n.getUTCMonth(), n.getUTCDate()] : [n.getFullYear(), n.getMonth(), n.getDate()] }(t), t._w && null == t._a[bt] && null == t._a[Tt] && function (e) { var t, n, s, i, r, a, o, u; if (null != (t = e._w).GG || null != t.W || null != t.E) r = 1, a = 4, n = de(t.GG, e._a[xt], X(pe(), 1, 4).year), s = de(t.W, 1), ((i = de(t.E, 1)) < 1 || i > 7) && (u = !0); else { r = e._locale._week.dow, a = e._locale._week.doy; var l = X(pe(), r, a); n = de(t.gg, e._a[xt], l.year), s = de(t.w, l.week), null != t.d ? ((i = t.d) < 0 || i > 6) && (u = !0) : null != t.e ? (i = t.e + r, (t.e < 0 || t.e > 6) && (u = !0)) : i = r } s < 1 || s > K(n, r, a) ? d(e)._overflowWeeks = !0 : null != u ? d(e)._overflowWeekday = !0 : (o = Q(n, s, i, r, a), e._a[xt] = o.year, e._dayOfYear = o.dayOfYear) }(t), null != t._dayOfYear && (a = de(t._a[xt], i[xt]), (t._dayOfYear > V(a) || 0 === t._dayOfYear) && (d(t)._overflowDayOfYear = !0), s = J(a, 0, t._dayOfYear), t._a[Tt] = s.getUTCMonth(), t._a[bt] = s.getUTCDate()), n = 0; n < 3 && null == t._a[n]; ++n)t._a[n] = o[n] = i[n]; for (; n < 7; n++)t._a[n] = o[n] = null == t._a[n] ? 2 === n ? 1 : 0 : t._a[n]; 24 === t._a[Pt] && 0 === t._a[Wt] && 0 === t._a[Rt] && 0 === t._a[Ct] && (t._nextDay = !0, t._a[Pt] = 0), t._d = (t._useUTC ? J : function (e, t, n, s, i, r, a) { var o = new Date(e, t, n, s, i, r, a); return e < 100 && e >= 0 && isFinite(o.getFullYear()) && o.setFullYear(e), o }).apply(null, o), r = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[Pt] = 24), t._w && void 0 !== t._w.d && t._w.d !== r && (d(t).weekdayMismatch = !0) } } function ce(e) { var t, n, s, i, r, a, o = e._i, u = en.exec(o) || tn.exec(o); if (u) { for (d(e).iso = !0, t = 0, n = sn.length; t < n; t++)if (sn[t][1].exec(u[1])) { i = sn[t][0], s = !1 !== sn[t][2]; break } if (null == i) return void (e._isValid = !1); if (u[3]) { for (t = 0, n = rn.length; t < n; t++)if (rn[t][1].exec(u[3])) { r = (u[2] || " ") + rn[t][0]; break } if (null == r) return void (e._isValid = !1) } if (!s && null != r) return void (e._isValid = !1); if (u[4]) { if (!nn.exec(u[4])) return void (e._isValid = !1); a = "Z" } e._f = i + (r || "") + (a || ""), _e(e) } else e._isValid = !1 } function fe(e, t, n, s, i, r) { var a = [function (e) { var t = parseInt(e, 10); { if (t <= 49) return 2e3 + t; if (t <= 999) return 1900 + t } return t }(e), Vt.indexOf(t), parseInt(n, 10), parseInt(s, 10), parseInt(i, 10)]; return r && a.push(parseInt(r, 10)), a } function me(e) { var t = on.exec(function (e) { return e.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim() }(e._i)); if (t) { var n = fe(t[4], t[3], t[2], t[5], t[6], t[7]); if (!function (e, t, n) { if (e && At.indexOf(e) !== new Date(t[0], t[1], t[2]).getDay()) return d(n).weekdayMismatch = !0, n._isValid = !1, !1; return !0 }(t[1], n, e)) return; e._a = n, e._tzm = function (e, t, n) { if (e) return un[e]; if (t) return 0; var s = parseInt(n, 10), i = s % 100; return (s - i) / 100 * 60 + i }(t[8], t[9], t[10]), e._d = J.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), d(e).rfc2822 = !0 } else e._isValid = !1 } function _e(t) { if (t._f !== e.ISO_8601) if (t._f !== e.RFC_2822) { t._a = [], d(t).empty = !0; var n, s, i, r, a, o = "" + t._i, u = o.length, l = 0; for (i = C(t._f, t._locale).match(rt) || [], n = 0; n < i.length; n++)r = i[n], (s = (o.match(U(r, t)) || [])[0]) && ((a = o.substr(0, o.indexOf(s))).length > 0 && d(t).unusedInput.push(a), o = o.slice(o.indexOf(s) + s.length), l += s.length), ut[r] ? (s ? d(t).empty = !1 : d(t).unusedTokens.push(r), G(r, s, t)) : t._strict && !s && d(t).unusedTokens.push(r); d(t).charsLeftOver = u - l, o.length > 0 && d(t).unusedInput.push(o), t._a[Pt] <= 12 && !0 === d(t).bigHour && t._a[Pt] > 0 && (d(t).bigHour = void 0), d(t).parsedDateParts = t._a.slice(0), d(t).meridiem = t._meridiem, t._a[Pt] = function (e, t, n) { var s; if (null == n) return t; return null != e.meridiemHour ? e.meridiemHour(t, n) : null != e.isPM ? ((s = e.isPM(n)) && t < 12 && (t += 12), s || 12 !== t || (t = 0), t) : t }(t._locale, t._a[Pt], t._meridiem), he(t), le(t) } else me(t); else ce(t) } function ye(o) { var l = o._i, y = o._f; return o._locale = o._locale || ue(o._l), null === l || void 0 === y && "" === l ? c({ nullInput: !0 }) : ("string" == typeof l && (o._i = l = o._locale.preparse(l)), _(l) ? new m(le(l)) : (r(l) ? o._d = l : t(y) ? function (e) { var t, n, s, i, r; if (0 === e._f.length) return d(e).invalidFormat = !0, void (e._d = new Date(NaN)); for (i = 0; i < e._f.length; i++)r = 0, t = f({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[i], _e(t), h(t) && (r += d(t).charsLeftOver, r += 10 * d(t).unusedTokens.length, d(t).score = r, (null == s || r < s) && (s = r, n = t)); u(e, n || t) }(o) : y ? _e(o) : function (o) { var u = o._i; s(u) ? o._d = new Date(e.now()) : r(u) ? o._d = new Date(u.valueOf()) : "string" == typeof u ? function (t) { var n = an.exec(t._i); null === n ? (ce(t), !1 === t._isValid && (delete t._isValid, me(t), !1 === t._isValid && (delete t._isValid, e.createFromInputFallback(t)))) : t._d = new Date(+n[1]) }(o) : t(u) ? (o._a = a(u.slice(0), function (e) { return parseInt(e, 10) }), he(o)) : n(u) ? function (e) { if (!e._d) { var t = x(e._i); e._a = a([t.year, t.month, t.day || t.date, t.hour, t.minute, t.second, t.millisecond], function (e) { return e && parseInt(e, 10) }), he(e) } }(o) : i(u) ? o._d = new Date(u) : e.createFromInputFallback(o) }(o), h(o) || (o._d = null), o)) } function ge(e, s, i, r, a) { var o = {}; return !0 !== i && !1 !== i || (r = i, i = void 0), (n(e) && function (e) { if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e).length; var t; for (t in e) if (e.hasOwnProperty(t)) return !1; return !0 }(e) || t(e) && 0 === e.length) && (e = void 0), o._isAMomentObject = !0, o._useUTC = o._isUTC = a, o._l = i, o._i = e, o._f = s, o._strict = r, function (e) { var t = new m(le(ye(e))); return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t }(o) } function pe(e, t, n, s) { return ge(e, t, n, s, !1) } function we(e, n) { var s, i; if (1 === n.length && t(n[0]) && (n = n[0]), !n.length) return pe(); for (s = n[0], i = 1; i < n.length; ++i)n[i].isValid() && !n[i][e](s) || (s = n[i]); return s } function ve(e) { var t = x(e), n = t.year || 0, s = t.quarter || 0, i = t.month || 0, r = t.week || 0, a = t.day || 0, o = t.hour || 0, u = t.minute || 0, l = t.second || 0, d = t.millisecond || 0; this._isValid = function (e) { for (var t in e) if (-1 === Nt.call(hn, t) || null != e[t] && isNaN(e[t])) return !1; for (var n = !1, s = 0; s < hn.length; ++s)if (e[hn[s]]) { if (n) return !1; parseFloat(e[hn[s]]) !== g(e[hn[s]]) && (n = !0) } return !0 }(t), this._milliseconds = +d + 1e3 * l + 6e4 * u + 1e3 * o * 60 * 60, this._days = +a + 7 * r, this._months = +i + 3 * s + 12 * n, this._data = {}, this._locale = ue(), this._bubble() } function Me(e) { return e instanceof ve } function ke(e) { return e < 0 ? -1 * Math.round(-1 * e) : Math.round(e) } function Se(e, t) { P(e, 0, 0, function () { var e = this.utcOffset(), n = "+"; return e < 0 && (e = -e, n = "-"), n + b(~~(e / 60), 2) + t + b(~~e % 60, 2) }) } function De(e, t) { var n = (t || "").match(e); if (null === n) return null; var s = ((n[n.length - 1] || []) + "").match(cn) || ["-", 0, 0], i = 60 * s[1] + g(s[2]); return 0 === i ? 0 : "+" === s[0] ? i : -i } function Ye(t, n) { var s, i; return n._isUTC ? (s = n.clone(), i = (_(t) || r(t) ? t.valueOf() : pe(t).valueOf()) - s.valueOf(), s._d.setTime(s._d.valueOf() + i), e.updateOffset(s, !1), s) : pe(t).local() } function Oe(e) { return 15 * -Math.round(e._d.getTimezoneOffset() / 15) } function xe() { return !!this.isValid() && (this._isUTC && 0 === this._offset) } function Te(e, t) { var n, s, r, a = e, u = null; return Me(e) ? a = { ms: e._milliseconds, d: e._days, M: e._months } : i(e) ? (a = {}, t ? a[t] = e : a.milliseconds = e) : (u = fn.exec(e)) ? (n = "-" === u[1] ? -1 : 1, a = { y: 0, d: g(u[bt]) * n, h: g(u[Pt]) * n, m: g(u[Wt]) * n, s: g(u[Rt]) * n, ms: g(ke(1e3 * u[Ct])) * n }) : (u = mn.exec(e)) ? (n = "-" === u[1] ? -1 : (u[1], 1), a = { y: be(u[2], n), M: be(u[3], n), w: be(u[4], n), d: be(u[5], n), h: be(u[6], n), m: be(u[7], n), s: be(u[8], n) }) : null == a ? a = {} : "object" == typeof a && ("from" in a || "to" in a) && (r = function (e, t) { var n; if (!e.isValid() || !t.isValid()) return { milliseconds: 0, months: 0 }; t = Ye(t, e), e.isBefore(t) ? n = Pe(e, t) : ((n = Pe(t, e)).milliseconds = -n.milliseconds, n.months = -n.months); return n }(pe(a.from), pe(a.to)), (a = {}).ms = r.milliseconds, a.M = r.months), s = new ve(a), Me(e) && o(e, "_locale") && (s._locale = e._locale), s } function be(e, t) { var n = e && parseFloat(e.replace(",", ".")); return (isNaN(n) ? 0 : n) * t } function Pe(e, t) { var n = { milliseconds: 0, months: 0 }; return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n } function We(e, t) { return function (n, s) { var i, r; return null === s || isNaN(+s) || (M(t, "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), r = n, n = s, s = r), n = "string" == typeof n ? +n : n, i = Te(n, s), Re(this, i, e), this } } function Re(t, n, s, i) { var r = n._milliseconds, a = ke(n._days), o = ke(n._months); t.isValid() && (i = null == i || i, o && Z(t, E(t, "Month") + o * s), a && A(t, "Date", E(t, "Date") + a * s), r && t._d.setTime(t._d.valueOf() + r * s), i && e.updateOffset(t, a || o)) } function Ce(e, t) { var n, s = 12 * (t.year() - e.year()) + (t.month() - e.month()), i = e.clone().add(s, "months"); return n = t - i < 0 ? (t - i) / (i - e.clone().add(s - 1, "months")) : (t - i) / (e.clone().add(s + 1, "months") - i), -(s + n) || 0 } function Fe(e) { var t; return void 0 === e ? this._locale._abbr : (null != (t = ue(e)) && (this._locale = t), this) } function Ue() { return this._locale } function Ne(e, t) { P(0, [e, e.length], 0, t) } function He(e, t, n, s, i) { var r; return null == e ? X(this, s, i).year : (r = K(e, s, i), t > r && (t = r), function (e, t, n, s, i) { var r = Q(e, t, n, s, i), a = J(r.year, 0, r.dayOfYear); return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this }.call(this, e, t, n, s, i)) } function Le(e, t) { t[Ct] = g(1e3 * ("0." + e)) } function Ge(e) { return e } function Ve(e, t, n, s) { var i = ue(), r = l().set(s, t); return i[n](r, e) } function je(e, t, n) { if (i(e) && (t = e, e = void 0), e = e || "", null != t) return Ve(e, t, n, "month"); var s, r = []; for (s = 0; s < 12; s++)r[s] = Ve(e, s, n, "month"); return r } function Ie(e, t, n, s) { "boolean" == typeof e ? (i(t) && (n = t, t = void 0), t = t || "") : (n = t = e, e = !1, i(t) && (n = t, t = void 0), t = t || ""); var r = ue(), a = e ? r._week.dow : 0; if (null != n) return Ve(t, (n + a) % 7, s, "day"); var o, u = []; for (o = 0; o < 7; o++)u[o] = Ve(t, (o + a) % 7, s, "day"); return u } function Ee(e, t, n, s) { var i = Te(t, n); return e._milliseconds += s * i._milliseconds, e._days += s * i._days, e._months += s * i._months, e._bubble() } function Ae(e) { return e < 0 ? Math.floor(e) : Math.ceil(e) } function ze(e) { return 4800 * e / 146097 } function Ze(e) { return 146097 * e / 4800 } function $e(e) { return function () { return this.as(e) } } function qe(e) { return function () { return this.isValid() ? this._data[e] : NaN } } function Je(e) { return (e > 0) - (e < 0) || +e } function Be() { if (!this.isValid()) return this.localeData().invalidDate(); var e, t, n = En(this._milliseconds) / 1e3, s = En(this._days), i = En(this._months); t = y((e = y(n / 60)) / 60), n %= 60, e %= 60; var r = y(i / 12), a = i %= 12, o = s, u = t, l = e, d = n ? n.toFixed(3).replace(/\.?0+$/, "") : "", h = this.asSeconds(); if (!h) return "P0D"; var c = h < 0 ? "-" : "", f = Je(this._months) !== Je(h) ? "-" : "", m = Je(this._days) !== Je(h) ? "-" : "", _ = Je(this._milliseconds) !== Je(h) ? "-" : ""; return c + "P" + (r ? f + r + "Y" : "") + (a ? f + a + "M" : "") + (o ? m + o + "D" : "") + (u || l || d ? "T" : "") + (u ? _ + u + "H" : "") + (l ? _ + l + "M" : "") + (d ? _ + d + "S" : "") } var Qe, Xe; Xe = Array.prototype.some ? Array.prototype.some : function (e) { for (var t = Object(this), n = t.length >>> 0, s = 0; s < n; s++)if (s in t && e.call(this, t[s], s, t)) return !0; return !1 }; var Ke = e.momentProperties = [], et = !1, tt = {}; e.suppressDeprecationWarnings = !1, e.deprecationHandler = null; var nt; nt = Object.keys ? Object.keys : function (e) { var t, n = []; for (t in e) o(e, t) && n.push(t); return n }; var st = {}, it = {}, rt = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, at = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, ot = {}, ut = {}, lt = /\d/, dt = /\d\d/, ht = /\d{3}/, ct = /\d{4}/, ft = /[+-]?\d{6}/, mt = /\d\d?/, _t = /\d\d\d\d?/, yt = /\d\d\d\d\d\d?/, gt = /\d{1,3}/, pt = /\d{1,4}/, wt = /[+-]?\d{1,6}/, vt = /\d+/, Mt = /[+-]?\d+/, kt = /Z|[+-]\d\d:?\d\d/gi, St = /Z|[+-]\d\d(?::?\d\d)?/gi, Dt = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, Yt = {}, Ot = {}, xt = 0, Tt = 1, bt = 2, Pt = 3, Wt = 4, Rt = 5, Ct = 6, Ft = 7, Ut = 8; P("Y", 0, 0, function () { var e = this.year(); return e <= 9999 ? "" + e : "+" + e }), P(0, ["YY", 2], 0, function () { return this.year() % 100 }), P(0, ["YYYY", 4], 0, "year"), P(0, ["YYYYY", 5], 0, "year"), P(0, ["YYYYYY", 6, !0], 0, "year"), Y("year", "y"), T("year", 1), F("Y", Mt), F("YY", mt, dt), F("YYYY", pt, ct), F("YYYYY", wt, ft), F("YYYYYY", wt, ft), H(["YYYYY", "YYYYYY"], xt), H("YYYY", function (t, n) { n[xt] = 2 === t.length ? e.parseTwoDigitYear(t) : g(t) }), H("YY", function (t, n) { n[xt] = e.parseTwoDigitYear(t) }), H("Y", function (e, t) { t[xt] = parseInt(e, 10) }), e.parseTwoDigitYear = function (e) { return g(e) + (g(e) > 68 ? 1900 : 2e3) }; var Nt, Ht = I("FullYear", !0); Nt = Array.prototype.indexOf ? Array.prototype.indexOf : function (e) { var t; for (t = 0; t < this.length; ++t)if (this[t] === e) return t; return -1 }, P("M", ["MM", 2], "Mo", function () { return this.month() + 1 }), P("MMM", 0, 0, function (e) { return this.localeData().monthsShort(this, e) }), P("MMMM", 0, 0, function (e) { return this.localeData().months(this, e) }), Y("month", "M"), T("month", 8), F("M", mt), F("MM", mt, dt), F("MMM", function (e, t) { return t.monthsShortRegex(e) }), F("MMMM", function (e, t) { return t.monthsRegex(e) }), H(["M", "MM"], function (e, t) { t[Tt] = g(e) - 1 }), H(["MMM", "MMMM"], function (e, t, n, s) { var i = n._locale.monthsParse(e, s, n._strict); null != i ? t[Tt] = i : d(n).invalidMonth = e }); var Lt = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Gt = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), Vt = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), jt = Dt, It = Dt; P("w", ["ww", 2], "wo", "week"), P("W", ["WW", 2], "Wo", "isoWeek"), Y("week", "w"), Y("isoWeek", "W"), T("week", 5), T("isoWeek", 5), F("w", mt), F("ww", mt, dt), F("W", mt), F("WW", mt, dt), L(["w", "ww", "W", "WW"], function (e, t, n, s) { t[s.substr(0, 1)] = g(e) }); P("d", 0, "do", "day"), P("dd", 0, 0, function (e) { return this.localeData().weekdaysMin(this, e) }), P("ddd", 0, 0, function (e) { return this.localeData().weekdaysShort(this, e) }), P("dddd", 0, 0, function (e) { return this.localeData().weekdays(this, e) }), P("e", 0, 0, "weekday"), P("E", 0, 0, "isoWeekday"), Y("day", "d"), Y("weekday", "e"), Y("isoWeekday", "E"), T("day", 11), T("weekday", 11), T("isoWeekday", 11), F("d", mt), F("e", mt), F("E", mt), F("dd", function (e, t) { return t.weekdaysMinRegex(e) }), F("ddd", function (e, t) { return t.weekdaysShortRegex(e) }), F("dddd", function (e, t) { return t.weekdaysRegex(e) }), L(["dd", "ddd", "dddd"], function (e, t, n, s) { var i = n._locale.weekdaysParse(e, s, n._strict); null != i ? t.d = i : d(n).invalidWeekday = e }), L(["d", "e", "E"], function (e, t, n, s) { t[s] = g(e) }); var Et = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), At = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), zt = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Zt = Dt, $t = Dt, qt = Dt; P("H", ["HH", 2], 0, "hour"), P("h", ["hh", 2], 0, te), P("k", ["kk", 2], 0, function () { return this.hours() || 24 }), P("hmm", 0, 0, function () { return "" + te.apply(this) + b(this.minutes(), 2) }), P("hmmss", 0, 0, function () { return "" + te.apply(this) + b(this.minutes(), 2) + b(this.seconds(), 2) }), P("Hmm", 0, 0, function () { return "" + this.hours() + b(this.minutes(), 2) }), P("Hmmss", 0, 0, function () { return "" + this.hours() + b(this.minutes(), 2) + b(this.seconds(), 2) }), ne("a", !0), ne("A", !1), Y("hour", "h"), T("hour", 13), F("a", se), F("A", se), F("H", mt), F("h", mt), F("k", mt), F("HH", mt, dt), F("hh", mt, dt), F("kk", mt, dt), F("hmm", _t), F("hmmss", yt), F("Hmm", _t), F("Hmmss", yt), H(["H", "HH"], Pt), H(["k", "kk"], function (e, t, n) { var s = g(e); t[Pt] = 24 === s ? 0 : s }), H(["a", "A"], function (e, t, n) { n._isPm = n._locale.isPM(e), n._meridiem = e }), H(["h", "hh"], function (e, t, n) { t[Pt] = g(e), d(n).bigHour = !0 }), H("hmm", function (e, t, n) { var s = e.length - 2; t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s)), d(n).bigHour = !0 }), H("hmmss", function (e, t, n) { var s = e.length - 4, i = e.length - 2; t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s, 2)), t[Rt] = g(e.substr(i)), d(n).bigHour = !0 }), H("Hmm", function (e, t, n) { var s = e.length - 2; t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s)) }), H("Hmmss", function (e, t, n) { var s = e.length - 4, i = e.length - 2; t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s, 2)), t[Rt] = g(e.substr(i)) }); var Jt, Bt = I("Hours", !0), Qt = { calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, longDateFormat: { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: /\d{1,2}/, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, months: Gt, monthsShort: Vt, week: { dow: 0, doy: 6 }, weekdays: Et, weekdaysMin: zt, weekdaysShort: At, meridiemParse: /[ap]\.?m?\.?/i }, Xt = {}, Kt = {}, en = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tn = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, nn = /Z|[+-]\d\d(?::?\d\d)?/, sn = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/]], rn = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], an = /^\/?Date\((\-?\d+)/i, on = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, un = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 }; e.createFromInputFallback = v("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (e) { e._d = new Date(e._i + (e._useUTC ? " UTC" : "")) }), e.ISO_8601 = function () { }, e.RFC_2822 = function () { }; var ln = v("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () { var e = pe.apply(null, arguments); return this.isValid() && e.isValid() ? e < this ? this : e : c() }), dn = v("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () { var e = pe.apply(null, arguments); return this.isValid() && e.isValid() ? e > this ? this : e : c() }), hn = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"]; Se("Z", ":"), Se("ZZ", ""), F("Z", St), F("ZZ", St), H(["Z", "ZZ"], function (e, t, n) { n._useUTC = !0, n._tzm = De(St, e) }); var cn = /([\+\-]|\d\d)/gi; e.updateOffset = function () { }; var fn = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/, mn = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/; Te.fn = ve.prototype, Te.invalid = function () { return Te(NaN) }; var _n = We(1, "add"), yn = We(-1, "subtract"); e.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", e.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]"; var gn = v("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (e) { return void 0 === e ? this.localeData() : this.locale(e) }); P(0, ["gg", 2], 0, function () { return this.weekYear() % 100 }), P(0, ["GG", 2], 0, function () { return this.isoWeekYear() % 100 }), Ne("gggg", "weekYear"), Ne("ggggg", "weekYear"), Ne("GGGG", "isoWeekYear"), Ne("GGGGG", "isoWeekYear"), Y("weekYear", "gg"), Y("isoWeekYear", "GG"), T("weekYear", 1), T("isoWeekYear", 1), F("G", Mt), F("g", Mt), F("GG", mt, dt), F("gg", mt, dt), F("GGGG", pt, ct), F("gggg", pt, ct), F("GGGGG", wt, ft), F("ggggg", wt, ft), L(["gggg", "ggggg", "GGGG", "GGGGG"], function (e, t, n, s) { t[s.substr(0, 2)] = g(e) }), L(["gg", "GG"], function (t, n, s, i) { n[i] = e.parseTwoDigitYear(t) }), P("Q", 0, "Qo", "quarter"), Y("quarter", "Q"), T("quarter", 7), F("Q", lt), H("Q", function (e, t) { t[Tt] = 3 * (g(e) - 1) }), P("D", ["DD", 2], "Do", "date"), Y("date", "D"), T("date", 9), F("D", mt), F("DD", mt, dt), F("Do", function (e, t) { return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient }), H(["D", "DD"], bt), H("Do", function (e, t) { t[bt] = g(e.match(mt)[0]) }); var pn = I("Date", !0); P("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), Y("dayOfYear", "DDD"), T("dayOfYear", 4), F("DDD", gt), F("DDDD", ht), H(["DDD", "DDDD"], function (e, t, n) { n._dayOfYear = g(e) }), P("m", ["mm", 2], 0, "minute"), Y("minute", "m"), T("minute", 14), F("m", mt), F("mm", mt, dt), H(["m", "mm"], Wt); var wn = I("Minutes", !1); P("s", ["ss", 2], 0, "second"), Y("second", "s"), T("second", 15), F("s", mt), F("ss", mt, dt), H(["s", "ss"], Rt); var vn = I("Seconds", !1); P("S", 0, 0, function () { return ~~(this.millisecond() / 100) }), P(0, ["SS", 2], 0, function () { return ~~(this.millisecond() / 10) }), P(0, ["SSS", 3], 0, "millisecond"), P(0, ["SSSS", 4], 0, function () { return 10 * this.millisecond() }), P(0, ["SSSSS", 5], 0, function () { return 100 * this.millisecond() }), P(0, ["SSSSSS", 6], 0, function () { return 1e3 * this.millisecond() }), P(0, ["SSSSSSS", 7], 0, function () { return 1e4 * this.millisecond() }), P(0, ["SSSSSSSS", 8], 0, function () { return 1e5 * this.millisecond() }), P(0, ["SSSSSSSSS", 9], 0, function () { return 1e6 * this.millisecond() }), Y("millisecond", "ms"), T("millisecond", 16), F("S", gt, lt), F("SS", gt, dt), F("SSS", gt, ht); var Mn; for (Mn = "SSSS"; Mn.length <= 9; Mn += "S")F(Mn, vt); for (Mn = "S"; Mn.length <= 9; Mn += "S")H(Mn, Le); var kn = I("Milliseconds", !1); P("z", 0, 0, "zoneAbbr"), P("zz", 0, 0, "zoneName"); var Sn = m.prototype; Sn.add = _n, Sn.calendar = function (t, n) { var s = t || pe(), i = Ye(s, this).startOf("day"), r = e.calendarFormat(this, i) || "sameElse", a = n && (k(n[r]) ? n[r].call(this, s) : n[r]); return this.format(a || this.localeData().calendar(r, this, pe(s))) }, Sn.clone = function () { return new m(this) }, Sn.diff = function (e, t, n) { var s, i, r; if (!this.isValid()) return NaN; if (!(s = Ye(e, this)).isValid()) return NaN; switch (i = 6e4 * (s.utcOffset() - this.utcOffset()), t = O(t)) { case "year": r = Ce(this, s) / 12; break; case "month": r = Ce(this, s); break; case "quarter": r = Ce(this, s) / 3; break; case "second": r = (this - s) / 1e3; break; case "minute": r = (this - s) / 6e4; break; case "hour": r = (this - s) / 36e5; break; case "day": r = (this - s - i) / 864e5; break; case "week": r = (this - s - i) / 6048e5; break; default: r = this - s }return n ? r : y(r) }, Sn.endOf = function (e) { return void 0 === (e = O(e)) || "millisecond" === e ? this : ("date" === e && (e = "day"), this.startOf(e).add(1, "isoWeek" === e ? "week" : e).subtract(1, "ms")) }, Sn.format = function (t) { t || (t = this.isUtc() ? e.defaultFormatUtc : e.defaultFormat); var n = R(this, t); return this.localeData().postformat(n) }, Sn.from = function (e, t) { return this.isValid() && (_(e) && e.isValid() || pe(e).isValid()) ? Te({ to: this, from: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate() }, Sn.fromNow = function (e) { return this.from(pe(), e) }, Sn.to = function (e, t) { return this.isValid() && (_(e) && e.isValid() || pe(e).isValid()) ? Te({ from: this, to: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate() }, Sn.toNow = function (e) { return this.to(pe(), e) }, Sn.get = function (e) { return e = O(e), k(this[e]) ? this[e]() : this }, Sn.invalidAt = function () { return d(this).overflow }, Sn.isAfter = function (e, t) { var n = _(e) ? e : pe(e); return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = O(s(t) ? "millisecond" : t)) ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf()) }, Sn.isBefore = function (e, t) { var n = _(e) ? e : pe(e); return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = O(s(t) ? "millisecond" : t)) ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf()) }, Sn.isBetween = function (e, t, n, s) { return ("(" === (s = s || "()")[0] ? this.isAfter(e, n) : !this.isBefore(e, n)) && (")" === s[1] ? this.isBefore(t, n) : !this.isAfter(t, n)) }, Sn.isSame = function (e, t) { var n, s = _(e) ? e : pe(e); return !(!this.isValid() || !s.isValid()) && ("millisecond" === (t = O(t || "millisecond")) ? this.valueOf() === s.valueOf() : (n = s.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf())) }, Sn.isSameOrAfter = function (e, t) { return this.isSame(e, t) || this.isAfter(e, t) }, Sn.isSameOrBefore = function (e, t) { return this.isSame(e, t) || this.isBefore(e, t) }, Sn.isValid = function () { return h(this) }, Sn.lang = gn, Sn.locale = Fe, Sn.localeData = Ue, Sn.max = dn, Sn.min = ln, Sn.parsingFlags = function () { return u({}, d(this)) }, Sn.set = function (e, t) { if ("object" == typeof e) for (var n = function (e) { var t = []; for (var n in e) t.push({ unit: n, priority: it[n] }); return t.sort(function (e, t) { return e.priority - t.priority }), t }(e = x(e)), s = 0; s < n.length; s++)this[n[s].unit](e[n[s].unit]); else if (e = O(e), k(this[e])) return this[e](t); return this }, Sn.startOf = function (e) { switch (e = O(e)) { case "year": this.month(0); case "quarter": case "month": this.date(1); case "week": case "isoWeek": case "day": case "date": this.hours(0); case "hour": this.minutes(0); case "minute": this.seconds(0); case "second": this.milliseconds(0) }return "week" === e && this.weekday(0), "isoWeek" === e && this.isoWeekday(1), "quarter" === e && this.month(3 * Math.floor(this.month() / 3)), this }, Sn.subtract = yn, Sn.toArray = function () { return [this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()] }, Sn.toObject = function () { return { years: this.year(), months: this.month(), date: this.date(), hours: this.hours(), minutes: this.minutes(), seconds: this.seconds(), milliseconds: this.milliseconds() } }, Sn.toDate = function () { return new Date(this.valueOf()) }, Sn.toISOString = function () { if (!this.isValid()) return null; var e = this.clone().utc(); return e.year() < 0 || e.year() > 9999 ? R(e, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : k(Date.prototype.toISOString) ? this.toDate().toISOString() : R(e, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") }, Sn.inspect = function () { if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)"; var e = "moment", t = ""; this.isLocal() || (e = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", t = "Z"); var n = "[" + e + '("]', s = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", i = t + '[")]'; return this.format(n + s + "-MM-DD[T]HH:mm:ss.SSS" + i) }, Sn.toJSON = function () { return this.isValid() ? this.toISOString() : null }, Sn.toString = function () { return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ") }, Sn.unix = function () { return Math.floor(this.valueOf() / 1e3) }, Sn.valueOf = function () { return this._d.valueOf() - 6e4 * (this._offset || 0) }, Sn.creationData = function () { return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict } }, Sn.year = Ht, Sn.isLeapYear = function () { return j(this.year()) }, Sn.weekYear = function (e) { return He.call(this, e, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy) }, Sn.isoWeekYear = function (e) { return He.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4) }, Sn.quarter = Sn.quarters = function (e) { return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3) }, Sn.month = $, Sn.daysInMonth = function () { return z(this.year(), this.month()) }, Sn.week = Sn.weeks = function (e) { var t = this.localeData().week(this); return null == e ? t : this.add(7 * (e - t), "d") }, Sn.isoWeek = Sn.isoWeeks = function (e) { var t = X(this, 1, 4).week; return null == e ? t : this.add(7 * (e - t), "d") }, Sn.weeksInYear = function () { var e = this.localeData()._week; return K(this.year(), e.dow, e.doy) }, Sn.isoWeeksInYear = function () { return K(this.year(), 1, 4) }, Sn.date = pn, Sn.day = Sn.days = function (e) { if (!this.isValid()) return null != e ? this : NaN; var t = this._isUTC ? this._d.getUTCDay() : this._d.getDay(); return null != e ? (e = function (e, t) { return "string" != typeof e ? e : isNaN(e) ? "number" == typeof (e = t.weekdaysParse(e)) ? e : null : parseInt(e, 10) }(e, this.localeData()), this.add(e - t, "d")) : t }, Sn.weekday = function (e) { if (!this.isValid()) return null != e ? this : NaN; var t = (this.day() + 7 - this.localeData()._week.dow) % 7; return null == e ? t : this.add(e - t, "d") }, Sn.isoWeekday = function (e) { if (!this.isValid()) return null != e ? this : NaN; if (null != e) { var t = function (e, t) { return "string" == typeof e ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e }(e, this.localeData()); return this.day(this.day() % 7 ? t : t - 7) } return this.day() || 7 }, Sn.dayOfYear = function (e) { var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1; return null == e ? t : this.add(e - t, "d") }, Sn.hour = Sn.hours = Bt, Sn.minute = Sn.minutes = wn, Sn.second = Sn.seconds = vn, Sn.millisecond = Sn.milliseconds = kn, Sn.utcOffset = function (t, n, s) { var i, r = this._offset || 0; if (!this.isValid()) return null != t ? this : NaN; if (null != t) { if ("string" == typeof t) { if (null === (t = De(St, t))) return this } else Math.abs(t) < 16 && !s && (t *= 60); return !this._isUTC && n && (i = Oe(this)), this._offset = t, this._isUTC = !0, null != i && this.add(i, "m"), r !== t && (!n || this._changeInProgress ? Re(this, Te(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, e.updateOffset(this, !0), this._changeInProgress = null)), this } return this._isUTC ? r : Oe(this) }, Sn.utc = function (e) { return this.utcOffset(0, e) }, Sn.local = function (e) { return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Oe(this), "m")), this }, Sn.parseZone = function () { if (null != this._tzm) this.utcOffset(this._tzm, !1, !0); else if ("string" == typeof this._i) { var e = De(kt, this._i); null != e ? this.utcOffset(e) : this.utcOffset(0, !0) } return this }, Sn.hasAlignedHourOffset = function (e) { return !!this.isValid() && (e = e ? pe(e).utcOffset() : 0, (this.utcOffset() - e) % 60 == 0) }, Sn.isDST = function () { return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset() }, Sn.isLocal = function () { return !!this.isValid() && !this._isUTC }, Sn.isUtcOffset = function () { return !!this.isValid() && this._isUTC }, Sn.isUtc = xe, Sn.isUTC = xe, Sn.zoneAbbr = function () { return this._isUTC ? "UTC" : "" }, Sn.zoneName = function () { return this._isUTC ? "Coordinated Universal Time" : "" }, Sn.dates = v("dates accessor is deprecated. Use date instead.", pn), Sn.months = v("months accessor is deprecated. Use month instead", $), Sn.years = v("years accessor is deprecated. Use year instead", Ht), Sn.zone = v("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (e, t) { return null != e ? ("string" != typeof e && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset() }), Sn.isDSTShifted = v("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () { if (!s(this._isDSTShifted)) return this._isDSTShifted; var e = {}; if (f(e, this), (e = ye(e))._a) { var t = e._isUTC ? l(e._a) : pe(e._a); this._isDSTShifted = this.isValid() && p(e._a, t.toArray()) > 0 } else this._isDSTShifted = !1; return this._isDSTShifted }); var Dn = D.prototype; Dn.calendar = function (e, t, n) { var s = this._calendar[e] || this._calendar.sameElse; return k(s) ? s.call(t, n) : s }, Dn.longDateFormat = function (e) { var t = this._longDateFormat[e], n = this._longDateFormat[e.toUpperCase()]; return t || !n ? t : (this._longDateFormat[e] = n.replace(/MMMM|MM|DD|dddd/g, function (e) { return e.slice(1) }), this._longDateFormat[e]) }, Dn.invalidDate = function () { return this._invalidDate }, Dn.ordinal = function (e) { return this._ordinal.replace("%d", e) }, Dn.preparse = Ge, Dn.postformat = Ge, Dn.relativeTime = function (e, t, n, s) { var i = this._relativeTime[n]; return k(i) ? i(e, t, n, s) : i.replace(/%d/i, e) }, Dn.pastFuture = function (e, t) { var n = this._relativeTime[e > 0 ? "future" : "past"]; return k(n) ? n(t) : n.replace(/%s/i, t) }, Dn.set = function (e) { var t, n; for (n in e) k(t = e[n]) ? this[n] = t : this["_" + n] = t; this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source) }, Dn.months = function (e, n) { return e ? t(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || Lt).test(n) ? "format" : "standalone"][e.month()] : t(this._months) ? this._months : this._months.standalone }, Dn.monthsShort = function (e, n) { return e ? t(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[Lt.test(n) ? "format" : "standalone"][e.month()] : t(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone }, Dn.monthsParse = function (e, t, n) { var s, i, r; if (this._monthsParseExact) return function (e, t, n) { var s, i, r, a = e.toLocaleLowerCase(); if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s)r = l([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[s] = this.months(r, "").toLocaleLowerCase(); return n ? "MMM" === t ? -1 !== (i = Nt.call(this._shortMonthsParse, a)) ? i : null : -1 !== (i = Nt.call(this._longMonthsParse, a)) ? i : null : "MMM" === t ? -1 !== (i = Nt.call(this._shortMonthsParse, a)) ? i : -1 !== (i = Nt.call(this._longMonthsParse, a)) ? i : null : -1 !== (i = Nt.call(this._longMonthsParse, a)) ? i : -1 !== (i = Nt.call(this._shortMonthsParse, a)) ? i : null }.call(this, e, t, n); for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) { if (i = l([2e3, s]), n && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[s] || (r = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[s] = new RegExp(r.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[s].test(e)) return s; if (n && "MMM" === t && this._shortMonthsParse[s].test(e)) return s; if (!n && this._monthsParse[s].test(e)) return s } }, Dn.monthsRegex = function (e) { return this._monthsParseExact ? (o(this, "_monthsRegex") || q.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (o(this, "_monthsRegex") || (this._monthsRegex = It), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex) }, Dn.monthsShortRegex = function (e) { return this._monthsParseExact ? (o(this, "_monthsRegex") || q.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (o(this, "_monthsShortRegex") || (this._monthsShortRegex = jt), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex) }, Dn.week = function (e) { return X(e, this._week.dow, this._week.doy).week }, Dn.firstDayOfYear = function () { return this._week.doy }, Dn.firstDayOfWeek = function () { return this._week.dow }, Dn.weekdays = function (e, n) { return e ? t(this._weekdays) ? this._weekdays[e.day()] : this._weekdays[this._weekdays.isFormat.test(n) ? "format" : "standalone"][e.day()] : t(this._weekdays) ? this._weekdays : this._weekdays.standalone }, Dn.weekdaysMin = function (e) { return e ? this._weekdaysMin[e.day()] : this._weekdaysMin }, Dn.weekdaysShort = function (e) { return e ? this._weekdaysShort[e.day()] : this._weekdaysShort }, Dn.weekdaysParse = function (e, t, n) { var s, i, r; if (this._weekdaysParseExact) return function (e, t, n) { var s, i, r, a = e.toLocaleLowerCase(); if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s)r = l([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(r, "").toLocaleLowerCase(); return n ? "dddd" === t ? -1 !== (i = Nt.call(this._weekdaysParse, a)) ? i : null : "ddd" === t ? -1 !== (i = Nt.call(this._shortWeekdaysParse, a)) ? i : null : -1 !== (i = Nt.call(this._minWeekdaysParse, a)) ? i : null : "dddd" === t ? -1 !== (i = Nt.call(this._weekdaysParse, a)) ? i : -1 !== (i = Nt.call(this._shortWeekdaysParse, a)) ? i : -1 !== (i = Nt.call(this._minWeekdaysParse, a)) ? i : null : "ddd" === t ? -1 !== (i = Nt.call(this._shortWeekdaysParse, a)) ? i : -1 !== (i = Nt.call(this._weekdaysParse, a)) ? i : -1 !== (i = Nt.call(this._minWeekdaysParse, a)) ? i : null : -1 !== (i = Nt.call(this._minWeekdaysParse, a)) ? i : -1 !== (i = Nt.call(this._weekdaysParse, a)) ? i : -1 !== (i = Nt.call(this._shortWeekdaysParse, a)) ? i : null }.call(this, e, t, n); for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) { if (i = l([2e3, 1]).day(s), n && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp("^" + this.weekdays(i, "").replace(".", ".?") + "$", "i"), this._shortWeekdaysParse[s] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", ".?") + "$", "i"), this._minWeekdaysParse[s] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", ".?") + "$", "i")), this._weekdaysParse[s] || (r = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[s] = new RegExp(r.replace(".", ""), "i")), n && "dddd" === t && this._fullWeekdaysParse[s].test(e)) return s; if (n && "ddd" === t && this._shortWeekdaysParse[s].test(e)) return s; if (n && "dd" === t && this._minWeekdaysParse[s].test(e)) return s; if (!n && this._weekdaysParse[s].test(e)) return s } }, Dn.weekdaysRegex = function (e) { return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (o(this, "_weekdaysRegex") || (this._weekdaysRegex = Zt), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex) }, Dn.weekdaysShortRegex = function (e) { return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (o(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = $t), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) }, Dn.weekdaysMinRegex = function (e) { return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (o(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = qt), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) }, Dn.isPM = function (e) { return "p" === (e + "").toLowerCase().charAt(0) }, Dn.meridiem = function (e, t, n) { return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM" }, ae("en", { dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function (e) { var t = e % 10; return e + (1 === g(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th") } }), e.lang = v("moment.lang is deprecated. Use moment.locale instead.", ae), e.langData = v("moment.langData is deprecated. Use moment.localeData instead.", ue); var Yn = Math.abs, On = $e("ms"), xn = $e("s"), Tn = $e("m"), bn = $e("h"), Pn = $e("d"), Wn = $e("w"), Rn = $e("M"), Cn = $e("y"), Fn = qe("milliseconds"), Un = qe("seconds"), Nn = qe("minutes"), Hn = qe("hours"), Ln = qe("days"), Gn = qe("months"), Vn = qe("years"), jn = Math.round, In = { ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11 }, En = Math.abs, An = ve.prototype; return An.isValid = function () { return this._isValid }, An.abs = function () { var e = this._data; return this._milliseconds = Yn(this._milliseconds), this._days = Yn(this._days), this._months = Yn(this._months), e.milliseconds = Yn(e.milliseconds), e.seconds = Yn(e.seconds), e.minutes = Yn(e.minutes), e.hours = Yn(e.hours), e.months = Yn(e.months), e.years = Yn(e.years), this }, An.add = function (e, t) { return Ee(this, e, t, 1) }, An.subtract = function (e, t) { return Ee(this, e, t, -1) }, An.as = function (e) { if (!this.isValid()) return NaN; var t, n, s = this._milliseconds; if ("month" === (e = O(e)) || "year" === e) return t = this._days + s / 864e5, n = this._months + ze(t), "month" === e ? n : n / 12; switch (t = this._days + Math.round(Ze(this._months)), e) { case "week": return t / 7 + s / 6048e5; case "day": return t + s / 864e5; case "hour": return 24 * t + s / 36e5; case "minute": return 1440 * t + s / 6e4; case "second": return 86400 * t + s / 1e3; case "millisecond": return Math.floor(864e5 * t) + s; default: throw new Error("Unknown unit " + e) } }, An.asMilliseconds = On, An.asSeconds = xn, An.asMinutes = Tn, An.asHours = bn, An.asDays = Pn, An.asWeeks = Wn, An.asMonths = Rn, An.asYears = Cn, An.valueOf = function () { return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * g(this._months / 12) : NaN }, An._bubble = function () { var e, t, n, s, i, r = this._milliseconds, a = this._days, o = this._months, u = this._data; return r >= 0 && a >= 0 && o >= 0 || r <= 0 && a <= 0 && o <= 0 || (r += 864e5 * Ae(Ze(o) + a), a = 0, o = 0), u.milliseconds = r % 1e3, e = y(r / 1e3), u.seconds = e % 60, t = y(e / 60), u.minutes = t % 60, n = y(t / 60), u.hours = n % 24, a += y(n / 24), i = y(ze(a)), o += i, a -= Ae(Ze(i)), s = y(o / 12), o %= 12, u.days = a, u.months = o, u.years = s, this }, An.clone = function () { return Te(this) }, An.get = function (e) { return e = O(e), this.isValid() ? this[e + "s"]() : NaN }, An.milliseconds = Fn, An.seconds = Un, An.minutes = Nn, An.hours = Hn, An.days = Ln, An.weeks = function () { return y(this.days() / 7) }, An.months = Gn, An.years = Vn, An.humanize = function (e) { if (!this.isValid()) return this.localeData().invalidDate(); var t = this.localeData(), n = function (e, t, n) { var s = Te(e).abs(), i = jn(s.as("s")), r = jn(s.as("m")), a = jn(s.as("h")), o = jn(s.as("d")), u = jn(s.as("M")), l = jn(s.as("y")), d = i <= In.ss && ["s", i] || i < In.s && ["ss", i] || r <= 1 && ["m"] || r < In.m && ["mm", r] || a <= 1 && ["h"] || a < In.h && ["hh", a] || o <= 1 && ["d"] || o < In.d && ["dd", o] || u <= 1 && ["M"] || u < In.M && ["MM", u] || l <= 1 && ["y"] || ["yy", l]; return d[2] = t, d[3] = +e > 0, d[4] = n, function (e, t, n, s, i) { return i.relativeTime(t || 1, !!n, e, s) }.apply(null, d) }(this, !e, t); return e && (n = t.pastFuture(+this, n)), t.postformat(n) }, An.toISOString = Be, An.toString = Be, An.toJSON = Be, An.locale = Fe, An.localeData = Ue, An.toIsoString = v("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Be), An.lang = gn, P("X", 0, 0, "unix"), P("x", 0, 0, "valueOf"), F("x", Mt), F("X", /[+-]?\d+(\.\d{1,3})?/), H("X", function (e, t, n) { n._d = new Date(1e3 * parseFloat(e, 10)) }), H("x", function (e, t, n) { n._d = new Date(g(e)) }), e.version = "2.19.4", function (e) { Qe = e }(pe), e.fn = Sn, e.min = function () { return we("isBefore", [].slice.call(arguments, 0)) }, e.max = function () { return we("isAfter", [].slice.call(arguments, 0)) }, e.now = function () { return Date.now ? Date.now() : +new Date }, e.utc = l, e.unix = function (e) { return pe(1e3 * e) }, e.months = function (e, t) { return je(e, t, "months") }, e.isDate = r, e.locale = ae, e.invalid = c, e.duration = Te, e.isMoment = _, e.weekdays = function (e, t, n) { return Ie(e, t, n, "weekdays") }, e.parseZone = function () { return pe.apply(null, arguments).parseZone() }, e.localeData = ue, e.isDuration = Me, e.monthsShort = function (e, t) { return je(e, t, "monthsShort") }, e.weekdaysMin = function (e, t, n) { return Ie(e, t, n, "weekdaysMin") }, e.defineLocale = oe, e.updateLocale = function (e, t) { if (null != t) { var n, s, i = Qt; null != (s = re(e)) && (i = s._config), (n = new D(t = S(i, t))).parentLocale = Xt[e], Xt[e] = n, ae(e) } else null != Xt[e] && (null != Xt[e].parentLocale ? Xt[e] = Xt[e].parentLocale : null != Xt[e] && delete Xt[e]); return Xt[e] }, e.locales = function () { return nt(Xt) }, e.weekdaysShort = function (e, t, n) { return Ie(e, t, n, "weekdaysShort") }, e.normalizeUnits = O, e.relativeTimeRounding = function (e) { return void 0 === e ? jn : "function" == typeof e && (jn = e, !0) }, e.relativeTimeThreshold = function (e, t) { return void 0 !== In[e] && (void 0 === t ? In[e] : (In[e] = t, "s" === e && (In.ss = t - 1), !0)) }, e.calendarFormat = function (e, t) { var n = e.diff(t, "days", !0); return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse" }, e.prototype = Sn, e });
/** @license React v16.4.2
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict'; (function (p, h) { "object" === typeof exports && "undefined" !== typeof module ? module.exports = h() : "function" === typeof define && define.amd ? define(h) : p.React = h() })(this, function () {
    function p(a) {
        for (var b = arguments.length - 1, f = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, d = 0; d < b; d++)f += "&args[]=" + encodeURIComponent(arguments[d + 1]); O(!1, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",
            f)
    } function h(a) { return function () { return a } } function q(a, b, f) { this.props = a; this.context = b; this.refs = D; this.updater = f || E } function F() { } function v(a, b, f) { this.props = a; this.context = b; this.refs = D; this.updater = f || E } function G(a, b, f) {
        var d = void 0, e = {}, k = null, c = null; if (null != b) for (d in void 0 !== b.ref && (c = b.ref), void 0 !== b.key && (k = "" + b.key), b) H.call(b, d) && !I.hasOwnProperty(d) && (e[d] = b[d]); var g = arguments.length - 2; if (1 === g) e.children = f; else if (1 < g) {
            for (var m = Array(g), l = 0; l < g; l++)m[l] = arguments[l + 2]; e.children =
                m
        } if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === e[d] && (e[d] = g[d]); return { $$typeof: r, type: a, key: k, ref: c, props: e, _owner: w.current }
    } function x(a) { return "object" === typeof a && null !== a && a.$$typeof === r } function P(a) { var b = { "=": "=0", ":": "=2" }; return "$" + ("" + a).replace(/[=:]/g, function (a) { return b[a] }) } function J(a, b, f, d) { if (u.length) { var e = u.pop(); e.result = a; e.keyPrefix = b; e.func = f; e.context = d; e.count = 0; return e } return { result: a, keyPrefix: b, func: f, context: d, count: 0 } } function K(a) {
        a.result = null; a.keyPrefix =
            null; a.func = null; a.context = null; a.count = 0; 10 > u.length && u.push(a)
    } function t(a, b, f, d) {
        var e = typeof a; if ("undefined" === e || "boolean" === e) a = null; var k = !1; if (null === a) k = !0; else switch (e) { case "string": case "number": k = !0; break; case "object": switch (a.$$typeof) { case r: case Q: k = !0 } }if (k) return f(d, a, "" === b ? "." + y(a, 0) : b), 1; k = 0; b = "" === b ? "." : b + ":"; if (Array.isArray(a)) for (var c = 0; c < a.length; c++) { e = a[c]; var g = b + y(e, c); k += t(e, g, f, d) } else if (null === a || "undefined" === typeof a ? g = null : (g = L && a[L] || a["@@iterator"], g = "function" ===
            typeof g ? g : null), "function" === typeof g) for (a = g.call(a), c = 0; !(e = a.next()).done;)e = e.value, g = b + y(e, c++), k += t(e, g, f, d); else "object" === e && (f = "" + a, p("31", "[object Object]" === f ? "object with keys {" + Object.keys(a).join(", ") + "}" : f, "")); return k
    } function y(a, b) { return "object" === typeof a && null !== a && null != a.key ? P(a.key) : b.toString(36) } function R(a, b, f) { a.func.call(a.context, b, a.count++) } function S(a, b, f) {
        var d = a.result, e = a.keyPrefix; a = a.func.call(a.context, b, a.count++); Array.isArray(a) ? z(a, d, f, A.thatReturnsArgument) :
            null != a && (x(a) && (b = e + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(M, "$&/") + "/") + f, a = { $$typeof: r, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner }), d.push(a))
    } function z(a, b, f, d, e) { var c = ""; null != f && (c = ("" + f).replace(M, "$&/") + "/"); b = J(b, c, d, e); null == a || t(a, "", S, b); K(b) } var N = Object.getOwnPropertySymbols, T = Object.prototype.hasOwnProperty, U = Object.prototype.propertyIsEnumerable, B = function () {
        try {
            if (!Object.assign) return !1; var a = new String("abc"); a[5] = "de"; if ("5" === Object.getOwnPropertyNames(a)[0]) return !1;
            var b = {}; for (a = 0; 10 > a; a++)b["_" + String.fromCharCode(a)] = a; if ("0123456789" !== Object.getOwnPropertyNames(b).map(function (a) { return b[a] }).join("")) return !1; var f = {}; "abcdefghijklmnopqrst".split("").forEach(function (a) { f[a] = a }); return "abcdefghijklmnopqrst" !== Object.keys(Object.assign({}, f)).join("") ? !1 : !0
        } catch (d) { return !1 }
    }() ? Object.assign : function (a, b) {
        if (null === a || void 0 === a) throw new TypeError("Object.assign cannot be called with null or undefined"); var f = Object(a); for (var d, e = 1; e < arguments.length; e++) {
            var c =
                Object(arguments[e]); for (var h in c) T.call(c, h) && (f[h] = c[h]); if (N) { d = N(c); for (var g = 0; g < d.length; g++)U.call(c, d[g]) && (f[d[g]] = c[d[g]]) }
        } return f
    }, c = "function" === typeof Symbol && Symbol.for, r = c ? Symbol.for("react.element") : 60103, Q = c ? Symbol.for("react.portal") : 60106, n = c ? Symbol.for("react.fragment") : 60107, C = c ? Symbol.for("react.strict_mode") : 60108, V = c ? Symbol.for("react.profiler") : 60114, W = c ? Symbol.for("react.provider") : 60109, X = c ? Symbol.for("react.context") : 60110, Y = c ? Symbol.for("react.async_mode") : 60111, Z =
            c ? Symbol.for("react.forward_ref") : 60112; c && Symbol.for("react.timeout"); var L = "function" === typeof Symbol && Symbol.iterator, O = function (a, b, f, d, c, k, h, g) { if (!a) { if (void 0 === b) a = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var e = [f, d, c, k, h, g], l = 0; a = Error(b.replace(/%s/g, function () { return e[l++] })); a.name = "Invariant Violation" } a.framesToPop = 1; throw a; } }, D = {}; c = function () { }; c.thatReturns = h; c.thatReturnsFalse = h(!1);
    c.thatReturnsTrue = h(!0); c.thatReturnsNull = h(null); c.thatReturnsThis = function () { return this }; c.thatReturnsArgument = function (a) { return a }; var A = c, E = { isMounted: function (a) { return !1 }, enqueueForceUpdate: function (a, b, c) { }, enqueueReplaceState: function (a, b, c, d) { }, enqueueSetState: function (a, b, c, d) { } }; q.prototype.isReactComponent = {}; q.prototype.setState = function (a, b) { "object" !== typeof a && "function" !== typeof a && null != a ? p("85") : void 0; this.updater.enqueueSetState(this, a, b, "setState") }; q.prototype.forceUpdate =
        function (a) { this.updater.enqueueForceUpdate(this, a, "forceUpdate") }; F.prototype = q.prototype; c = v.prototype = new F; c.constructor = v; B(c, q.prototype); c.isPureReactComponent = !0; var w = { current: null }, H = Object.prototype.hasOwnProperty, I = { key: !0, ref: !0, __self: !0, __source: !0 }, M = /\/+/g, u = []; n = {
            Children: {
                map: function (a, b, c) { if (null == a) return a; var d = []; z(a, d, null, b, c); return d }, forEach: function (a, b, c) { if (null == a) return a; b = J(null, null, b, c); null == a || t(a, "", R, b); K(b) }, count: function (a) {
                    return null == a ? 0 : t(a, "", A.thatReturnsNull,
                        null)
                }, toArray: function (a) { var b = []; z(a, b, null, A.thatReturnsArgument); return b }, only: function (a) { x(a) ? void 0 : p("143"); return a }
            }, createRef: function () { return { current: null } }, Component: q, PureComponent: v, createContext: function (a, b) { void 0 === b && (b = null); a = { $$typeof: X, _calculateChangedBits: b, _defaultValue: a, _currentValue: a, _currentValue2: a, _changedBits: 0, _changedBits2: 0, Provider: null, Consumer: null }; a.Provider = { $$typeof: W, _context: a }; return a.Consumer = a }, forwardRef: function (a) { return { $$typeof: Z, render: a } },
            Fragment: n, StrictMode: C, unstable_AsyncMode: Y, unstable_Profiler: V, createElement: G, cloneElement: function (a, b, c) {
                null === a || void 0 === a ? p("267", a) : void 0; var d = void 0, e = B({}, a.props), f = a.key, h = a.ref, g = a._owner; if (null != b) { void 0 !== b.ref && (h = b.ref, g = w.current); void 0 !== b.key && (f = "" + b.key); var m = void 0; a.type && a.type.defaultProps && (m = a.type.defaultProps); for (d in b) H.call(b, d) && !I.hasOwnProperty(d) && (e[d] = void 0 === b[d] && void 0 !== m ? m[d] : b[d]) } d = arguments.length - 2; if (1 === d) e.children = c; else if (1 < d) {
                    m = Array(d);
                    for (var l = 0; l < d; l++)m[l] = arguments[l + 2]; e.children = m
                } return { $$typeof: r, type: a.type, key: f, ref: h, props: e, _owner: g }
            }, createFactory: function (a) { var b = G.bind(null, a); b.type = a; return b }, isValidElement: x, version: "16.4.2", __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: w, assign: B }
        }; n = (C = { default: n }, n) || C; return n.default ? n.default : n
});

/** @license React v16.4.2
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict'; (function (ma, m) { "object" === typeof exports && "undefined" !== typeof module ? module.exports = m(require("react")) : "function" === typeof define && define.amd ? define(["react"], m) : ma.ReactDOM = m(ma.React) })(this, function (ma) {
    function m(a) {
        for (var b = arguments.length - 1, c = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, d = 0; d < b; d++)c += "&args[]=" + encodeURIComponent(arguments[d + 1]); Tg(!1, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",
            c)
    } function Sd() { if (Eb) for (var a in ua) { var b = ua[a], c = Eb.indexOf(a); -1 < c ? void 0 : m("96", a); if (!Ua[c]) { b.extractEvents ? void 0 : m("97", a); Ua[c] = b; c = b.eventTypes; for (var d in c) { var e = void 0; var f = c[d], g = b, h = d; vc.hasOwnProperty(h) ? m("99", h) : void 0; vc[h] = f; var k = f.phasedRegistrationNames; if (k) { for (e in k) k.hasOwnProperty(e) && Td(k[e], g, h); e = !0 } else f.registrationName ? (Td(f.registrationName, g, h), e = !0) : e = !1; e ? void 0 : m("98", d, a) } } } } function Td(a, b, c) { na[a] ? m("100", a) : void 0; na[a] = b; Fb[a] = b.eventTypes[c].dependencies }
    function Ud(a) { Eb ? m("101") : void 0; Eb = Array.prototype.slice.call(a); Sd() } function Vd(a) { var b = !1, c; for (c in a) if (a.hasOwnProperty(c)) { var d = a[c]; ua.hasOwnProperty(c) && ua[c] === d || (ua[c] ? m("102", c) : void 0, ua[c] = d, b = !0) } b && Sd() } function Gb(a) { return function () { return a } } function Wd(a, b, c, d) { b = a.type || "unknown-event"; a.currentTarget = Xd(d); r.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a); a.currentTarget = null } function va(a, b) {
        null == b ? m("30") : void 0; if (null == a) return b; if (Array.isArray(a)) {
            if (Array.isArray(b)) return a.push.apply(a,
                b), a; a.push(b); return a
        } return Array.isArray(b) ? [a].concat(b) : [a, b]
    } function Va(a, b, c) { Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a) } function wc(a, b) {
        var c = a.stateNode; if (!c) return null; var d = xc(c); if (!d) return null; c = d[b]; a: switch (b) {
            case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" ===
                a || "select" === a || "textarea" === a)); a = !d; break a; default: a = !1
        }if (a) return null; c && "function" !== typeof c ? m("231", b, typeof c) : void 0; return c
    } function yc(a, b) { null !== a && (Wa = va(Wa, a)); a = Wa; Wa = null; a && (b ? Va(a, Ug) : Va(a, Vg), Wa ? m("95") : void 0, r.rethrowCaughtError()) } function Yd(a, b, c, d) { for (var e = null, f = 0; f < Ua.length; f++) { var g = Ua[f]; g && (g = g.extractEvents(a, b, c, d)) && (e = va(e, g)) } yc(e, !1) } function Zd(a, b) { b[wa] = a } function Xa(a) {
        if (a[wa]) return a[wa]; for (; !a[wa];)if (a.parentNode) a = a.parentNode; else return null;
        a = a[wa]; return 5 === a.tag || 6 === a.tag ? a : null
    } function xa(a) { if (5 === a.tag || 6 === a.tag) return a.stateNode; m("33") } function $d(a) { return a[ae] || null } function be(a, b) { a[ae] = b } function S(a) { do a = a.return; while (a && 5 !== a.tag); return a ? a : null } function ce(a, b, c) { for (var d = []; a;)d.push(a), a = S(a); for (a = d.length; 0 < a--;)b(d[a], "captured", c); for (a = 0; a < d.length; a++)b(d[a], "bubbled", c) } function de(a, b, c) {
        if (b = wc(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = va(c._dispatchListeners, b), c._dispatchInstances =
            va(c._dispatchInstances, a)
    } function Wg(a) { a && a.dispatchConfig.phasedRegistrationNames && ce(a._targetInst, de, a) } function Xg(a) { if (a && a.dispatchConfig.phasedRegistrationNames) { var b = a._targetInst; b = b ? S(b) : null; ce(b, de, a) } } function zc(a, b, c) { a && c && c.dispatchConfig.registrationName && (b = wc(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = va(c._dispatchListeners, b), c._dispatchInstances = va(c._dispatchInstances, a)) } function Yg(a) { a && a.dispatchConfig.registrationName && zc(a._targetInst, null, a) } function ya(a) {
        Va(a,
            Wg)
    } function ee(a, b, c, d) { if (c && d) a: { var e = c; for (var f = d, g = 0, h = e; h; h = S(h))g++; h = 0; for (var k = f; k; k = S(k))h++; for (; 0 < g - h;)e = S(e), g--; for (; 0 < h - g;)f = S(f), h--; for (; g--;) { if (e === f || e === f.alternate) break a; e = S(e); f = S(f) } e = null } else e = null; f = e; for (e = []; c && c !== f;) { g = c.alternate; if (null !== g && g === f) break; e.push(c); c = S(c) } for (c = []; d && d !== f;) { g = d.alternate; if (null !== g && g === f) break; c.push(d); d = S(d) } for (d = 0; d < e.length; d++)zc(e[d], "bubbled", a); for (a = c.length; 0 < a--;)zc(c[a], "captured", b) } function Hb(a, b) {
        var c = {}; c[a.toLowerCase()] =
            b.toLowerCase(); c["Webkit" + a] = "webkit" + b; c["Moz" + a] = "moz" + b; c["ms" + a] = "MS" + b; c["O" + a] = "o" + b.toLowerCase(); return c
    } function Ib(a) { if (Ac[a]) return Ac[a]; if (!za[a]) return a; var b = za[a], c; for (c in b) if (b.hasOwnProperty(c) && c in fe) return Ac[a] = b[c]; return a } function ge() { !Bc && T.canUseDOM && (Bc = "textContent" in document.documentElement ? "textContent" : "innerText"); return Bc } function he() {
        if (z._fallbackText) return z._fallbackText; var a, b = z._startText, c = b.length, d, e = ie(), f = e.length; for (a = 0; a < c && b[a] === e[a]; a++);
        var g = c - a; for (d = 1; d <= g && b[c - d] === e[f - d]; d++); z._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0); return z._fallbackText
    } function ie() { return "value" in z._root ? z._root.value : z._root[ge()] } function L(a, b, c, d) {
        this.dispatchConfig = a; this._targetInst = b; this.nativeEvent = c; a = this.constructor.Interface; for (var e in a) a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]); this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? M.thatReturnsTrue : M.thatReturnsFalse;
        this.isPropagationStopped = M.thatReturnsFalse; return this
    } function Zg(a, b, c, d) { if (this.eventPool.length) { var e = this.eventPool.pop(); this.call(e, a, b, c, d); return e } return new this(a, b, c, d) } function $g(a) { a instanceof this ? void 0 : m("223"); a.destructor(); 10 > this.eventPool.length && this.eventPool.push(a) } function je(a) { a.eventPool = []; a.getPooled = Zg; a.release = $g } function ke(a, b) {
        switch (a) {
            case "keyup": return -1 !== ah.indexOf(b.keyCode); case "keydown": return 229 !== b.keyCode; case "keypress": case "mousedown": case "blur": return !0;
            default: return !1
        }
    } function le(a) { a = a.detail; return "object" === typeof a && "data" in a ? a.data : null } function bh(a, b) { switch (a) { case "compositionend": return le(b); case "keypress": if (32 !== b.which) return null; me = !0; return ne; case "textInput": return a = b.data, a === ne && me ? null : a; default: return null } } function ch(a, b) {
        if (Aa) return "compositionend" === a || !Cc && ke(a, b) ? (a = he(), z._root = null, z._startText = null, z._fallbackText = null, Aa = !1, a) : null; switch (a) {
            case "paste": return null; case "keypress": if (!(b.ctrlKey || b.altKey ||
                b.metaKey) || b.ctrlKey && b.altKey) { if (b.char && 1 < b.char.length) return b.char; if (b.which) return String.fromCharCode(b.which) } return null; case "compositionend": return oe ? null : b.data; default: return null
        }
    } function pe(a) { if (a = qe(a)) { Jb && "function" === typeof Jb.restoreControlledState ? void 0 : m("194"); var b = xc(a.stateNode); Jb.restoreControlledState(a.stateNode, a.type, b) } } function re(a) { Ba ? Ca ? Ca.push(a) : Ca = [a] : Ba = a } function se() { return null !== Ba || null !== Ca } function te() {
        if (Ba) {
            var a = Ba, b = Ca; Ca = Ba = null; pe(a); if (b) for (a =
                0; a < b.length; a++)pe(b[a])
        }
    } function ue(a, b) { if (Dc) return a(b); Dc = !0; try { return ve(a, b) } finally { Dc = !1, se() && (we(), te()) } } function xe(a) { var b = a && a.nodeName && a.nodeName.toLowerCase(); return "input" === b ? !!dh[a.type] : "textarea" === b ? !0 : !1 } function Ec(a) { a = a.target || a.srcElement || window; a.correspondingUseElement && (a = a.correspondingUseElement); return 3 === a.nodeType ? a.parentNode : a } function ye(a, b) {
        if (!T.canUseDOM || b && !("addEventListener" in document)) return !1; a = "on" + a; b = a in document; b || (b = document.createElement("div"),
            b.setAttribute(a, "return;"), b = "function" === typeof b[a]); return b
    } function ze(a) { var b = a.type; return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b) } function eh(a) {
        var b = ze(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b]; if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
            var e = c.get, f = c.set; Object.defineProperty(a, b, {
                configurable: !0, get: function () { return e.call(this) }, set: function (a) {
                    d =
                        "" + a; f.call(this, a)
                }
            }); Object.defineProperty(a, b, { enumerable: c.enumerable }); return { getValue: function () { return d }, setValue: function (a) { d = "" + a }, stopTracking: function () { a._valueTracker = null; delete a[b] } }
        }
    } function Kb(a) { a._valueTracker || (a._valueTracker = eh(a)) } function Ae(a) { if (!a) return !1; var b = a._valueTracker; if (!b) return !0; var c = b.getValue(); var d = ""; a && (d = ze(a) ? a.checked ? "true" : "false" : a.value); a = d; return a !== c ? (b.setValue(a), !0) : !1 } function Ya(a) {
        if (null === a || "undefined" === typeof a) return null;
        a = Be && a[Be] || a["@@iterator"]; return "function" === typeof a ? a : null
    } function Za(a) {
        var b = a.type; if ("function" === typeof b) return b.displayName || b.name; if ("string" === typeof b) return b; switch (b) { case Ce: return "AsyncMode"; case De: return "Context.Consumer"; case ea: return "ReactFragment"; case Da: return "ReactPortal"; case Fc: return "Profiler(" + a.pendingProps.id + ")"; case Ee: return "Context.Provider"; case Fe: return "StrictMode"; case Ge: return "Timeout" }if ("object" === typeof b && null !== b) switch (b.$$typeof) {
            case He: return a =
                b.render.displayName || b.render.name || "", "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef"
        }return null
    } function Ie(a) { var b = ""; do { a: switch (a.tag) { case 0: case 1: case 2: case 5: var c = a._debugOwner, d = a._debugSource; var e = Za(a); var f = null; c && (f = Za(c)); c = d; e = "\n    in " + (e || "Unknown") + (c ? " (at " + c.fileName.replace(/^.*[\\\/]/, "") + ":" + c.lineNumber + ")" : f ? " (created by " + f + ")" : ""); break a; default: e = "" }b += e; a = a.return } while (a); return b } function fh(a) {
        if (Je.call(Ke, a)) return !0; if (Je.call(Le, a)) return !1; if (gh.test(a)) return Ke[a] =
            !0; Le[a] = !0; return !1
    } function hh(a, b, c, d) { if (null !== c && 0 === c.type) return !1; switch (typeof b) { case "function": case "symbol": return !0; case "boolean": if (d) return !1; if (null !== c) return !c.acceptsBooleans; a = a.toLowerCase().slice(0, 5); return "data-" !== a && "aria-" !== a; default: return !1 } } function ih(a, b, c, d) { if (null === b || "undefined" === typeof b || hh(a, b, c, d)) return !0; if (d) return !1; if (null !== c) switch (c.type) { case 3: return !b; case 4: return !1 === b; case 5: return isNaN(b); case 6: return isNaN(b) || 1 > b }return !1 } function N(a,
        b, c, d, e) { this.acceptsBooleans = 2 === b || 3 === b || 4 === b; this.attributeName = d; this.attributeNamespace = e; this.mustUseProperty = c; this.propertyName = a; this.type = b } function Gc(a, b, c, d) {
            var e = u.hasOwnProperty(b) ? u[b] : null; var f = null !== e ? 0 === e.type : d ? !1 : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? !1 : !0; f || (ih(b, c, e, d) && (c = null), d || null === e ? fh(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace,
                null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))))
        } function Hc(a, b) { var c = b.checked; return G({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked }) } function Me(a, b) {
            var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked; c = Ic(null != b.value ? b.value : c); a._wrapperState = {
                initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" ===
                    b.type ? null != b.checked : null != b.value
            }
        } function Ne(a, b) { b = b.checked; null != b && Gc(a, "checked", b, !1) } function Jc(a, b) { Ne(a, b); var c = Ic(b.value); if (null != c) if ("number" === b.type) { if (0 === c && "" === a.value || a.value != c) a.value = "" + c } else a.value !== "" + c && (a.value = "" + c); b.hasOwnProperty("value") ? Kc(a, b.type, c) : b.hasOwnProperty("defaultValue") && Kc(a, b.type, Ic(b.defaultValue)); null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked) } function Oe(a, b, c) {
            if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
                b =
                    "" + a._wrapperState.initialValue; var d = a.value; c || b === d || (a.value = b); a.defaultValue = b
            } c = a.name; "" !== c && (a.name = ""); a.defaultChecked = !a.defaultChecked; a.defaultChecked = !a.defaultChecked; "" !== c && (a.name = c)
        } function Kc(a, b, c) { if ("number" !== b || a.ownerDocument.activeElement !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c) } function Ic(a) { switch (typeof a) { case "boolean": case "number": case "object": case "string": case "undefined": return a; default: return "" } }
    function Pe(a, b, c) { a = L.getPooled(Qe.change, a, b, c); a.type = "change"; re(c); ya(a); return a } function jh(a) { yc(a, !1) } function Lb(a) { var b = xa(a); if (Ae(b)) return a } function kh(a, b) { if ("change" === a) return b } function Re() { $a && ($a.detachEvent("onpropertychange", Se), ab = $a = null) } function Se(a) { "value" === a.propertyName && Lb(ab) && (a = Pe(ab, a, Ec(a)), ue(jh, a)) } function lh(a, b, c) { "focus" === a ? (Re(), $a = b, ab = c, $a.attachEvent("onpropertychange", Se)) : "blur" === a && Re() } function mh(a, b) {
        if ("selectionchange" === a || "keyup" === a ||
            "keydown" === a) return Lb(ab)
    } function nh(a, b) { if ("click" === a) return Lb(b) } function oh(a, b) { if ("input" === a || "change" === a) return Lb(b) } function ph(a) { var b = this.nativeEvent; return b.getModifierState ? b.getModifierState(a) : (a = qh[a]) ? !!b[a] : !1 } function Lc(a) { return ph } function Te(a, b) { return a === b ? 0 !== a || 0 !== b || 1 / a === 1 / b : a !== a && b !== b } function bb(a) {
        var b = a; if (a.alternate) for (; b.return;)b = b.return; else { if (0 !== (b.effectTag & 2)) return 1; for (; b.return;)if (b = b.return, 0 !== (b.effectTag & 2)) return 1 } return 3 === b.tag ?
            2 : 3
    } function Ue(a) { 2 !== bb(a) ? m("188") : void 0 } function Ve(a) {
        var b = a.alternate; if (!b) return b = bb(a), 3 === b ? m("188") : void 0, 1 === b ? null : a; for (var c = a, d = b; ;) {
            var e = c.return, f = e ? e.alternate : null; if (!e || !f) break; if (e.child === f.child) { for (var g = e.child; g;) { if (g === c) return Ue(e), a; if (g === d) return Ue(e), b; g = g.sibling } m("188") } if (c.return !== d.return) c = e, d = f; else {
                g = !1; for (var h = e.child; h;) { if (h === c) { g = !0; c = e; d = f; break } if (h === d) { g = !0; d = e; c = f; break } h = h.sibling } if (!g) {
                    for (h = f.child; h;) {
                        if (h === c) { g = !0; c = f; d = e; break } if (h ===
                            d) { g = !0; d = f; c = e; break } h = h.sibling
                    } g ? void 0 : m("189")
                }
            } c.alternate !== d ? m("190") : void 0
        } 3 !== c.tag ? m("188") : void 0; return c.stateNode.current === c ? a : b
    } function We(a) { a = Ve(a); if (!a) return null; for (var b = a; ;) { if (5 === b.tag || 6 === b.tag) return b; if (b.child) b.child.return = b, b = b.child; else { if (b === a) break; for (; !b.sibling;) { if (!b.return || b.return === a) return null; b = b.return } b.sibling.return = b.return; b = b.sibling } } return null } function rh(a) {
        a = Ve(a); if (!a) return null; for (var b = a; ;) {
            if (5 === b.tag || 6 === b.tag) return b;
            if (b.child && 4 !== b.tag) b.child.return = b, b = b.child; else { if (b === a) break; for (; !b.sibling;) { if (!b.return || b.return === a) return null; b = b.return } b.sibling.return = b.return; b = b.sibling }
        } return null
    } function Mb(a) { var b = a.keyCode; "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b; 10 === a && (a = 13); return 32 <= a || 13 === a ? a : 0 } function Xe(a, b) {
        var c = a[0]; a = a[1]; var d = "on" + (a[0].toUpperCase() + a.slice(1)); b = { phasedRegistrationNames: { bubbled: d, captured: d + "Capture" }, dependencies: [c], isInteractive: b }; Ye[a] = b; Mc[c] =
            b
    } function sh(a) { var b = a.targetInst; do { if (!b) { a.ancestors.push(b); break } var c; for (c = b; c.return;)c = c.return; c = 3 !== c.tag ? null : c.stateNode.containerInfo; if (!c) break; a.ancestors.push(b); b = Xa(c) } while (b); for (c = 0; c < a.ancestors.length; c++)b = a.ancestors[c], Yd(a.topLevelType, b, a.nativeEvent, Ec(a.nativeEvent)) } function Nc(a) { cb = !!a } function p(a, b) { if (!b) return null; var c = (Ze(a) ? $e : Nb).bind(null, a); b.addEventListener(a, c, !1) } function db(a, b) {
        if (!b) return null; var c = (Ze(a) ? $e : Nb).bind(null, a); b.addEventListener(a,
            c, !0)
    } function $e(a, b) { af(Nb, a, b) } function Nb(a, b) { if (cb) { var c = Ec(b); c = Xa(c); null === c || "number" !== typeof c.tag || 2 === bb(c) || (c = null); if (Ob.length) { var d = Ob.pop(); d.topLevelType = a; d.nativeEvent = b; d.targetInst = c; a = d } else a = { topLevelType: a, nativeEvent: b, targetInst: c, ancestors: [] }; try { ue(sh, a) } finally { a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > Ob.length && Ob.push(a) } } } function bf(a) { Object.prototype.hasOwnProperty.call(a, Pb) || (a[Pb] = th++, cf[a[Pb]] = {}); return cf[a[Pb]] }
    function df(a, b) { return a && b ? a === b ? !0 : ef(a) ? !1 : ef(b) ? df(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1 } function ff(a) { for (; a && a.firstChild;)a = a.firstChild; return a } function gf(a, b) { var c = ff(a); a = 0; for (var d; c;) { if (3 === c.nodeType) { d = a + c.textContent.length; if (a <= b && d >= b) return { node: c, offset: b - a }; a = d } a: { for (; c;) { if (c.nextSibling) { c = c.nextSibling; break a } c = c.parentNode } c = void 0 } c = ff(c) } } function Oc(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable)
    } function hf(a, b) {
        if (Pc || null == Ea || Ea !== Qc()) return null; var c = Ea; "selectionStart" in c && Oc(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : window.getSelection ? (c = window.getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }) : c = void 0; return eb && Rc(eb, c) ? null : (eb = c, a = L.getPooled(jf.select,
            Sc, a, b), a.type = "select", a.target = Ea, ya(a), a)
    } function uh(a) { var b = ""; ma.Children.forEach(a, function (a) { null == a || "string" !== typeof a && "number" !== typeof a || (b += a) }); return b } function Tc(a, b) { a = G({ children: void 0 }, b); if (b = uh(b.children)) a.children = b; return a } function Fa(a, b, c, d) {
        a = a.options; if (b) { b = {}; for (var e = 0; e < c.length; e++)b["$" + c[e]] = !0; for (c = 0; c < a.length; c++)e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0) } else {
            c = "" + c; b = null; for (e = 0; e < a.length; e++) {
                if (a[e].value ===
                    c) { a[e].selected = !0; d && (a[e].defaultSelected = !0); return } null !== b || a[e].disabled || (b = a[e])
            } null !== b && (b.selected = !0)
        }
    } function kf(a, b) { var c = b.value; a._wrapperState = { initialValue: null != c ? c : b.defaultValue, wasMultiple: !!b.multiple } } function Uc(a, b) { null != b.dangerouslySetInnerHTML ? m("91") : void 0; return G({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue }) } function lf(a, b) {
        var c = b.value; null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? m("92") : void 0, Array.isArray(b) &&
            (1 >= b.length ? void 0 : m("93"), b = b[0]), c = "" + b), null == c && (c = "")); a._wrapperState = { initialValue: "" + c }
    } function mf(a, b) { var c = b.value; null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c)); null != b.defaultValue && (a.defaultValue = b.defaultValue) } function nf(a) { switch (a) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Vc(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" ===
            a ? nf(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a
    } function of(a, b, c) { a = a.style; for (var d in b) if (b.hasOwnProperty(d)) { c = 0 === d.indexOf("--"); var e = d; var f = b[d]; e = null == f || "boolean" === typeof f || "" === f ? "" : c || "number" !== typeof f || 0 === f || fb.hasOwnProperty(e) && fb[e] ? ("" + f).trim() : f + "px"; "float" === d && (d = "cssFloat"); c ? a.setProperty(d, e) : a[d] = e } } function Wc(a, b, c) {
        b && (vh[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? m("137", a, c()) : void 0), null != b.dangerouslySetInnerHTML &&
            (null != b.children ? m("60") : void 0, "object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML ? void 0 : m("61")), null != b.style && "object" !== typeof b.style ? m("62", c()) : void 0)
    } function Xc(a, b) { if (-1 === a.indexOf("-")) return "string" === typeof b.is; switch (a) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } function W(a, b) {
        a = 9 === a.nodeType ||
            11 === a.nodeType ? a : a.ownerDocument; var c = bf(a); b = Fb[b]; for (var d = 0; d < b.length; d++) { var e = b[d]; if (!c.hasOwnProperty(e) || !c[e]) { switch (e) { case "scroll": db("scroll", a); break; case "focus": case "blur": db("focus", a); db("blur", a); c.blur = !0; c.focus = !0; break; case "cancel": case "close": ye(e, !0) && db(e, a); break; case "invalid": case "submit": case "reset": break; default: -1 === gb.indexOf(e) && p(e, a) }c[e] = !0 } }
    } function pf(a, b, c, d) {
        c = 9 === c.nodeType ? c : c.ownerDocument; "http://www.w3.org/1999/xhtml" === d && (d = nf(a)); "http://www.w3.org/1999/xhtml" ===
            d ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, { is: b.is }) : c.createElement(a) : a = c.createElementNS(d, a); return a
    } function qf(a, b) { return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a) } function rf(a, b, c, d) {
        var e = Xc(b, c); switch (b) {
            case "iframe": case "object": p("load", a); var f = c; break; case "video": case "audio": for (f = 0; f < gb.length; f++)p(gb[f], a); f = c; break; case "source": p("error", a); f = c; break; case "img": case "image": case "link": p("error",
                a); p("load", a); f = c; break; case "form": p("reset", a); p("submit", a); f = c; break; case "details": p("toggle", a); f = c; break; case "input": Me(a, c); f = Hc(a, c); p("invalid", a); W(d, "onChange"); break; case "option": f = Tc(a, c); break; case "select": kf(a, c); f = G({}, c, { value: void 0 }); p("invalid", a); W(d, "onChange"); break; case "textarea": lf(a, c); f = Uc(a, c); p("invalid", a); W(d, "onChange"); break; default: f = c
        }Wc(b, f, hb); var g = f, h; for (h in g) if (g.hasOwnProperty(h)) {
            var k = g[h]; "style" === h ? of(a, k, hb) : "dangerouslySetInnerHTML" === h ? (k =
                k ? k.__html : void 0, null != k && sf(a, k)) : "children" === h ? "string" === typeof k ? ("textarea" !== b || "" !== k) && ib(a, k) : "number" === typeof k && ib(a, "" + k) : "suppressContentEditableWarning" !== h && "suppressHydrationWarning" !== h && "autoFocus" !== h && (na.hasOwnProperty(h) ? null != k && W(d, h) : null != k && Gc(a, h, k, e))
        } switch (b) {
            case "input": Kb(a); Oe(a, c, !1); break; case "textarea": Kb(a); c = a.textContent; c === a._wrapperState.initialValue && (a.value = c); break; case "option": null != c.value && a.setAttribute("value", c.value); break; case "select": a.multiple =
                !!c.multiple; b = c.value; null != b ? Fa(a, !!c.multiple, b, !1) : null != c.defaultValue && Fa(a, !!c.multiple, c.defaultValue, !0); break; default: "function" === typeof f.onClick && (a.onclick = M)
        }
    } function tf(a, b, c, d, e) {
        var f = null; switch (b) {
            case "input": c = Hc(a, c); d = Hc(a, d); f = []; break; case "option": c = Tc(a, c); d = Tc(a, d); f = []; break; case "select": c = G({}, c, { value: void 0 }); d = G({}, d, { value: void 0 }); f = []; break; case "textarea": c = Uc(a, c); d = Uc(a, d); f = []; break; default: "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick =
                M)
        }Wc(b, d, hb); b = a = void 0; var g = null; for (a in c) if (!d.hasOwnProperty(a) && c.hasOwnProperty(a) && null != c[a]) if ("style" === a) { var h = c[a]; for (b in h) h.hasOwnProperty(b) && (g || (g = {}), g[b] = "") } else "dangerouslySetInnerHTML" !== a && "children" !== a && "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (na.hasOwnProperty(a) ? f || (f = []) : (f = f || []).push(a, null)); for (a in d) {
            var k = d[a]; h = null != c ? c[a] : void 0; if (d.hasOwnProperty(a) && k !== h && (null != k || null != h)) if ("style" === a) if (h) {
                for (b in h) !h.hasOwnProperty(b) ||
                    k && k.hasOwnProperty(b) || (g || (g = {}), g[b] = ""); for (b in k) k.hasOwnProperty(b) && h[b] !== k[b] && (g || (g = {}), g[b] = k[b])
            } else g || (f || (f = []), f.push(a, g)), g = k; else "dangerouslySetInnerHTML" === a ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(a, "" + k)) : "children" === a ? h === k || "string" !== typeof k && "number" !== typeof k || (f = f || []).push(a, "" + k) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && (na.hasOwnProperty(a) ? (null != k && W(e, a), f || h === k || (f = [])) : (f = f || []).push(a, k))
        } g && (f =
            f || []).push("style", g); return f
    } function uf(a, b, c, d, e) {
        "input" === c && "radio" === e.type && null != e.name && Ne(a, e); Xc(c, d); d = Xc(c, e); for (var f = 0; f < b.length; f += 2) { var g = b[f], h = b[f + 1]; "style" === g ? of(a, h, hb) : "dangerouslySetInnerHTML" === g ? sf(a, h) : "children" === g ? ib(a, h) : Gc(a, g, h, d) } switch (c) {
            case "input": Jc(a, e); break; case "textarea": mf(a, e); break; case "select": a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, c = e.value, null != c ? Fa(a, !!e.multiple, c, !1) :
                b !== !!e.multiple && (null != e.defaultValue ? Fa(a, !!e.multiple, e.defaultValue, !0) : Fa(a, !!e.multiple, e.multiple ? [] : "", !1))
        }
    } function vf(a, b, c, d, e) {
        switch (b) {
            case "iframe": case "object": p("load", a); break; case "video": case "audio": for (d = 0; d < gb.length; d++)p(gb[d], a); break; case "source": p("error", a); break; case "img": case "image": case "link": p("error", a); p("load", a); break; case "form": p("reset", a); p("submit", a); break; case "details": p("toggle", a); break; case "input": Me(a, c); p("invalid", a); W(e, "onChange"); break;
            case "select": kf(a, c); p("invalid", a); W(e, "onChange"); break; case "textarea": lf(a, c), p("invalid", a), W(e, "onChange")
        }Wc(b, c, hb); d = null; for (var f in c) if (c.hasOwnProperty(f)) { var g = c[f]; "children" === f ? "string" === typeof g ? a.textContent !== g && (d = ["children", g]) : "number" === typeof g && a.textContent !== "" + g && (d = ["children", "" + g]) : na.hasOwnProperty(f) && null != g && W(e, f) } switch (b) {
            case "input": Kb(a); Oe(a, c, !0); break; case "textarea": Kb(a); b = a.textContent; b === a._wrapperState.initialValue && (a.value = b); break; case "select": case "option": break;
            default: "function" === typeof c.onClick && (a.onclick = M)
        }return d
    } function wf(a, b) { return a.nodeValue !== b } function xf(a, b) { switch (a) { case "button": case "input": case "select": case "textarea": return !!b.autoFocus }return !1 } function Yc(a, b) { return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html } function Zc(a) {
        for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !==
            a.nodeType;)a = a.nextSibling; return a
    } function yf(a) { for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType;)a = a.nextSibling; return a } function fa(a) { return { current: a } } function v(a, b) { 0 > Ga || (a.current = $c[Ga], $c[Ga] = null, Ga--) } function y(a, b, c) { Ga++; $c[Ga] = a.current; a.current = b } function Ha(a) { return jb(a) ? ad : X.current } function Ia(a, b) {
        var c = a.type.contextTypes; if (!c) return Y; var d = a.stateNode; if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext; var e =
            {}, f; for (f in c) e[f] = b[f]; d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e); return e
    } function jb(a) { return 2 === a.tag && null != a.type.childContextTypes } function bd(a) { jb(a) && (v(x, a), v(X, a)) } function cd(a) { v(x, a); v(X, a) } function zf(a, b, c) { X.current !== Y ? m("168") : void 0; y(X, b, a); y(x, c, a) } function Af(a, b) {
        var c = a.stateNode, d = a.type.childContextTypes; if ("function" !== typeof c.getChildContext) return b; c = c.getChildContext(); for (var e in c) e in d ?
            void 0 : m("108", Za(a) || "Unknown", e); return G({}, b, c)
    } function dd(a) { if (!jb(a)) return !1; var b = a.stateNode; b = b && b.__reactInternalMemoizedMergedChildContext || Y; ad = X.current; y(X, b, a); y(x, x.current, a); return !0 } function Bf(a, b) { var c = a.stateNode; c ? void 0 : m("169"); if (b) { var d = Af(a, ad); c.__reactInternalMemoizedMergedChildContext = d; v(x, a); v(X, a); y(X, d, a) } else v(x, a); y(x, b, a) } function ha(a, b, c, d) {
        this.tag = a; this.key = c; this.sibling = this.child = this.return = this.stateNode = this.type = null; this.index = 0; this.ref = null;
        this.pendingProps = b; this.memoizedState = this.updateQueue = this.memoizedProps = null; this.mode = d; this.effectTag = 0; this.lastEffect = this.firstEffect = this.nextEffect = null; this.expirationTime = 0; this.alternate = null
    } function Qb(a, b, c) {
        var d = a.alternate; null === d ? (d = new ha(a.tag, b, a.key, a.mode), d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.pendingProps = b, d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, d.lastEffect = null); d.expirationTime = c; d.child = a.child; d.memoizedProps = a.memoizedProps;
        d.memoizedState = a.memoizedState; d.updateQueue = a.updateQueue; d.sibling = a.sibling; d.index = a.index; d.ref = a.ref; return d
    } function ed(a, b, c) {
        var d = a.type, e = a.key; a = a.props; if ("function" === typeof d) var f = d.prototype && d.prototype.isReactComponent ? 2 : 0; else if ("string" === typeof d) f = 5; else switch (d) {
            case ea: return Rb(a.children, b, c, e); case Ce: f = 11; b |= 3; break; case Fe: f = 11; b |= 2; break; case Fc: return d = new ha(15, a, e, b | 4), d.type = Fc, d.expirationTime = c, d; case Ge: f = 16; b |= 2; break; default: a: {
                switch ("object" === typeof d &&
                    null !== d ? d.$$typeof : null) { case Ee: f = 13; break a; case De: f = 12; break a; case He: f = 14; break a; default: m("130", null == d ? d : typeof d, "") }f = void 0
            }
        }b = new ha(f, a, e, b); b.type = d; b.expirationTime = c; return b
    } function Rb(a, b, c, d) { a = new ha(10, a, d, b); a.expirationTime = c; return a } function fd(a, b, c) { a = new ha(6, a, null, b); a.expirationTime = c; return a } function gd(a, b, c) {
        b = new ha(4, null !== a.children ? a.children : [], a.key, b); b.expirationTime = c; b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b
    } function Cf(a, b, c) { b = new ha(3, null, null, b ? 3 : 0); a = { current: b, containerInfo: a, pendingChildren: null, earliestPendingTime: 0, latestPendingTime: 0, earliestSuspendedTime: 0, latestSuspendedTime: 0, latestPingedTime: 0, pendingCommitExpirationTime: 0, finishedWork: null, context: null, pendingContext: null, hydrate: c, remainingExpirationTime: 0, firstBatch: null, nextScheduledRoot: null }; return b.stateNode = a } function Df(a) { return function (b) { try { return a(b) } catch (c) { } } } function wh(a) {
        if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
        var b = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (b.isDisabled || !b.supportsFiber) return !0; try { var c = b.inject(a); hd = Df(function (a) { return b.onCommitFiberRoot(c, a) }); id = Df(function (a) { return b.onCommitFiberUnmount(c, a) }) } catch (d) { } return !0
    } function Ef(a) { "function" === typeof hd && hd(a) } function Ff(a) { "function" === typeof id && id(a) } function Sb(a) {
        return {
            expirationTime: 0, baseState: a, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null,
            lastCapturedEffect: null
        }
    } function jd(a) { return { expirationTime: a.expirationTime, baseState: a.baseState, firstUpdate: a.firstUpdate, lastUpdate: a.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null } } function Ja(a) { return { expirationTime: a, tag: 0, payload: null, callback: null, next: null, nextEffect: null } } function Tb(a, b, c) {
        null === a.lastUpdate ? a.firstUpdate = a.lastUpdate = b : (a.lastUpdate.next = b, a.lastUpdate = b); if (0 === a.expirationTime ||
            a.expirationTime > c) a.expirationTime = c
    } function oa(a, b, c) { var d = a.alternate; if (null === d) { var e = a.updateQueue; var f = null; null === e && (e = a.updateQueue = Sb(a.memoizedState)) } else e = a.updateQueue, f = d.updateQueue, null === e ? null === f ? (e = a.updateQueue = Sb(a.memoizedState), f = d.updateQueue = Sb(d.memoizedState)) : e = a.updateQueue = jd(f) : null === f && (f = d.updateQueue = jd(e)); null === f || e === f ? Tb(e, b, c) : null === e.lastUpdate || null === f.lastUpdate ? (Tb(e, b, c), Tb(f, b, c)) : (Tb(e, b, c), f.lastUpdate = b) } function Gf(a, b, c) {
        var d = a.updateQueue;
        d = null === d ? a.updateQueue = Sb(a.memoizedState) : Hf(a, d); null === d.lastCapturedUpdate ? d.firstCapturedUpdate = d.lastCapturedUpdate = b : (d.lastCapturedUpdate.next = b, d.lastCapturedUpdate = b); if (0 === d.expirationTime || d.expirationTime > c) d.expirationTime = c
    } function Hf(a, b) { var c = a.alternate; null !== c && b === c.updateQueue && (b = a.updateQueue = jd(b)); return b } function If(a, b, c, d, e, f) {
        switch (c.tag) {
            case 1: return a = c.payload, "function" === typeof a ? a.call(f, d, e) : a; case 3: a.effectTag = a.effectTag & -1025 | 64; case 0: a = c.payload;
                e = "function" === typeof a ? a.call(f, d, e) : a; if (null === e || void 0 === e) break; return G({}, d, e); case 2: ia = !0
        }return d
    } function kb(a, b, c, d, e) {
        ia = !1; if (!(0 === b.expirationTime || b.expirationTime > e)) {
            b = Hf(a, b); for (var f = b.baseState, g = null, h = 0, k = b.firstUpdate, m = f; null !== k;) {
                var l = k.expirationTime; if (l > e) { if (null === g && (g = k, f = m), 0 === h || h > l) h = l } else m = If(a, b, k, m, c, d), null !== k.callback && (a.effectTag |= 32, k.nextEffect = null, null === b.lastEffect ? b.firstEffect = b.lastEffect = k : (b.lastEffect.nextEffect = k, b.lastEffect = k)); k =
                    k.next
            } l = null; for (k = b.firstCapturedUpdate; null !== k;) { var p = k.expirationTime; if (p > e) { if (null === l && (l = k, null === g && (f = m)), 0 === h || h > p) h = p } else m = If(a, b, k, m, c, d), null !== k.callback && (a.effectTag |= 32, k.nextEffect = null, null === b.lastCapturedEffect ? b.firstCapturedEffect = b.lastCapturedEffect = k : (b.lastCapturedEffect.nextEffect = k, b.lastCapturedEffect = k)); k = k.next } null === g && (b.lastUpdate = null); null === l ? b.lastCapturedUpdate = null : a.effectTag |= 32; null === g && null === l && (f = m); b.baseState = f; b.firstUpdate = g; b.firstCapturedUpdate =
                l; b.expirationTime = h; a.memoizedState = m
        }
    } function Kf(a, b) { "function" !== typeof a ? m("191", a) : void 0; a.call(b) } function Lf(a, b, c, d) {
        null !== b.firstCapturedUpdate && (null !== b.lastUpdate && (b.lastUpdate.next = b.firstCapturedUpdate, b.lastUpdate = b.lastCapturedUpdate), b.firstCapturedUpdate = b.lastCapturedUpdate = null); a = b.firstEffect; for (b.firstEffect = b.lastEffect = null; null !== a;)d = a.callback, null !== d && (a.callback = null, Kf(d, c)), a = a.nextEffect; a = b.firstCapturedEffect; for (b.firstCapturedEffect = b.lastCapturedEffect =
            null; null !== a;)b = a.callback, null !== b && (a.callback = null, Kf(b, c)), a = a.nextEffect
    } function Ub(a, b) { return { value: a, source: b, stack: Ie(b) } } function Ka(a) { var b = a.type._context; y(kd, b._changedBits, a); y(ld, b._currentValue, a); y(Mf, a, a); b._currentValue = a.pendingProps.value; b._changedBits = a.stateNode } function md(a) { var b = kd.current, c = ld.current; v(Mf, a); v(ld, a); v(kd, a); a = a.type._context; a._currentValue = c; a._changedBits = b } function pa(a) { a === lb ? m("174") : void 0; return a } function nd(a, b) {
        y(mb, b, a); y(nb, a, a); y(U,
            lb, a); var c = b.nodeType; switch (c) { case 9: case 11: b = (b = b.documentElement) ? b.namespaceURI : Vc(null, ""); break; default: c = 8 === c ? b.parentNode : b, b = c.namespaceURI || null, c = c.tagName, b = Vc(b, c) }v(U, a); y(U, b, a)
    } function La(a) { v(U, a); v(nb, a); v(mb, a) } function od(a) { nb.current === a && (v(U, a), v(nb, a)) } function Vb(a, b, c) { var d = a.memoizedState; b = b(c, d); d = null === b || void 0 === b ? d : G({}, d, b); a.memoizedState = d; a = a.updateQueue; null !== a && 0 === a.expirationTime && (a.baseState = d) } function Nf(a, b, c, d, e, f) {
        var g = a.stateNode; a = a.type;
        return "function" === typeof g.shouldComponentUpdate ? g.shouldComponentUpdate(c, e, f) : a.prototype && a.prototype.isPureReactComponent ? !Rc(b, c) || !Rc(d, e) : !0
    } function Of(a, b, c, d) { a = b.state; "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d); "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d); b.state !== a && Wb.enqueueReplaceState(b, b.state, null) } function Pf(a, b) {
        var c = a.type, d = a.stateNode, e = a.pendingProps, f = Ha(a); d.props = e; d.state = a.memoizedState;
        d.refs = Y; d.context = Ia(a, f); f = a.updateQueue; null !== f && (kb(a, f, e, d, b), d.state = a.memoizedState); f = a.type.getDerivedStateFromProps; "function" === typeof f && (Vb(a, f, e), d.state = a.memoizedState); "function" === typeof c.getDerivedStateFromProps || "function" === typeof d.getSnapshotBeforeUpdate || "function" !== typeof d.UNSAFE_componentWillMount && "function" !== typeof d.componentWillMount || (c = d.state, "function" === typeof d.componentWillMount && d.componentWillMount(), "function" === typeof d.UNSAFE_componentWillMount && d.UNSAFE_componentWillMount(),
            c !== d.state && Wb.enqueueReplaceState(d, d.state, null), f = a.updateQueue, null !== f && (kb(a, f, e, d, b), d.state = a.memoizedState)); "function" === typeof d.componentDidMount && (a.effectTag |= 4)
    } function ob(a, b, c) {
        a = c.ref; if (null !== a && "function" !== typeof a && "object" !== typeof a) {
            if (c._owner) {
                c = c._owner; var d = void 0; c && (2 !== c.tag ? m("110") : void 0, d = c.stateNode); d ? void 0 : m("147", a); var e = "" + a; if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref; b = function (a) {
                    var b = d.refs === Y ? d.refs = {} :
                        d.refs; null === a ? delete b[e] : b[e] = a
                }; b._stringRef = e; return b
            } "string" !== typeof a ? m("148") : void 0; c._owner ? void 0 : m("254", a)
        } return a
    } function Xb(a, b) { "textarea" !== a.type && m("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "") } function Qf(a) {
        function b(b, c) { if (a) { var d = b.lastEffect; null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c; c.nextEffect = null; c.effectTag = 8 } } function c(c, d) {
            if (!a) return null; for (; null !== d;)b(c, d),
                d = d.sibling; return null
        } function d(a, b) { for (a = new Map; null !== b;)null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling; return a } function e(a, b, c) { a = Qb(a, b, c); a.index = 0; a.sibling = null; return a } function f(b, c, d) { b.index = d; if (!a) return c; d = b.alternate; if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d; b.effectTag = 2; return c } function g(b) { a && null === b.alternate && (b.effectTag = 2); return b } function h(a, b, c, d) { if (null === b || 6 !== b.tag) return b = fd(c, a.mode, d), b.return = a, b; b = e(b, c, d); b.return = a; return b } function k(a,
            b, c, d) { if (null !== b && b.type === c.type) return d = e(b, c.props, d), d.ref = ob(a, b, c), d.return = a, d; d = ed(c, a.mode, d); d.ref = ob(a, b, c); d.return = a; return d } function l(a, b, c, d) { if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = gd(c, a.mode, d), b.return = a, b; b = e(b, c.children || [], d); b.return = a; return b } function p(a, b, c, d, f) { if (null === b || 10 !== b.tag) return b = Rb(c, a.mode, d, f), b.return = a, b; b = e(b, c, d); b.return = a; return b } function Jf(a, b, c) {
                if ("string" ===
                    typeof b || "number" === typeof b) return b = fd("" + b, a.mode, c), b.return = a, b; if ("object" === typeof b && null !== b) { switch (b.$$typeof) { case Yb: return c = ed(b, a.mode, c), c.ref = ob(a, null, b), c.return = a, c; case Da: return b = gd(b, a.mode, c), b.return = a, b }if (Zb(b) || Ya(b)) return b = Rb(b, a.mode, c, null), b.return = a, b; Xb(a, b) } return null
            } function r(a, b, c, d) {
                var e = null !== b ? b.key : null; if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d); if ("object" === typeof c && null !== c) {
                    switch (c.$$typeof) {
                        case Yb: return c.key ===
                            e ? c.type === ea ? p(a, b, c.props.children, d, e) : k(a, b, c, d) : null; case Da: return c.key === e ? l(a, b, c, d) : null
                    }if (Zb(c) || Ya(c)) return null !== e ? null : p(a, b, c, d, null); Xb(a, c)
                } return null
            } function x(a, b, c, d, e) {
                if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e); if ("object" === typeof d && null !== d) {
                    switch (d.$$typeof) { case Yb: return a = a.get(null === d.key ? c : d.key) || null, d.type === ea ? p(b, a, d.props.children, e, d.key) : k(b, a, d, e); case Da: return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e) }if (Zb(d) ||
                        Ya(d)) return a = a.get(c) || null, p(b, a, d, e, null); Xb(b, d)
                } return null
            } function v(e, g, h, k) {
                for (var m = null, q = null, l = g, t = g = 0, w = null; null !== l && t < h.length; t++) { l.index > t ? (w = l, l = null) : w = l.sibling; var n = r(e, l, h[t], k); if (null === n) { null === l && (l = w); break } a && l && null === n.alternate && b(e, l); g = f(n, g, t); null === q ? m = n : q.sibling = n; q = n; l = w } if (t === h.length) return c(e, l), m; if (null === l) { for (; t < h.length; t++)if (l = Jf(e, h[t], k)) g = f(l, g, t), null === q ? m = l : q.sibling = l, q = l; return m } for (l = d(e, l); t < h.length; t++)if (w = x(l, e, t, h[t], k)) a &&
                    null !== w.alternate && l.delete(null === w.key ? t : w.key), g = f(w, g, t), null === q ? m = w : q.sibling = w, q = w; a && l.forEach(function (a) { return b(e, a) }); return m
            } function D(e, g, h, k) {
                var l = Ya(h); "function" !== typeof l ? m("150") : void 0; h = l.call(h); null == h ? m("151") : void 0; for (var q = l = null, t = g, w = g = 0, A = null, n = h.next(); null !== t && !n.done; w++, n = h.next()) { t.index > w ? (A = t, t = null) : A = t.sibling; var p = r(e, t, n.value, k); if (null === p) { t || (t = A); break } a && t && null === p.alternate && b(e, t); g = f(p, g, w); null === q ? l = p : q.sibling = p; q = p; t = A } if (n.done) return c(e,
                    t), l; if (null === t) { for (; !n.done; w++, n = h.next())n = Jf(e, n.value, k), null !== n && (g = f(n, g, w), null === q ? l = n : q.sibling = n, q = n); return l } for (t = d(e, t); !n.done; w++, n = h.next())n = x(t, e, w, n.value, k), null !== n && (a && null !== n.alternate && t.delete(null === n.key ? w : n.key), g = f(n, g, w), null === q ? l = n : q.sibling = n, q = n); a && t.forEach(function (a) { return b(e, a) }); return l
            } return function (a, d, f, h) {
                var k = "object" === typeof f && null !== f && f.type === ea && null === f.key; k && (f = f.props.children); var l = "object" === typeof f && null !== f; if (l) switch (f.$$typeof) {
                    case Yb: a: {
                        l =
                            f.key; for (k = d; null !== k;) { if (k.key === l) if (10 === k.tag ? f.type === ea : k.type === f.type) { c(a, k.sibling); d = e(k, f.type === ea ? f.props.children : f.props, h); d.ref = ob(a, k, f); d.return = a; a = d; break a } else { c(a, k); break } else b(a, k); k = k.sibling } f.type === ea ? (d = Rb(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = ed(f, a.mode, h), h.ref = ob(a, d, f), h.return = a, a = h)
                    } return g(a); case Da: a: {
                        for (k = f.key; null !== d;) {
                            if (d.key === k) if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                                c(a,
                                    d.sibling); d = e(d, f.children || [], h); d.return = a; a = d; break a
                            } else { c(a, d); break } else b(a, d); d = d.sibling
                        } d = gd(f, a.mode, h); d.return = a; a = d
                    } return g(a)
                }if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f, h), d.return = a, a = d) : (c(a, d), d = fd(f, a.mode, h), d.return = a, a = d), g(a); if (Zb(f)) return v(a, d, f, h); if (Ya(f)) return D(a, d, f, h); l && Xb(a, f); if ("undefined" === typeof f && !k) switch (a.tag) { case 2: case 1: h = a.type, m("152", h.displayName || h.name || "Component") }return c(a, d)
            }
    }
    function Rf(a, b) { var c = new ha(5, null, null, 0); c.type = "DELETED"; c.stateNode = b; c.return = a; c.effectTag = 8; null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c } function Sf(a, b) { switch (a.tag) { case 5: var c = a.type; b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b; return null !== b ? (a.stateNode = b, !0) : !1; case 6: return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, !0) : !1; default: return !1 } } function Tf(a) {
        if (qa) {
            var b = Ma; if (b) {
                var c =
                    b; if (!Sf(a, b)) { b = Zc(c); if (!b || !Sf(a, b)) { a.effectTag |= 2; qa = !1; Z = a; return } Rf(Z, c) } Z = a; Ma = yf(b)
            } else a.effectTag |= 2, qa = !1, Z = a
        }
    } function Uf(a) { for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag;)a = a.return; Z = a } function pd(a) { if (a !== Z) return !1; if (!qa) return Uf(a), qa = !0, !1; var b = a.type; if (5 !== a.tag || "head" !== b && "body" !== b && !Yc(b, a.memoizedProps)) for (b = Ma; b;)Rf(a, b), b = Zc(b); Uf(a); Ma = Z ? Zc(a.stateNode) : null; return !0 } function qd() { Ma = Z = null; qa = !1 } function O(a, b, c) { rd(a, b, c, b.expirationTime) } function rd(a, b, c, d) {
        b.child =
            null === a ? Vf(b, null, c, d) : Wf(b, a.child, c, d)
    } function Xf(a, b) { var c = b.ref; if (null === a && null !== c || null !== a && a.ref !== c) b.effectTag |= 128 } function Yf(a, b, c, d, e) { Xf(a, b); var f = 0 !== (b.effectTag & 64); if (!c && !f) return d && Bf(b, !1), D(a, b); c = b.stateNode; sd.current = b; var g = f ? null : c.render(); b.effectTag |= 1; f && (rd(a, b, null, e), b.child = null); rd(a, b, g, e); b.memoizedState = c.state; b.memoizedProps = c.props; d && Bf(b, !0); return b.child } function Zf(a) {
        var b = a.stateNode; b.pendingContext ? zf(a, b.pendingContext, b.pendingContext !==
            b.context) : b.context && zf(a, b.context, !1); nd(a, b.containerInfo)
    } function $f(a, b, c, d) {
        var e = a.child; null !== e && (e.return = a); for (; null !== e;) {
            switch (e.tag) {
                case 12: var f = e.stateNode | 0; if (e.type === b && 0 !== (f & c)) { for (f = e; null !== f;) { var g = f.alternate; if (0 === f.expirationTime || f.expirationTime > d) f.expirationTime = d, null !== g && (0 === g.expirationTime || g.expirationTime > d) && (g.expirationTime = d); else if (null !== g && (0 === g.expirationTime || g.expirationTime > d)) g.expirationTime = d; else break; f = f.return } f = null } else f = e.child;
                    break; case 13: f = e.type === a.type ? null : e.child; break; default: f = e.child
            }if (null !== f) f.return = e; else for (f = e; null !== f;) { if (f === a) { f = null; break } e = f.sibling; if (null !== e) { e.return = f.return; f = e; break } f = f.return } e = f
        }
    } function yh(a, b, c) {
        var d = b.type._context, e = b.pendingProps, f = b.memoizedProps, g = !0; if (x.current) g = !1; else if (f === e) return b.stateNode = 0, Ka(b), D(a, b); var h = e.value; b.memoizedProps = e; if (null === f) h = 1073741823; else if (f.value === e.value) {
            if (f.children === e.children && g) return b.stateNode = 0, Ka(b), D(a, b);
            h = 0
        } else { var k = f.value; if (k === h && (0 !== k || 1 / k === 1 / h) || k !== k && h !== h) { if (f.children === e.children && g) return b.stateNode = 0, Ka(b), D(a, b); h = 0 } else if (h = "function" === typeof d._calculateChangedBits ? d._calculateChangedBits(k, h) : 1073741823, h |= 0, 0 === h) { if (f.children === e.children && g) return b.stateNode = 0, Ka(b), D(a, b) } else $f(b, d, h, c) } b.stateNode = h; Ka(b); O(a, b, e.children); return b.child
    } function D(a, b) {
        null !== a && b.child !== a.child ? m("153") : void 0; if (null !== b.child) {
            a = b.child; var c = Qb(a, a.pendingProps, a.expirationTime);
            b.child = c; for (c.return = b; null !== a.sibling;)a = a.sibling, c = c.sibling = Qb(a, a.pendingProps, a.expirationTime), c.return = b; c.sibling = null
        } return b.child
    } function zh(a, b, c) {
        if (0 === b.expirationTime || b.expirationTime > c) { switch (b.tag) { case 3: Zf(b); break; case 2: dd(b); break; case 4: nd(b, b.stateNode.containerInfo); break; case 13: Ka(b) }return null } switch (b.tag) {
            case 0: null !== a ? m("155") : void 0; var d = b.type, e = b.pendingProps, f = Ha(b); f = Ia(b, f); d = d(e, f); b.effectTag |= 1; "object" === typeof d && null !== d && "function" === typeof d.render &&
                void 0 === d.$$typeof ? (f = b.type, b.tag = 2, b.memoizedState = null !== d.state && void 0 !== d.state ? d.state : null, f = f.getDerivedStateFromProps, "function" === typeof f && Vb(b, f, e), e = dd(b), d.updater = Wb, b.stateNode = d, d._reactInternalFiber = b, Pf(b, c), a = Yf(a, b, !0, e, c)) : (b.tag = 1, O(a, b, d), b.memoizedProps = e, a = b.child); return a; case 1: return e = b.type, c = b.pendingProps, x.current || b.memoizedProps !== c ? (d = Ha(b), d = Ia(b, d), e = e(c, d), b.effectTag |= 1, O(a, b, e), b.memoizedProps = c, a = b.child) : a = D(a, b), a; case 2: e = dd(b); if (null === a) if (null ===
                    b.stateNode) { var g = b.pendingProps, h = b.type; d = Ha(b); var k = 2 === b.tag && null != b.type.contextTypes; f = k ? Ia(b, d) : Y; g = new h(g, f); b.memoizedState = null !== g.state && void 0 !== g.state ? g.state : null; g.updater = Wb; b.stateNode = g; g._reactInternalFiber = b; k && (k = b.stateNode, k.__reactInternalMemoizedUnmaskedChildContext = d, k.__reactInternalMemoizedMaskedChildContext = f); Pf(b, c); d = !0 } else {
                    h = b.type; d = b.stateNode; k = b.memoizedProps; f = b.pendingProps; d.props = k; var l = d.context; g = Ha(b); g = Ia(b, g); var p = h.getDerivedStateFromProps; (h =
                        "function" === typeof p || "function" === typeof d.getSnapshotBeforeUpdate) || "function" !== typeof d.UNSAFE_componentWillReceiveProps && "function" !== typeof d.componentWillReceiveProps || (k !== f || l !== g) && Of(b, d, f, g); ia = !1; var r = b.memoizedState; l = d.state = r; var v = b.updateQueue; null !== v && (kb(b, v, f, d, c), l = b.memoizedState); k !== f || r !== l || x.current || ia ? ("function" === typeof p && (Vb(b, p, f), l = b.memoizedState), (k = ia || Nf(b, k, f, r, l, g)) ? (h || "function" !== typeof d.UNSAFE_componentWillMount && "function" !== typeof d.componentWillMount ||
                            ("function" === typeof d.componentWillMount && d.componentWillMount(), "function" === typeof d.UNSAFE_componentWillMount && d.UNSAFE_componentWillMount()), "function" === typeof d.componentDidMount && (b.effectTag |= 4)) : ("function" === typeof d.componentDidMount && (b.effectTag |= 4), b.memoizedProps = f, b.memoizedState = l), d.props = f, d.state = l, d.context = g, d = k) : ("function" === typeof d.componentDidMount && (b.effectTag |= 4), d = !1)
                } else h = b.type, d = b.stateNode, f = b.memoizedProps, k = b.pendingProps, d.props = f, l = d.context, g = Ha(b), g = Ia(b,
                    g), p = h.getDerivedStateFromProps, (h = "function" === typeof p || "function" === typeof d.getSnapshotBeforeUpdate) || "function" !== typeof d.UNSAFE_componentWillReceiveProps && "function" !== typeof d.componentWillReceiveProps || (f !== k || l !== g) && Of(b, d, k, g), ia = !1, l = b.memoizedState, r = d.state = l, v = b.updateQueue, null !== v && (kb(b, v, k, d, c), r = b.memoizedState), f !== k || l !== r || x.current || ia ? ("function" === typeof p && (Vb(b, p, k), r = b.memoizedState), (p = ia || Nf(b, f, k, l, r, g)) ? (h || "function" !== typeof d.UNSAFE_componentWillUpdate && "function" !==
                        typeof d.componentWillUpdate || ("function" === typeof d.componentWillUpdate && d.componentWillUpdate(k, r, g), "function" === typeof d.UNSAFE_componentWillUpdate && d.UNSAFE_componentWillUpdate(k, r, g)), "function" === typeof d.componentDidUpdate && (b.effectTag |= 4), "function" === typeof d.getSnapshotBeforeUpdate && (b.effectTag |= 256)) : ("function" !== typeof d.componentDidUpdate || f === a.memoizedProps && l === a.memoizedState || (b.effectTag |= 4), "function" !== typeof d.getSnapshotBeforeUpdate || f === a.memoizedProps && l === a.memoizedState ||
                            (b.effectTag |= 256), b.memoizedProps = k, b.memoizedState = r), d.props = k, d.state = r, d.context = g, d = p) : ("function" !== typeof d.componentDidUpdate || f === a.memoizedProps && l === a.memoizedState || (b.effectTag |= 4), "function" !== typeof d.getSnapshotBeforeUpdate || f === a.memoizedProps && l === a.memoizedState || (b.effectTag |= 256), d = !1); return Yf(a, b, d, e, c); case 3: Zf(b); e = b.updateQueue; if (null !== e) if (d = b.memoizedState, d = null !== d ? d.element : null, kb(b, e, b.pendingProps, null, c), e = b.memoizedState.element, e === d) qd(), a = D(a, b); else {
                                d =
                                    b.stateNode; if (d = (null === a || null === a.child) && d.hydrate) Ma = yf(b.stateNode.containerInfo), Z = b, d = qa = !0; d ? (b.effectTag |= 2, b.child = Vf(b, null, e, c)) : (qd(), O(a, b, e)); a = b.child
                            } else qd(), a = D(a, b); return a; case 5: a: {
                                pa(mb.current); e = pa(U.current); d = Vc(e, b.type); e !== d && (y(nb, b, b), y(U, d, b)); null === a && Tf(b); e = b.type; k = b.memoizedProps; d = b.pendingProps; f = null !== a ? a.memoizedProps : null; if (!x.current && k === d) { if (k = b.mode & 1 && !!d.hidden) b.expirationTime = 1073741823; if (!k || 1073741823 !== c) { a = D(a, b); break a } } k = d.children;
                                Yc(e, d) ? k = null : f && Yc(e, f) && (b.effectTag |= 16); Xf(a, b); 1073741823 !== c && b.mode & 1 && d.hidden ? (b.expirationTime = 1073741823, b.memoizedProps = d, a = null) : (O(a, b, k), b.memoizedProps = d, a = b.child)
                            } return a; case 6: return null === a && Tf(b), b.memoizedProps = b.pendingProps, null; case 16: return null; case 4: return nd(b, b.stateNode.containerInfo), e = b.pendingProps, x.current || b.memoizedProps !== e ? (null === a ? b.child = Wf(b, null, e, c) : O(a, b, e), b.memoizedProps = e, a = b.child) : a = D(a, b), a; case 14: return e = b.type.render, c = b.pendingProps,
                                d = b.ref, x.current || b.memoizedProps !== c || d !== (null !== a ? a.ref : null) ? (e = e(c, d), O(a, b, e), b.memoizedProps = c, a = b.child) : a = D(a, b), a; case 10: return c = b.pendingProps, x.current || b.memoizedProps !== c ? (O(a, b, c), b.memoizedProps = c, a = b.child) : a = D(a, b), a; case 11: return c = b.pendingProps.children, x.current || null !== c && b.memoizedProps !== c ? (O(a, b, c), b.memoizedProps = c, a = b.child) : a = D(a, b), a; case 15: return c = b.pendingProps, b.memoizedProps === c ? a = D(a, b) : (O(a, b, c.children), b.memoizedProps = c, a = b.child), a; case 13: return yh(a,
                                    b, c); case 12: a: if (d = b.type, f = b.pendingProps, k = b.memoizedProps, e = d._currentValue, g = d._changedBits, x.current || 0 !== g || k !== f) { b.memoizedProps = f; h = f.unstable_observedBits; if (void 0 === h || null === h) h = 1073741823; b.stateNode = h; if (0 !== (g & h)) $f(b, d, g, c); else if (k === f) { a = D(a, b); break a } c = f.children; c = c(e); b.effectTag |= 1; O(a, b, c); a = b.child } else a = D(a, b); return a; default: m("156")
        }
    } function pb(a) { a.effectTag |= 4 } function Ah(a, b, c) {
        var d = b.pendingProps; switch (b.tag) {
            case 1: return null; case 2: return bd(b), null; case 3: La(b);
                cd(b); c = b.stateNode; c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null); if (null === a || null === a.child) pd(b), b.effectTag &= -3; td(b); return null; case 5: od(b); c = pa(mb.current); var e = b.type; if (null !== a && null != b.stateNode) { var f = a.memoizedProps, g = b.stateNode, h = pa(U.current); g = Bh(g, e, f, d, c); ag(a, b, g, e, f, d, c, h); a.ref !== b.ref && (b.effectTag |= 128) } else {
                    if (!d) return null === b.stateNode ? m("166") : void 0, null; a = pa(U.current); if (pd(b)) d = b.stateNode, e = b.type, f = b.memoizedProps, $b(b, d), ud(d, f), c = Ch(d,
                        e, f, a, c), b.updateQueue = c, null !== c && pb(b); else { a = Dh(e, d, c, a); $b(b, a); ud(a, d); a: for (f = b.child; null !== f;) { if (5 === f.tag || 6 === f.tag) a.appendChild(f.stateNode); else if (4 !== f.tag && null !== f.child) { f.child.return = f; f = f.child; continue } if (f === b) break; for (; null === f.sibling;) { if (null === f.return || f.return === b) break a; f = f.return } f.sibling.return = f.return; f = f.sibling } Eh(a, e, d, c); xf(e, d) && pb(b); b.stateNode = a } null !== b.ref && (b.effectTag |= 128)
                } return null; case 6: if (a && null != b.stateNode) bg(a, b, a.memoizedProps, d); else {
                    if ("string" !==
                        typeof d) return null === b.stateNode ? m("166") : void 0, null; c = pa(mb.current); pa(U.current); pd(b) ? (c = b.stateNode, d = b.memoizedProps, $b(b, c), Fh(c, d) && pb(b)) : (c = Gh(d, c), $b(b, c), b.stateNode = c)
                } return null; case 14: return null; case 16: return null; case 10: return null; case 11: return null; case 15: return null; case 4: return La(b), td(b), null; case 13: return md(b), null; case 12: return null; case 0: m("167"); default: m("156")
        }
    } function cg(a, b) {
        var c = b.source; null === b.stack && null !== c && Ie(c); null !== c && Za(c); b = b.value; null !==
            a && 2 === a.tag && Za(a); try { b && b.suppressReactErrorLogging || console.error(b) } catch (d) { d && d.suppressReactErrorLogging || console.error(d) }
    } function dg(a) { var b = a.ref; if (null !== b) if ("function" === typeof b) try { b(null) } catch (c) { qb(a, c) } else b.current = null } function eg(a) { "function" === typeof Ff && Ff(a); switch (a.tag) { case 2: dg(a); var b = a.stateNode; if ("function" === typeof b.componentWillUnmount) try { b.props = a.memoizedProps, b.state = a.memoizedState, b.componentWillUnmount() } catch (c) { qb(a, c) } break; case 5: dg(a); break; case 4: fg(a) } }
    function gg(a) { return 5 === a.tag || 3 === a.tag || 4 === a.tag } function hg(a) {
        a: { for (var b = a.return; null !== b;) { if (gg(b)) { var c = b; break a } b = b.return } m("160"); c = void 0 } var d = b = void 0; switch (c.tag) { case 5: b = c.stateNode; d = !1; break; case 3: b = c.stateNode.containerInfo; d = !0; break; case 4: b = c.stateNode.containerInfo; d = !0; break; default: m("161") }c.effectTag & 16 && (ib(b, ""), c.effectTag &= -17); a: b: for (c = a; ;) {
            for (; null === c.sibling;) { if (null === c.return || gg(c.return)) { c = null; break a } c = c.return } c.sibling.return = c.return; for (c =
                c.sibling; 5 !== c.tag && 6 !== c.tag;) { if (c.effectTag & 2) continue b; if (null === c.child || 4 === c.tag) continue b; else c.child.return = c, c = c.child } if (!(c.effectTag & 2)) { c = c.stateNode; break a }
        } for (var e = a; ;) {
            if (5 === e.tag || 6 === e.tag) if (c) if (d) { var f = b, g = e.stateNode, h = c; 8 === f.nodeType ? f.parentNode.insertBefore(g, h) : f.insertBefore(g, h) } else b.insertBefore(e.stateNode, c); else d ? (f = b, g = e.stateNode, 8 === f.nodeType ? f.parentNode.insertBefore(g, f) : f.appendChild(g)) : b.appendChild(e.stateNode); else if (4 !== e.tag && null !== e.child) {
                e.child.return =
                    e; e = e.child; continue
            } if (e === a) break; for (; null === e.sibling;) { if (null === e.return || e.return === a) return; e = e.return } e.sibling.return = e.return; e = e.sibling
        }
    } function fg(a) {
        for (var b = a, c = !1, d = void 0, e = void 0; ;) {
            if (!c) { c = b.return; a: for (; ;) { null === c ? m("160") : void 0; switch (c.tag) { case 5: d = c.stateNode; e = !1; break a; case 3: d = c.stateNode.containerInfo; e = !0; break a; case 4: d = c.stateNode.containerInfo; e = !0; break a }c = c.return } c = !0 } if (5 === b.tag || 6 === b.tag) {
                a: for (var f = b, g = f; ;)if (eg(g), null !== g.child && 4 !== g.tag) g.child.return =
                    g, g = g.child; else { if (g === f) break; for (; null === g.sibling;) { if (null === g.return || g.return === f) break a; g = g.return } g.sibling.return = g.return; g = g.sibling } e ? (f = d, g = b.stateNode, 8 === f.nodeType ? f.parentNode.removeChild(g) : f.removeChild(g)) : d.removeChild(b.stateNode)
            } else if (4 === b.tag ? d = b.stateNode.containerInfo : eg(b), null !== b.child) { b.child.return = b; b = b.child; continue } if (b === a) break; for (; null === b.sibling;) { if (null === b.return || b.return === a) return; b = b.return; 4 === b.tag && (c = !1) } b.sibling.return = b.return; b = b.sibling
        }
    }
    function ig(a, b) { switch (b.tag) { case 2: break; case 5: var c = b.stateNode; if (null != c) { var d = b.memoizedProps; a = null !== a ? a.memoizedProps : d; var e = b.type, f = b.updateQueue; b.updateQueue = null; null !== f && (ud(c, d), Hh(c, f, e, a, d)) } break; case 6: null === b.stateNode ? m("162") : void 0; b.stateNode.nodeValue = b.memoizedProps; break; case 3: break; case 15: break; case 16: break; default: m("163") } } function vd(a, b, c) { c = Ja(c); c.tag = 3; c.payload = { element: null }; var d = b.value; c.callback = function () { wd(d); cg(a, b) }; return c } function jg(a, b,
        c) { c = Ja(c); c.tag = 3; var d = a.stateNode; null !== d && "function" === typeof d.componentDidCatch && (c.callback = function () { null === ja ? ja = new Set([this]) : ja.add(this); var c = b.value, d = b.stack; cg(a, b); this.componentDidCatch(c, { componentStack: null !== d ? d : "" }) }); return c } function Ih(a, b, c, d, e, f, g) {
            c.effectTag |= 512; c.firstEffect = c.lastEffect = null; d = Ub(d, c); a = b; do {
                switch (a.tag) {
                    case 3: a.effectTag |= 1024; d = vd(a, d, f); Gf(a, d, f); return; case 2: if (b = d, c = a.stateNode, 0 === (a.effectTag & 64) && null !== c && "function" === typeof c.componentDidCatch &&
                        (null === ja || !ja.has(c))) { a.effectTag |= 1024; d = jg(a, b, f); Gf(a, d, f); return }
                }a = a.return
            } while (null !== a)
        } function Jh(a, b, c) { switch (a.tag) { case 2: return bd(a), b = a.effectTag, b & 1024 ? (a.effectTag = b & -1025 | 64, a) : null; case 3: return La(a), cd(a), b = a.effectTag, b & 1024 ? (a.effectTag = b & -1025 | 64, a) : null; case 5: return od(a), null; case 16: return b = a.effectTag, b & 1024 ? (a.effectTag = b & -1025 | 64, a) : null; case 4: return La(a), null; case 13: return md(a), null; default: return null } } function kg() {
            if (null !== F) for (var a = F.return; null !==
                a;) { var b = a; switch (b.tag) { case 2: bd(b); break; case 3: La(b); cd(b); break; case 5: od(b); break; case 4: La(b); break; case 13: md(b) }a = a.return } rb = null; K = 0; ac = -1; sb = !1; F = null; xd = !1
        } function lg(a) {
            for (; ;) {
                var b = a.alternate, c = a.return, d = a.sibling; if (0 === (a.effectTag & 512)) {
                    b = Ah(b, a, K); var e = a; if (1073741823 === K || 1073741823 !== e.expirationTime) {
                        var f = 0; switch (e.tag) { case 3: case 2: var g = e.updateQueue; null !== g && (f = g.expirationTime) }for (g = e.child; null !== g;)0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime),
                            g = g.sibling; e.expirationTime = f
                    } if (null !== b) return b; null !== c && 0 === (c.effectTag & 512) && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a)); if (null !== d) return d; if (null !== c) a = c; else { xd = !0; break }
                } else {
                    a = Jh(a, sb, K); if (null !== a) return a.effectTag &= 511, a; null !== c && (c.firstEffect = c.lastEffect = null, c.effectTag |=
                        512); if (null !== d) return d; if (null !== c) a = c; else break
                }
            } return null
        } function mg(a) { var b = zh(a.alternate, a, K); null === b && (b = lg(a)); sd.current = null; return b } function ng(a, b, c) {
            aa ? m("243") : void 0; aa = !0; if (b !== K || a !== rb || null === F) kg(), rb = a, K = b, ac = -1, F = Qb(rb.current, null, K), a.pendingCommitExpirationTime = 0; var d = !1; sb = !c || K <= og; do {
                try { if (c) for (; null !== F && !pg();)F = mg(F); else for (; null !== F;)F = mg(F) } catch (f) {
                    if (null === F) d = !0, wd(f); else {
                        null === F ? m("271") : void 0; c = F; var e = c.return; if (null === e) { d = !0; wd(f); break } Ih(a,
                            e, c, f, sb, K, yd); F = lg(c)
                    }
                } break
            } while (1); aa = !1; if (d) return null; if (null === F) { if (xd) return a.pendingCommitExpirationTime = b, a.current.alternate; sb ? m("262") : void 0; 0 <= ac && setTimeout(function () { var b = a.current.expirationTime; 0 !== b && (0 === a.remainingExpirationTime || a.remainingExpirationTime < b) && zd(a, b) }, ac); Kh(a.current.expirationTime) } return null
        } function qb(a, b) {
            var c; a: {
                aa && !tb ? m("263") : void 0; for (c = a.return; null !== c;) {
                    switch (c.tag) {
                        case 2: var d = c.stateNode; if ("function" === typeof c.type.getDerivedStateFromCatch ||
                            "function" === typeof d.componentDidCatch && (null === ja || !ja.has(d))) { a = Ub(b, a); a = jg(c, a, 1); oa(c, a, 1); ra(c, 1); c = void 0; break a } break; case 3: a = Ub(b, a); a = vd(c, a, 1); oa(c, a, 1); ra(c, 1); c = void 0; break a
                    }c = c.return
                } 3 === a.tag && (c = Ub(b, a), c = vd(a, c, 1), oa(a, c, 1), ra(a, 1)); c = void 0
            } return c
        } function qg() { var a = 2 + 25 * (((ba() - 2 + 500) / 25 | 0) + 1); a <= Ad && (a = Ad + 1); return Ad = a } function bc(a, b) { a = 0 !== ka ? ka : aa ? tb ? 1 : K : b.mode & 1 ? Na ? 2 + 10 * (((a - 2 + 15) / 10 | 0) + 1) : 2 + 25 * (((a - 2 + 500) / 25 | 0) + 1) : 1; Na && (0 === ca || a > ca) && (ca = a); return a } function ra(a,
            b) { for (; null !== a;) { if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b; null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b); if (null === a.return) if (3 === a.tag) { var c = a.stateNode; !aa && 0 !== K && b < K && kg(); var d = c.current.expirationTime; aa && !tb && rb === c || zd(c, d); cc > Lh && m("185") } else break; a = a.return } } function ba() { yd = Bd() - Cd; return og = (yd / 10 | 0) + 2 } function rg(a) { var b = ka; ka = 2 + 25 * (((ba() - 2 + 500) / 25 | 0) + 1); try { return a() } finally { ka = b } } function Dd(a,
                b, c, d, e) { var f = ka; ka = 1; try { return a(b, c, d, e) } finally { ka = f } } function sg(a) { if (0 !== dc) { if (a > dc) return; null !== ec && Mh(ec) } var b = Bd() - Cd; dc = a; ec = Nh(Oh, { timeout: 10 * (a - 2) - b }) } function zd(a, b) { if (null === a.nextScheduledRoot) a.remainingExpirationTime = b, null === E ? (sa = E = a, a.nextScheduledRoot = a) : (E = E.nextScheduledRoot = a, E.nextScheduledRoot = sa); else { var c = a.remainingExpirationTime; if (0 === c || b < c) a.remainingExpirationTime = b } Q || (H ? fc && (P = a, I = 1, gc(a, 1, !1)) : 1 === b ? ub() : sg(b)) } function Ed() {
                    var a = 0, b = null; if (null !== E) for (var c =
                        E, d = sa; null !== d;) { var e = d.remainingExpirationTime; if (0 === e) { null === c || null === E ? m("244") : void 0; if (d === d.nextScheduledRoot) { sa = E = d.nextScheduledRoot = null; break } else if (d === sa) sa = e = d.nextScheduledRoot, E.nextScheduledRoot = e, d.nextScheduledRoot = null; else if (d === E) { E = c; E.nextScheduledRoot = sa; d.nextScheduledRoot = null; break } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null; d = c.nextScheduledRoot } else { if (0 === a || e < a) a = e, b = d; if (d === E) break; c = d; d = d.nextScheduledRoot } } c = P; null !== c && c === b &&
                            1 === a ? cc++ : cc = 0; P = b; I = a
                } function Oh(a) { vb(0, !0, a) } function ub() { vb(1, !1, null) } function vb(a, b, c) { wb = c; Ed(); if (b) for (; null !== P && 0 !== I && (0 === a || a >= I) && (!hc || ba() >= I);)ba(), gc(P, I, !hc), Ed(); else for (; null !== P && 0 !== I && (0 === a || a >= I);)gc(P, I, !1), Ed(); null !== wb && (dc = 0, ec = null); 0 !== I && sg(I); wb = null; hc = !1; tg() } function ug(a, b) { Q ? m("253") : void 0; P = a; I = b; gc(a, b, !1); ub(); tg() } function tg() {
                    cc = 0; if (null !== Oa) { var a = Oa; Oa = null; for (var b = 0; b < a.length; b++) { var c = a[b]; try { c._onComplete() } catch (d) { Pa || (Pa = !0, ic = d) } } } if (Pa) throw a =
                        ic, ic = null, Pa = !1, a;
                } function gc(a, b, c) { Q ? m("245") : void 0; Q = !0; c ? (c = a.finishedWork, null !== c ? jc(a, c, b) : (c = ng(a, b, !0), null !== c && (pg() ? a.finishedWork = c : jc(a, c, b)))) : (c = a.finishedWork, null !== c ? jc(a, c, b) : (c = ng(a, b, !1), null !== c && jc(a, c, b))); Q = !1 } function jc(a, b, c) {
                    var d = a.firstBatch; if (null !== d && d._expirationTime <= c && (null === Oa ? Oa = [d] : Oa.push(d), d._defer)) { a.finishedWork = b; a.remainingExpirationTime = 0; return } a.finishedWork = null; tb = aa = !0; c = b.stateNode; c.current === b ? m("177") : void 0; d = c.pendingCommitExpirationTime;
                    0 === d ? m("261") : void 0; c.pendingCommitExpirationTime = 0; ba(); sd.current = null; if (1 < b.effectTag) if (null !== b.lastEffect) { b.lastEffect.nextEffect = b; var e = b.firstEffect } else e = b; else e = b.firstEffect; Fd = cb; var f = Qc(); if (Oc(f)) {
                        if ("selectionStart" in f) var g = { start: f.selectionStart, end: f.selectionEnd }; else a: {
                            var h = window.getSelection && window.getSelection(); if (h && 0 !== h.rangeCount) {
                                g = h.anchorNode; var k = h.anchorOffset, p = h.focusNode; h = h.focusOffset; try { g.nodeType, p.nodeType } catch (Qa) { g = null; break a } var r = 0, v =
                                    -1, x = -1, D = 0, F = 0, u = f, w = null; b: for (; ;) { for (var t; ;) { u !== g || 0 !== k && 3 !== u.nodeType || (v = r + k); u !== p || 0 !== h && 3 !== u.nodeType || (x = r + h); 3 === u.nodeType && (r += u.nodeValue.length); if (null === (t = u.firstChild)) break; w = u; u = t } for (; ;) { if (u === f) break b; w === g && ++D === k && (v = r); w === p && ++F === h && (x = r); if (null !== (t = u.nextSibling)) break; u = w; w = u.parentNode } u = t } g = -1 === v || -1 === x ? null : { start: v, end: x }
                            } else g = null
                        } g = g || { start: 0, end: 0 }
                    } else g = null; Gd = { focusedElem: f, selectionRange: g }; Nc(!1); for (l = e; null !== l;) {
                        f = !1; g = void 0; try {
                            for (; null !==
                                l;) { if (l.effectTag & 256) { var q = l.alternate; k = l; switch (k.tag) { case 2: if (k.effectTag & 256 && null !== q) { var A = q.memoizedProps, J = q.memoizedState, y = k.stateNode; y.props = k.memoizedProps; y.state = k.memoizedState; var H = y.getSnapshotBeforeUpdate(A, J); y.__reactInternalSnapshotBeforeUpdate = H } break; case 3: case 5: case 6: case 4: break; default: m("163") } } l = l.nextEffect }
                        } catch (Qa) { f = !0, g = Qa } f && (null === l ? m("178") : void 0, qb(l, g), null !== l && (l = l.nextEffect))
                    } for (l = e; null !== l;) {
                        q = !1; A = void 0; try {
                            for (; null !== l;) {
                                var B = l.effectTag;
                                B & 16 && ib(l.stateNode, ""); if (B & 128) { var C = l.alternate; if (null !== C) { var n = C.ref; null !== n && ("function" === typeof n ? n(null) : n.current = null) } } switch (B & 14) { case 2: hg(l); l.effectTag &= -3; break; case 6: hg(l); l.effectTag &= -3; ig(l.alternate, l); break; case 4: ig(l.alternate, l); break; case 8: J = l, fg(J), J.return = null, J.child = null, J.alternate && (J.alternate.child = null, J.alternate.return = null) }l = l.nextEffect
                            }
                        } catch (Qa) { q = !0, A = Qa } q && (null === l ? m("178") : void 0, qb(l, A), null !== l && (l = l.nextEffect))
                    } n = Gd; C = Qc(); B = n.focusedElem;
                    q = n.selectionRange; if (C !== B && Ph(document.documentElement, B)) {
                        null !== q && Oc(B) && (C = q.start, n = q.end, void 0 === n && (n = C), "selectionStart" in B ? (B.selectionStart = C, B.selectionEnd = Math.min(n, B.value.length)) : window.getSelection && (C = window.getSelection(), A = B[ge()].length, n = Math.min(q.start, A), q = void 0 === q.end ? n : Math.min(q.end, A), !C.extend && n > q && (A = q, q = n, n = A), A = gf(B, n), J = gf(B, q), A && J && (1 !== C.rangeCount || C.anchorNode !== A.node || C.anchorOffset !== A.offset || C.focusNode !== J.node || C.focusOffset !== J.offset) && (y = document.createRange(),
                            y.setStart(A.node, A.offset), C.removeAllRanges(), n > q ? (C.addRange(y), C.extend(J.node, J.offset)) : (y.setEnd(J.node, J.offset), C.addRange(y))))); C = []; for (n = B; n = n.parentNode;)1 === n.nodeType && C.push({ element: n, left: n.scrollLeft, top: n.scrollTop }); "function" === typeof B.focus && B.focus(); for (B = 0; B < C.length; B++)n = C[B], n.element.scrollLeft = n.left, n.element.scrollTop = n.top
                    } Gd = null; Nc(Fd); Fd = null; c.current = b; for (l = e; null !== l;) {
                        e = !1; B = void 0; try {
                            for (C = d; null !== l;) {
                                var G = l.effectTag; if (G & 36) {
                                    var E = l.alternate; n = l;
                                    q = C; switch (n.tag) {
                                        case 2: var z = n.stateNode; if (n.effectTag & 4) if (null === E) z.props = n.memoizedProps, z.state = n.memoizedState, z.componentDidMount(); else { var L = E.memoizedProps, N = E.memoizedState; z.props = n.memoizedProps; z.state = n.memoizedState; z.componentDidUpdate(L, N, z.__reactInternalSnapshotBeforeUpdate) } var K = n.updateQueue; null !== K && (z.props = n.memoizedProps, z.state = n.memoizedState, Lf(n, K, z, q)); break; case 3: var M = n.updateQueue; if (null !== M) {
                                            A = null; if (null !== n.child) switch (n.child.tag) {
                                                case 5: A = n.child.stateNode;
                                                    break; case 2: A = n.child.stateNode
                                            }Lf(n, M, A, q)
                                        } break; case 5: var P = n.stateNode; null === E && n.effectTag & 4 && xf(n.type, n.memoizedProps) && P.focus(); break; case 6: break; case 4: break; case 15: break; case 16: break; default: m("163")
                                    }
                                } if (G & 128) { n = void 0; var I = l.ref; if (null !== I) { var O = l.stateNode; switch (l.tag) { case 5: n = O; break; default: n = O }"function" === typeof I ? I(n) : I.current = n } } var Q = l.nextEffect; l.nextEffect = null; l = Q
                            }
                        } catch (Qa) { e = !0, B = Qa } e && (null === l ? m("178") : void 0, qb(l, B), null !== l && (l = l.nextEffect))
                    } aa = tb = !1; "function" ===
                        typeof Ef && Ef(b.stateNode); b = c.current.expirationTime; 0 === b && (ja = null); a.remainingExpirationTime = b
                } function pg() { return null === wb || wb.timeRemaining() > Qh ? !1 : hc = !0 } function wd(a) { null === P ? m("246") : void 0; P.remainingExpirationTime = 0; Pa || (Pa = !0, ic = a) } function Kh(a) { null === P ? m("246") : void 0; P.remainingExpirationTime = a } function vg(a, b) { var c = H; H = !0; try { return a(b) } finally { (H = c) || Q || ub() } } function Hd(a, b) { if (H && !fc) { fc = !0; try { return a(b) } finally { fc = !1 } } return a(b) } function wg(a, b) {
                    Q ? m("187") : void 0; var c =
                        H; H = !0; try { return Dd(a, b) } finally { H = c, ub() }
                } function xg(a, b, c) { if (Na) return a(b, c); H || Q || 0 === ca || (vb(ca, !1, null), ca = 0); var d = Na, e = H; H = Na = !0; try { return a(b, c) } finally { Na = d, (H = e) || Q || ub() } } function yg(a) { var b = H; H = !0; try { Dd(a) } finally { (H = b) || Q || vb(1, !1, null) } } function Id(a, b, c, d, e) {
                    var f = b.current; if (c) {
                        c = c._reactInternalFiber; var g; b: { 2 === bb(c) && 2 === c.tag ? void 0 : m("170"); for (g = c; 3 !== g.tag;) { if (jb(g)) { g = g.stateNode.__reactInternalMemoizedMergedChildContext; break b } (g = g.return) ? void 0 : m("171") } g = g.stateNode.context } c =
                            jb(c) ? Af(c, g) : g
                    } else c = Y; null === b.context ? b.context = c : b.pendingContext = c; b = e; e = Ja(d); e.payload = { element: a }; b = void 0 === b ? null : b; null !== b && (e.callback = b); oa(f, e, d); ra(f, d); return d
                } function zg(a) { var b = a._reactInternalFiber; void 0 === b && ("function" === typeof a.render ? m("188") : m("268", Object.keys(a))); a = We(b); return null === a ? null : a.stateNode } function kc(a, b, c, d) { var e = b.current, f = ba(); e = bc(f, e); return Id(a, b, c, e, d) } function lc(a) {
                    a = a.current; if (!a.child) return null; switch (a.child.tag) {
                        case 5: return a.child.stateNode;
                        default: return a.child.stateNode
                    }
                } function Ag(a) { var b = a.findFiberByHostInstance; return wh(G({}, a, { findHostInstanceByFiber: function (a) { a = We(a); return null === a ? null : a.stateNode }, findFiberByHostInstance: function (a) { return b ? b(a) : null } })) } function Rh(a, b, c) { var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: Da, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c } } function xb(a) {
                    this._expirationTime = qg(); this._root = a; this._callbacks = this._next = null; this._hasChildren =
                        this._didComplete = !1; this._children = null; this._defer = !0
                } function Ra() { this._callbacks = null; this._didCommit = !1; this._onCommit = this._onCommit.bind(this) } function Sa(a, b, c) { this._internalRoot = Cf(a, b, c) } function Jd(a) { return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue)) } function Sh(a, b) {
                    b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot"))); if (!b) for (var c; c = a.lastChild;)a.removeChild(c);
                    return new Sa(a, !1, b)
                } function mc(a, b, c, d, e) { Jd(c) ? void 0 : m("200"); var f = c._reactRootContainer; if (f) { if ("function" === typeof e) { var g = e; e = function () { var a = lc(f._internalRoot); g.call(a) } } null != a ? f.legacy_renderSubtreeIntoContainer(a, b, e) : f.render(b, e) } else { f = c._reactRootContainer = Sh(c, d); if ("function" === typeof e) { var h = e; e = function () { var a = lc(f._internalRoot); h.call(a) } } Hd(function () { null != a ? f.legacy_renderSubtreeIntoContainer(a, b, e) : f.render(b, e) }) } return lc(f._internalRoot) } function Bg(a, b) {
                    var c =
                        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; Jd(b) ? void 0 : m("200"); return Rh(a, b, null, c)
                } var Tg = function (a, b, c, d, e, f, g, h) { if (!a) { if (void 0 === b) a = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var k = [c, d, e, f, g, h], l = 0; a = Error(b.replace(/%s/g, function () { return k[l++] })); a.name = "Invariant Violation" } a.framesToPop = 1; throw a; } }; ma ? void 0 : m("227"); var Th = function (a, b, c, d, e, f, g, h, k) {
                    this._hasCaughtError =
                        !1; this._caughtError = null; var l = Array.prototype.slice.call(arguments, 3); try { b.apply(c, l) } catch (xh) { this._caughtError = xh, this._hasCaughtError = !0 }
                }, r = {
                    _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, invokeGuardedCallback: function (a, b, c, d, e, f, g, h, k) { Th.apply(r, arguments) }, invokeGuardedCallbackAndCatchFirstError: function (a, b, c, d, e, f, g, h, k) {
                        r.invokeGuardedCallback.apply(this, arguments); if (r.hasCaughtError()) {
                            var l = r.clearCaughtError(); r._hasRethrowError || (r._hasRethrowError =
                                !0, r._rethrowError = l)
                        }
                    }, rethrowCaughtError: function () { return Uh.apply(r, arguments) }, hasCaughtError: function () { return r._hasCaughtError }, clearCaughtError: function () { if (r._hasCaughtError) { var a = r._caughtError; r._caughtError = null; r._hasCaughtError = !1; return a } m("198") }
                }, Uh = function () { if (r._hasRethrowError) { var a = r._rethrowError; r._rethrowError = null; r._hasRethrowError = !1; throw a; } }, Eb = null, ua = {}, Ua = [], vc = {}, na = {}, Fb = {}, Vh = {
                    plugins: Ua, eventNameDispatchConfigs: vc, registrationNameModules: na, registrationNameDependencies: Fb,
                    possibleRegistrationNames: null, injectEventPluginOrder: Ud, injectEventPluginsByName: Vd
                }, ta = function () { }; ta.thatReturns = Gb; ta.thatReturnsFalse = Gb(!1); ta.thatReturnsTrue = Gb(!0); ta.thatReturnsNull = Gb(null); ta.thatReturnsThis = function () { return this }; ta.thatReturnsArgument = function (a) { return a }; var M = ta, xc = null, qe = null, Xd = null, Wa = null, Cg = function (a, b) {
                    if (a) {
                        var c = a._dispatchListeners, d = a._dispatchInstances; if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++)Wd(a, b, c[e], d[e]); else c &&
                            Wd(a, b, c, d); a._dispatchListeners = null; a._dispatchInstances = null; a.isPersistent() || a.constructor.release(a)
                    }
                }, Ug = function (a) { return Cg(a, !0) }, Vg = function (a) { return Cg(a, !1) }, Kd = { injectEventPluginOrder: Ud, injectEventPluginsByName: Vd }, Wh = { injection: Kd, getListener: wc, runEventsInBatch: yc, runExtractedEventsInBatch: Yd }, Dg = Math.random().toString(36).slice(2), wa = "__reactInternalInstance$" + Dg, ae = "__reactEventHandlers$" + Dg, Eg = {
                    precacheFiberNode: Zd, getClosestInstanceFromNode: Xa, getInstanceFromNode: function (a) {
                        a =
                            a[wa]; return !a || 5 !== a.tag && 6 !== a.tag ? null : a
                    }, getNodeFromInstance: xa, getFiberCurrentPropsFromNode: $d, updateFiberProps: be
                }, Xh = { accumulateTwoPhaseDispatches: ya, accumulateTwoPhaseDispatchesSkipTarget: function (a) { Va(a, Xg) }, accumulateEnterLeaveDispatches: ee, accumulateDirectDispatches: function (a) { Va(a, Yg) } }, nc = !("undefined" === typeof window || !window.document || !window.document.createElement), T = {
                    canUseDOM: nc, canUseWorkers: "undefined" !== typeof Worker, canUseEventListeners: nc && !(!window.addEventListener && !window.attachEvent),
                    canUseViewport: nc && !!window.screen, isInWorker: !nc
                }, za = { animationend: Hb("Animation", "AnimationEnd"), animationiteration: Hb("Animation", "AnimationIteration"), animationstart: Hb("Animation", "AnimationStart"), transitionend: Hb("Transition", "TransitionEnd") }, Ac = {}, fe = {}; T.canUseDOM && (fe = document.createElement("div").style, "AnimationEvent" in window || (delete za.animationend.animation, delete za.animationiteration.animation, delete za.animationstart.animation), "TransitionEvent" in window || delete za.transitionend.transition);
    var Fg = Ib("animationend"), Gg = Ib("animationiteration"), Hg = Ib("animationstart"), Ig = Ib("transitionend"), gb = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Bc = null, z = { _root: null, _startText: null, _fallbackText: null }, G = ma.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign, Jg = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
        Yh = { type: null, target: null, currentTarget: M.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function (a) { return a.timeStamp || Date.now() }, defaultPrevented: null, isTrusted: null }; G(L.prototype, {
            preventDefault: function () { this.defaultPrevented = !0; var a = this.nativeEvent; a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = M.thatReturnsTrue) }, stopPropagation: function () {
                var a = this.nativeEvent; a && (a.stopPropagation ? a.stopPropagation() :
                    "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = M.thatReturnsTrue)
            }, persist: function () { this.isPersistent = M.thatReturnsTrue }, isPersistent: M.thatReturnsFalse, destructor: function () { var a = this.constructor.Interface, b; for (b in a) this[b] = null; for (a = 0; a < Jg.length; a++)this[Jg[a]] = null }
        }); L.Interface = Yh; L.extend = function (a) {
            function b() { return c.apply(this, arguments) } var c = this, d = function () { }; d.prototype = c.prototype; d = new d; G(d, b.prototype); b.prototype = d; b.prototype.constructor =
                b; b.Interface = G({}, c.Interface, a); b.extend = c.extend; je(b); return b
        }; je(L); var Zh = L.extend({ data: null }), $h = L.extend({ data: null }), ah = [9, 13, 27, 32], Cc = T.canUseDOM && "CompositionEvent" in window, yb = null; T.canUseDOM && "documentMode" in document && (yb = document.documentMode); var ai = T.canUseDOM && "TextEvent" in window && !yb, oe = T.canUseDOM && (!Cc || yb && 8 < yb && 11 >= yb), ne = String.fromCharCode(32), da = {
            beforeInput: {
                phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["compositionend",
                    "keypress", "textInput", "paste"]
            }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "blur compositionend keydown keypress keyup mousedown".split(" ") }, compositionStart: { phasedRegistrationNames: { bubbled: "onCompositionStart", captured: "onCompositionStartCapture" }, dependencies: "blur compositionstart keydown keypress keyup mousedown".split(" ") }, compositionUpdate: {
                phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" },
                dependencies: "blur compositionupdate keydown keypress keyup mousedown".split(" ")
            }
        }, me = !1, Aa = !1, bi = {
            eventTypes: da, extractEvents: function (a, b, c, d) {
                var e = void 0; var f = void 0; if (Cc) b: { switch (a) { case "compositionstart": e = da.compositionStart; break b; case "compositionend": e = da.compositionEnd; break b; case "compositionupdate": e = da.compositionUpdate; break b }e = void 0 } else Aa ? ke(a, c) && (e = da.compositionEnd) : "keydown" === a && 229 === c.keyCode && (e = da.compositionStart); e ? (oe && (Aa || e !== da.compositionStart ? e === da.compositionEnd &&
                    Aa && (f = he()) : (z._root = d, z._startText = ie(), Aa = !0)), e = Zh.getPooled(e, b, c, d), f ? e.data = f : (f = le(c), null !== f && (e.data = f)), ya(e), f = e) : f = null; (a = ai ? bh(a, c) : ch(a, c)) ? (b = $h.getPooled(da.beforeInput, b, c, d), b.data = a, ya(b)) : b = null; return null === f ? b : null === b ? f : [f, b]
            }
        }, Jb = null, Ba = null, Ca = null, Kg = { injectFiberControlledHostComponent: function (a) { Jb = a } }, ci = { injection: Kg, enqueueStateRestore: re, needsStateRestore: se, restoreStateIfNeeded: te }, ve = function (a, b) { return a(b) }, af = function (a, b, c) { return a(b, c) }, we = function () { },
            Dc = !1, dh = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }, sd = ma.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, V = "function" === typeof Symbol && Symbol.for, Yb = V ? Symbol.for("react.element") : 60103, Da = V ? Symbol.for("react.portal") : 60106, ea = V ? Symbol.for("react.fragment") : 60107, Fe = V ? Symbol.for("react.strict_mode") : 60108, Fc = V ? Symbol.for("react.profiler") : 60114, Ee = V ? Symbol.for("react.provider") :
                60109, De = V ? Symbol.for("react.context") : 60110, Ce = V ? Symbol.for("react.async_mode") : 60111, He = V ? Symbol.for("react.forward_ref") : 60112, Ge = V ? Symbol.for("react.timeout") : 60113, Be = "function" === typeof Symbol && Symbol.iterator, gh = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
            Je = Object.prototype.hasOwnProperty, Le = {}, Ke = {}, u = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) { u[a] = new N(a, 0, !1, a, null) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) { var b = a[0]; u[b] = new N(b, 1, !1, a[1], null) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
                u[a] = new N(a, 2, !1,
                    a.toLowerCase(), null)
            });["autoReverse", "externalResourcesRequired", "preserveAlpha"].forEach(function (a) { u[a] = new N(a, 2, !1, a, null) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) { u[a] = new N(a, 3, !1, a.toLowerCase(), null) });["checked", "multiple", "muted", "selected"].forEach(function (a) { u[a] = new N(a, 3, !0, a.toLowerCase(), null) });
    ["capture", "download"].forEach(function (a) { u[a] = new N(a, 4, !1, a.toLowerCase(), null) });["cols", "rows", "size", "span"].forEach(function (a) { u[a] = new N(a, 6, !1, a.toLowerCase(), null) });["rowSpan", "start"].forEach(function (a) { u[a] = new N(a, 5, !1, a.toLowerCase(), null) }); var Ld = /[\-:]([a-z])/g, Md = function (a) { return a[1].toUpperCase() }; "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
        var b =
            a.replace(Ld, Md); u[b] = new N(b, 1, !1, a, null)
    }); "xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) { var b = a.replace(Ld, Md); u[b] = new N(b, 1, !1, a, "http://www.w3.org/1999/xlink") });["xml:base", "xml:lang", "xml:space"].forEach(function (a) { var b = a.replace(Ld, Md); u[b] = new N(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace") }); u.tabIndex = new N("tabIndex", 1, !1, "tabindex", null); var Qe = {
        change: {
            phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" },
            dependencies: "blur change click focus input keydown keyup selectionchange".split(" ")
        }
    }, $a = null, ab = null, Nd = !1; T.canUseDOM && (Nd = ye("input") && (!document.documentMode || 9 < document.documentMode)); var di = {
        eventTypes: Qe, _isInputEventSupported: Nd, extractEvents: function (a, b, c, d) {
            var e = b ? xa(b) : window, f = void 0, g = void 0, h = e.nodeName && e.nodeName.toLowerCase(); "select" === h || "input" === h && "file" === e.type ? f = kh : xe(e) ? Nd ? f = oh : (f = mh, g = lh) : (h = e.nodeName) && "input" === h.toLowerCase() && ("checkbox" === e.type || "radio" === e.type) &&
                (f = nh); if (f && (f = f(a, b))) return Pe(f, c, d); g && g(a, e, b); "blur" === a && (a = e._wrapperState) && a.controlled && "number" === e.type && Kc(e, "number", e.value)
        }
    }, zb = L.extend({ view: null, detail: null }), qh = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }, Ab = zb.extend({
        screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: Lc, button: null, buttons: null, relatedTarget: function (a) {
            return a.relatedTarget || (a.fromElement ===
                a.srcElement ? a.toElement : a.fromElement)
        }
    }), Lg = Ab.extend({ pointerId: null, width: null, height: null, pressure: null, tiltX: null, tiltY: null, pointerType: null, isPrimary: null }), Bb = {
        mouseEnter: { registrationName: "onMouseEnter", dependencies: ["mouseout", "mouseover"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["mouseout", "mouseover"] }, pointerEnter: { registrationName: "onPointerEnter", dependencies: ["pointerout", "pointerover"] }, pointerLeave: {
            registrationName: "onPointerLeave", dependencies: ["pointerout",
                "pointerover"]
        }
    }, ei = {
        eventTypes: Bb, extractEvents: function (a, b, c, d) {
            var e = "mouseover" === a || "pointerover" === a, f = "mouseout" === a || "pointerout" === a; if (e && (c.relatedTarget || c.fromElement) || !f && !e) return null; e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window; f ? (f = b, b = (b = c.relatedTarget || c.toElement) ? Xa(b) : null) : f = null; if (f === b) return null; var g = void 0, h = void 0, k = void 0, l = void 0; if ("mouseout" === a || "mouseover" === a) g = Ab, h = Bb.mouseLeave, k = Bb.mouseEnter, l = "mouse"; else if ("pointerout" ===
                a || "pointerover" === a) g = Lg, h = Bb.pointerLeave, k = Bb.pointerEnter, l = "pointer"; a = null == f ? e : xa(f); e = null == b ? e : xa(b); h = g.getPooled(h, f, c, d); h.type = l + "leave"; h.target = a; h.relatedTarget = e; c = g.getPooled(k, b, c, d); c.type = l + "enter"; c.target = e; c.relatedTarget = a; ee(h, c, f, b); return [h, c]
        }
    }, Qc = function (a) { a = a || ("undefined" !== typeof document ? document : void 0); if ("undefined" === typeof a) return null; try { return a.activeElement || a.body } catch (b) { return a.body } }, fi = Object.prototype.hasOwnProperty, Rc = function (a, b) {
        if (Te(a, b)) return !0;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1; var c = Object.keys(a), d = Object.keys(b); if (c.length !== d.length) return !1; for (d = 0; d < c.length; d++)if (!fi.call(b, c[d]) || !Te(a[c[d]], b[c[d]])) return !1; return !0
    }, gi = L.extend({ animationName: null, elapsedTime: null, pseudoElement: null }), hi = L.extend({ clipboardData: function (a) { return "clipboardData" in a ? a.clipboardData : window.clipboardData } }), ii = zb.extend({ relatedTarget: null }), ji = {
        Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight",
        Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified"
    }, ki = {
        8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock",
        145: "ScrollLock", 224: "Meta"
    }, li = zb.extend({
        key: function (a) { if (a.key) { var b = ji[a.key] || a.key; if ("Unidentified" !== b) return b } return "keypress" === a.type ? (a = Mb(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? ki[a.keyCode] || "Unidentified" : "" }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: Lc, charCode: function (a) { return "keypress" === a.type ? Mb(a) : 0 }, keyCode: function (a) {
            return "keydown" === a.type || "keyup" === a.type ? a.keyCode :
                0
        }, which: function (a) { return "keypress" === a.type ? Mb(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0 }
    }), mi = Ab.extend({ dataTransfer: null }), ni = zb.extend({ touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: Lc }), oi = L.extend({ propertyName: null, elapsedTime: null, pseudoElement: null }), pi = Ab.extend({
        deltaX: function (a) { return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0 }, deltaY: function (a) {
            return "deltaY" in a ? a.deltaY : "wheelDeltaY" in
                a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0
        }, deltaZ: null, deltaMode: null
    }), qi = [["abort", "abort"], [Fg, "animationEnd"], [Gg, "animationIteration"], [Hg, "animationStart"], ["canplay", "canPlay"], ["canplaythrough", "canPlayThrough"], ["drag", "drag"], ["dragenter", "dragEnter"], ["dragexit", "dragExit"], ["dragleave", "dragLeave"], ["dragover", "dragOver"], ["durationchange", "durationChange"], ["emptied", "emptied"], ["encrypted", "encrypted"], ["ended", "ended"], ["error", "error"], ["gotpointercapture", "gotPointerCapture"],
    ["load", "load"], ["loadeddata", "loadedData"], ["loadedmetadata", "loadedMetadata"], ["loadstart", "loadStart"], ["lostpointercapture", "lostPointerCapture"], ["mousemove", "mouseMove"], ["mouseout", "mouseOut"], ["mouseover", "mouseOver"], ["playing", "playing"], ["pointermove", "pointerMove"], ["pointerout", "pointerOut"], ["pointerover", "pointerOver"], ["progress", "progress"], ["scroll", "scroll"], ["seeking", "seeking"], ["stalled", "stalled"], ["suspend", "suspend"], ["timeupdate", "timeUpdate"], ["toggle", "toggle"], ["touchmove",
        "touchMove"], [Ig, "transitionEnd"], ["waiting", "waiting"], ["wheel", "wheel"]], Ye = {}, Mc = {};[["blur", "blur"], ["cancel", "cancel"], ["click", "click"], ["close", "close"], ["contextmenu", "contextMenu"], ["copy", "copy"], ["cut", "cut"], ["dblclick", "doubleClick"], ["dragend", "dragEnd"], ["dragstart", "dragStart"], ["drop", "drop"], ["focus", "focus"], ["input", "input"], ["invalid", "invalid"], ["keydown", "keyDown"], ["keypress", "keyPress"], ["keyup", "keyUp"], ["mousedown", "mouseDown"], ["mouseup", "mouseUp"], ["paste", "paste"], ["pause",
            "pause"], ["play", "play"], ["pointercancel", "pointerCancel"], ["pointerdown", "pointerDown"], ["pointerup", "pointerUp"], ["ratechange", "rateChange"], ["reset", "reset"], ["seeked", "seeked"], ["submit", "submit"], ["touchcancel", "touchCancel"], ["touchend", "touchEnd"], ["touchstart", "touchStart"], ["volumechange", "volumeChange"]].forEach(function (a) { Xe(a, !0) }); qi.forEach(function (a) { Xe(a, !1) }); var Mg = {
                eventTypes: Ye, isInteractiveTopLevelEventType: function (a) { a = Mc[a]; return void 0 !== a && !0 === a.isInteractive }, extractEvents: function (a,
                    b, c, d) {
                    var e = Mc[a]; if (!e) return null; switch (a) {
                        case "keypress": if (0 === Mb(c)) return null; case "keydown": case "keyup": a = li; break; case "blur": case "focus": a = ii; break; case "click": if (2 === c.button) return null; case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": a = Ab; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": a = mi; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": a =
                            ni; break; case Fg: case Gg: case Hg: a = gi; break; case Ig: a = oi; break; case "scroll": a = zb; break; case "wheel": a = pi; break; case "copy": case "cut": case "paste": a = hi; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": a = Lg; break; default: a = L
                    }b = a.getPooled(e, b, c, d); ya(b); return b
                }
            }, Ze = Mg.isInteractiveTopLevelEventType, Ob = [], cb = !0, ri = {
                get _enabled() { return cb }, setEnabled: Nc, isEnabled: function () { return cb },
                trapBubbledEvent: p, trapCapturedEvent: db, dispatchEvent: Nb
            }, cf = {}, th = 0, Pb = "_reactListenersID" + ("" + Math.random()).slice(2), ef = function (a) { var b = (a ? a.ownerDocument || a : document).defaultView || window; return !!(a && ("function" === typeof b.Node ? a instanceof b.Node : "object" === typeof a && "number" === typeof a.nodeType && "string" === typeof a.nodeName)) && 3 == a.nodeType }, Ph = df, si = T.canUseDOM && "documentMode" in document && 11 >= document.documentMode, jf = {
                select: {
                    phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" },
                    dependencies: "blur contextmenu focus keydown keyup mousedown mouseup selectionchange".split(" ")
                }
            }, Ea = null, Sc = null, eb = null, Pc = !1, ti = {
                eventTypes: jf, extractEvents: function (a, b, c, d) {
                    var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument, f; if (!(f = !e)) { a: { e = bf(e); f = Fb.onSelect; for (var g = 0; g < f.length; g++) { var h = f[g]; if (!e.hasOwnProperty(h) || !e[h]) { e = !1; break a } } e = !0 } f = !e } if (f) return null; e = b ? xa(b) : window; switch (a) {
                        case "focus": if (xe(e) || "true" === e.contentEditable) Ea = e, Sc = b, eb = null; break; case "blur": eb =
                            Sc = Ea = null; break; case "mousedown": Pc = !0; break; case "contextmenu": case "mouseup": return Pc = !1, hf(c, d); case "selectionchange": if (si) break; case "keydown": case "keyup": return hf(c, d)
                    }return null
                }
            }; Kd.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" ")); (function (a) { xc = a.getFiberCurrentPropsFromNode; qe = a.getInstanceFromNode; Xd = a.getNodeFromInstance })(Eg); Kd.injectEventPluginsByName({
                SimpleEventPlugin: Mg,
                EnterLeaveEventPlugin: ei, ChangeEventPlugin: di, SelectEventPlugin: ti, BeforeInputEventPlugin: bi
            }); var Y = {}, Ng = "function" === typeof requestAnimationFrame ? requestAnimationFrame : void 0, ui = Date, vi = setTimeout, wi = clearTimeout, la = void 0; if ("object" === typeof performance && "function" === typeof performance.now) { var xi = performance; la = function () { return xi.now() } } else la = function () { return ui.now() }; var Od = void 0, oc = void 0; if (T.canUseDOM) {
                var Og = "function" === typeof Ng ? Ng : function (a) { m("276") }, R = null, pc = null, Ta = -1, qc =
                    !1, Cb = !1, rc = 0, sc = 33, Db = 33, tc = { didTimeout: !1, timeRemaining: function () { var a = rc - la(); return 0 < a ? a : 0 } }, Pg = function (a, b) { var c = a.scheduledCallback, d = !1; try { c(b), d = !0 } finally { oc(a), d || (qc = !0, window.postMessage(Pd, "*")) } }, Pd = "__reactIdleCallback$" + Math.random().toString(36).slice(2); window.addEventListener("message", function (a) {
                        if (a.source === window && a.data === Pd && (qc = !1, null !== R)) {
                            if (null !== R) {
                                var b = la(); if (!(-1 === Ta || Ta > b)) {
                                    a = -1; for (var c = [], d = R; null !== d;) {
                                        var e = d.timeoutTime; -1 !== e && e <= b ? c.push(d) : -1 !==
                                            e && (-1 === a || e < a) && (a = e); d = d.next
                                    } if (0 < c.length) for (tc.didTimeout = !0, b = 0, d = c.length; b < d; b++)Pg(c[b], tc); Ta = a
                                }
                            } for (a = la(); 0 < rc - a && null !== R;)a = R, tc.didTimeout = !1, Pg(a, tc), a = la(); null === R || Cb || (Cb = !0, Og(Qg))
                        }
                    }, !1); var Qg = function (a) { Cb = !1; var b = a - rc + Db; b < Db && sc < Db ? (8 > b && (b = 8), Db = b < sc ? sc : b) : sc = b; rc = a + Db; qc || (qc = !0, window.postMessage(Pd, "*")) }; Od = function (a, b) {
                        var c = -1; null != b && "number" === typeof b.timeout && (c = la() + b.timeout); if (-1 === Ta || -1 !== c && c < Ta) Ta = c; a = { scheduledCallback: a, timeoutTime: c, prev: null, next: null };
                        null === R ? R = a : (b = a.prev = pc, null !== b && (b.next = a)); pc = a; Cb || (Cb = !0, Og(Qg)); return a
                    }; oc = function (a) { if (null !== a.prev || R === a) { var b = a.next, c = a.prev; a.next = null; a.prev = null; null !== b ? null !== c ? (c.next = b, b.prev = c) : (b.prev = null, R = b) : null !== c ? (c.next = null, pc = c) : pc = R = null } }
            } else {
        var Qd = new Map; Od = function (a, b) { b = { scheduledCallback: a, timeoutTime: 0, next: null, prev: null }; var c = vi(function () { a({ timeRemaining: function () { return Infinity }, didTimeout: !1 }) }); Qd.set(a, c); return b }; oc = function (a) {
            var b = Qd.get(a.scheduledCallback);
            Qd.delete(a); wi(b)
        }
    } var uc = void 0, sf = function (a) { return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) { MSApp.execUnsafeLocalFunction(function () { return a(b, c, d, e) }) } : a }(function (a, b) { if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b; else { uc = uc || document.createElement("div"); uc.innerHTML = "<svg>" + b + "</svg>"; for (b = uc.firstChild; a.firstChild;)a.removeChild(a.firstChild); for (; b.firstChild;)a.appendChild(b.firstChild) } }), ib = function (a, b) {
        if (b) {
            var c =
                a.firstChild; if (c && c === a.lastChild && 3 === c.nodeType) { c.nodeValue = b; return }
        } a.textContent = b
    }, fb = {
        animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0,
        order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0
    }, yi = ["Webkit", "ms", "Moz", "O"]; Object.keys(fb).forEach(function (a) { yi.forEach(function (b) { b = b + a.charAt(0).toUpperCase() + a.substring(1); fb[b] = fb[a] }) }); var vh = G({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }), hb = M.thatReturns(""),
        zi = {
            createElement: pf, createTextNode: qf, setInitialProperties: rf, diffProperties: tf, updateProperties: uf, diffHydratedProperties: vf, diffHydratedText: wf, warnForUnmatchedText: function (a, b) { }, warnForDeletedHydratableElement: function (a, b) { }, warnForDeletedHydratableText: function (a, b) { }, warnForInsertedHydratedElement: function (a, b, c) { }, warnForInsertedHydratedText: function (a, b) { }, restoreControlledState: function (a, b, c) {
                switch (b) {
                    case "input": Jc(a, c); b = c.name; if ("radio" === c.type && null != b) {
                        for (c = a; c.parentNode;)c =
                            c.parentNode; c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]'); for (b = 0; b < c.length; b++) { var d = c[b]; if (d !== a && d.form === a.form) { var e = $d(d); e ? void 0 : m("90"); Ae(d); Jc(d, e) } }
                    } break; case "textarea": mf(a, c); break; case "select": b = c.value, null != b && Fa(a, !!c.multiple, b, !1)
                }
            }
        }, Dh = pf, Gh = qf, Eh = rf, Bh = tf, Hh = uf, Ch = vf, Fh = wf, $b = Zd, ud = be, Fd = null, Gd = null, Bd = la, Nh = Od, Mh = oc; new Set; var $c = [], Ga = -1, X = fa(Y), x = fa(!1), ad = Y, hd = null, id = null, ia = !1, Mf = fa(null), ld = fa(null), kd = fa(0), lb = {}, U = fa(lb), nb = fa(lb),
            mb = fa(lb), Wb = {
                isMounted: function (a) { return (a = a._reactInternalFiber) ? 2 === bb(a) : !1 }, enqueueSetState: function (a, b, c) { a = a._reactInternalFiber; var d = ba(); d = bc(d, a); var e = Ja(d); e.payload = b; void 0 !== c && null !== c && (e.callback = c); oa(a, e, d); ra(a, d) }, enqueueReplaceState: function (a, b, c) { a = a._reactInternalFiber; var d = ba(); d = bc(d, a); var e = Ja(d); e.tag = 1; e.payload = b; void 0 !== c && null !== c && (e.callback = c); oa(a, e, d); ra(a, d) }, enqueueForceUpdate: function (a, b) {
                    a = a._reactInternalFiber; var c = ba(); c = bc(c, a); var d = Ja(c); d.tag =
                        2; void 0 !== b && null !== b && (d.callback = b); oa(a, d, c); ra(a, c)
                }
            }, Zb = Array.isArray, Wf = Qf(!0), Vf = Qf(!1), Z = null, Ma = null, qa = !1, td = void 0, ag = void 0, bg = void 0; td = function (a) { }; ag = function (a, b, c, d, e, f, g, h) { (b.updateQueue = c) && pb(b) }; bg = function (a, b, c, d) { c !== d && pb(b) }; var Cd = Bd(), og = 2, yd = Cd, Ad = 0, ka = 0, aa = !1, F = null, rb = null, K = 0, ac = -1, sb = !1, l = null, tb = !1, xd = !1, ja = null, sa = null, E = null, dc = 0, ec = void 0, Q = !1, P = null, I = 0, ca = 0, hc = !1, Pa = !1, ic = null, wb = null, H = !1, fc = !1, Na = !1, Oa = null, Lh = 1E3, cc = 0, Qh = 1, Ai = {
                updateContainerAtExpirationTime: Id,
                createContainer: function (a, b, c) { return Cf(a, b, c) }, updateContainer: kc, flushRoot: ug, requestWork: zd, computeUniqueAsyncExpiration: qg, batchedUpdates: vg, unbatchedUpdates: Hd, deferredUpdates: rg, syncUpdates: Dd, interactiveUpdates: xg, flushInteractiveUpdates: function () { Q || 0 === ca || (vb(ca, !1, null), ca = 0) }, flushControlled: yg, flushSync: wg, getPublicRootInstance: lc, findHostInstance: zg, findHostInstanceWithNoPortals: function (a) { a = rh(a); return null === a ? null : a.stateNode }, injectIntoDevTools: Ag
            }; Kg.injectFiberControlledHostComponent(zi);
    xb.prototype.render = function (a) { this._defer ? void 0 : m("250"); this._hasChildren = !0; this._children = a; var b = this._root._internalRoot, c = this._expirationTime, d = new Ra; Id(a, b, null, c, d._onCommit); return d }; xb.prototype.then = function (a) { if (this._didComplete) a(); else { var b = this._callbacks; null === b && (b = this._callbacks = []); b.push(a) } }; xb.prototype.commit = function () {
        var a = this._root._internalRoot, b = a.firstBatch; this._defer && null !== b ? void 0 : m("251"); if (this._hasChildren) {
            var c = this._expirationTime; if (b !== this) {
                this._hasChildren &&
                    (c = this._expirationTime = b._expirationTime, this.render(this._children)); for (var d = null, e = b; e !== this;)d = e, e = e._next; null === d ? m("251") : void 0; d._next = e._next; this._next = b; a.firstBatch = this
            } this._defer = !1; ug(a, c); b = this._next; this._next = null; b = a.firstBatch = b; null !== b && b._hasChildren && b.render(b._children)
        } else this._next = null, this._defer = !1
    }; xb.prototype._onComplete = function () { if (!this._didComplete) { this._didComplete = !0; var a = this._callbacks; if (null !== a) for (var b = 0; b < a.length; b++)(0, a[b])() } }; Ra.prototype.then =
        function (a) { if (this._didCommit) a(); else { var b = this._callbacks; null === b && (b = this._callbacks = []); b.push(a) } }; Ra.prototype._onCommit = function () { if (!this._didCommit) { this._didCommit = !0; var a = this._callbacks; if (null !== a) for (var b = 0; b < a.length; b++) { var c = a[b]; "function" !== typeof c ? m("191", c) : void 0; c() } } }; Sa.prototype.render = function (a, b) { var c = this._internalRoot, d = new Ra; b = void 0 === b ? null : b; null !== b && d.then(b); kc(a, c, null, d._onCommit); return d }; Sa.prototype.unmount = function (a) {
            var b = this._internalRoot,
                c = new Ra; a = void 0 === a ? null : a; null !== a && c.then(a); kc(null, b, null, c._onCommit); return c
        }; Sa.prototype.legacy_renderSubtreeIntoContainer = function (a, b, c) { var d = this._internalRoot, e = new Ra; c = void 0 === c ? null : c; null !== c && e.then(c); kc(b, d, a, e._onCommit); return e }; Sa.prototype.createBatch = function () { var a = new xb(this), b = a._expirationTime, c = this._internalRoot, d = c.firstBatch; if (null === d) c.firstBatch = a, a._next = null; else { for (c = null; null !== d && d._expirationTime <= b;)c = d, d = d._next; a._next = d; null !== c && (c._next = a) } return a };
    (function (a) { ve = a.batchedUpdates; af = a.interactiveUpdates; we = a.flushInteractiveUpdates })(Ai); var Rg = {
        createPortal: Bg, findDOMNode: function (a) { return null == a ? null : 1 === a.nodeType ? a : zg(a) }, hydrate: function (a, b, c) { return mc(null, a, b, !0, c) }, render: function (a, b, c) { return mc(null, a, b, !1, c) }, unstable_renderSubtreeIntoContainer: function (a, b, c, d) { null == a || void 0 === a._reactInternalFiber ? m("38") : void 0; return mc(a, b, c, !1, d) }, unmountComponentAtNode: function (a) {
            Jd(a) ? void 0 : m("40"); return a._reactRootContainer ? (Hd(function () {
                mc(null,
                    null, a, !1, function () { a._reactRootContainer = null })
            }), !0) : !1
        }, unstable_createPortal: function () { return Bg.apply(void 0, arguments) }, unstable_batchedUpdates: vg, unstable_deferredUpdates: rg, unstable_interactiveUpdates: xg, flushSync: wg, unstable_flushControlled: yg, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { EventPluginHub: Wh, EventPluginRegistry: Vh, EventPropagators: Xh, ReactControlledComponent: ci, ReactDOMComponentTree: Eg, ReactDOMEventListener: ri }, unstable_createRoot: function (a, b) {
            return new Sa(a, !0, null !=
                b && !0 === b.hydrate)
        }
    }; Ag({ findFiberByHostInstance: Xa, bundleType: 0, version: "16.4.2", rendererPackageName: "react-dom" }); var Sg = { default: Rg }, Rd = Sg && Rg || Sg; return Rd.default ? Rd.default : Rd
});

/*** https://unpkg.com/react-transition-group@2.2.1/dist/react-transition-group.min.js ***/

!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e(require("react"), require("react-dom")) : "function" == typeof define && define.amd ? define(["react", "react-dom"], e) : "object" == typeof exports ? exports.ReactTransitionGroup = e(require("react"), require("react-dom")) : t.ReactTransitionGroup = e(t.React, t.ReactDOM) }(this, function (t, e) { return function (t) { function e(r) { if (n[r]) return n[r].exports; var o = n[r] = { i: r, l: !1, exports: {} }; return t[r].call(o.exports, o, o.exports, e), o.l = !0, o.exports } var n = {}; return e.m = t, e.c = n, e.i = function (t) { return t }, e.d = function (t, n, r) { e.o(t, n) || Object.defineProperty(t, n, { configurable: !1, enumerable: !0, get: r }) }, e.n = function (t) { var n = t && t.__esModule ? function () { return t.default } : function () { return t }; return e.d(n, "a", n), n }, e.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, e.p = "", e(e.s = 12) }([function (t, e, n) { "use strict"; "function" == typeof Symbol && Symbol.iterator; t.exports = n(11)() }, function (e, n) { e.exports = t }, function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { default: t } } function o(t, e) { var n = {}; for (var r in t) e.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]); return n } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function a(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e } function s(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } function u() { } e.__esModule = !0, e.EXITING = e.ENTERED = e.ENTERING = e.EXITED = e.UNMOUNTED = void 0; var l = n(0), c = function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e.default = t, e }(l), p = n(1), f = r(p), d = n(14), h = r(d), E = (n(3), e.UNMOUNTED = "unmounted"), x = e.EXITED = "exited", m = e.ENTERING = "entering", y = e.ENTERED = "entered", v = e.EXITING = "exiting", g = function (t) { function e(n, r) { i(this, e); var o = a(this, t.call(this, n, r)), s = r.transitionGroup, u = s && !s.isMounting ? n.enter : n.appear, l = void 0; return o.nextStatus = null, n.in ? u ? (l = x, o.nextStatus = m) : l = y : l = n.unmountOnExit || n.mountOnEnter ? E : x, o.state = { status: l }, o.nextCallback = null, o } return s(e, t), e.prototype.getChildContext = function () { return { transitionGroup: null } }, e.prototype.componentDidMount = function () { this.updateStatus(!0) }, e.prototype.componentWillReceiveProps = function (t) { var e = this.pendingState || this.state, n = e.status; t.in ? (n === E && this.setState({ status: x }), n !== m && n !== y && (this.nextStatus = m)) : n !== m && n !== y || (this.nextStatus = v) }, e.prototype.componentDidUpdate = function () { this.updateStatus() }, e.prototype.componentWillUnmount = function () { this.cancelNextCallback() }, e.prototype.getTimeouts = function () { var t = this.props.timeout, e = void 0, n = void 0, r = void 0; return e = n = r = t, null != t && "number" != typeof t && (e = t.exit, n = t.enter, r = t.appear), { exit: e, enter: n, appear: r } }, e.prototype.updateStatus = function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = this.nextStatus; if (null !== e) { this.nextStatus = null, this.cancelNextCallback(); var n = h.default.findDOMNode(this); e === m ? this.performEnter(n, t) : this.performExit(n) } else this.props.unmountOnExit && this.state.status === x && this.setState({ status: E }) }, e.prototype.performEnter = function (t, e) { var n = this, r = this.props.enter, o = this.context.transitionGroup ? this.context.transitionGroup.isMounting : e, i = this.getTimeouts(); if (!e && !r) return void this.safeSetState({ status: y }, function () { n.props.onEntered(t) }); this.props.onEnter(t, o), this.safeSetState({ status: m }, function () { n.props.onEntering(t, o), n.onTransitionEnd(t, i.enter, function () { n.safeSetState({ status: y }, function () { n.props.onEntered(t, o) }) }) }) }, e.prototype.performExit = function (t) { var e = this, n = this.props.exit, r = this.getTimeouts(); if (!n) return void this.safeSetState({ status: x }, function () { e.props.onExited(t) }); this.props.onExit(t), this.safeSetState({ status: v }, function () { e.props.onExiting(t), e.onTransitionEnd(t, r.exit, function () { e.safeSetState({ status: x }, function () { e.props.onExited(t) }) }) }) }, e.prototype.cancelNextCallback = function () { null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null) }, e.prototype.safeSetState = function (t, e) { var n = this; this.pendingState = t, e = this.setNextCallback(e), this.setState(t, function () { n.pendingState = null, e() }) }, e.prototype.setNextCallback = function (t) { var e = this, n = !0; return this.nextCallback = function (r) { n && (n = !1, e.nextCallback = null, t(r)) }, this.nextCallback.cancel = function () { n = !1 }, this.nextCallback }, e.prototype.onTransitionEnd = function (t, e, n) { this.setNextCallback(n), t ? (this.props.addEndListener && this.props.addEndListener(t, this.nextCallback), null != e && setTimeout(this.nextCallback, e)) : setTimeout(this.nextCallback, 0) }, e.prototype.render = function () { var t = this.state.status; if (t === E) return null; var e = this.props, n = e.children, r = o(e, ["children"]); if (delete r.in, delete r.mountOnEnter, delete r.unmountOnExit, delete r.appear, delete r.enter, delete r.exit, delete r.timeout, delete r.addEndListener, delete r.onEnter, delete r.onEntering, delete r.onEntered, delete r.onExit, delete r.onExiting, delete r.onExited, "function" == typeof n) return n(t, r); var i = f.default.Children.only(n); return f.default.cloneElement(i, r) }, e }(f.default.Component); g.contextTypes = { transitionGroup: c.object }, g.childContextTypes = { transitionGroup: function () { } }, g.propTypes = {}, g.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: u, onEntering: u, onEntered: u, onExit: u, onExiting: u, onExited: u }, g.UNMOUNTED = 0, g.EXITED = 1, g.ENTERING = 2, g.ENTERED = 3, g.EXITING = 4, e.default = g }, function (t, e, n) { "use strict"; function r(t) { var e = "transition" + t + "Timeout", n = "transition" + t; return function (t) { if (t[n]) { if (null == t[e]) return new Error(e + " wasn't supplied to CSSTransitionGroup: this can cause unreliable animations and won't be supported in a future version of React. See https://fb.me/react-animation-transition-group-timeout for more information."); if ("number" != typeof t[e]) return new Error(e + " must be a number (in milliseconds)") } return null } } e.__esModule = !0, e.classNamesShape = e.timeoutsShape = void 0, e.transitionTimeout = r; var o = n(0), i = function (t) { return t && t.__esModule ? t : { default: t } }(o); e.timeoutsShape = i.default.oneOfType([i.default.number, i.default.shape({ enter: i.default.number, exit: i.default.number }).isRequired]), e.classNamesShape = i.default.oneOfType([i.default.string, i.default.shape({ enter: i.default.string, exit: i.default.string, active: i.default.string }), i.default.shape({ enter: i.default.string, enterActive: i.default.string, exit: i.default.string, exitActive: i.default.string })]) }, function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { default: t } } function o(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e } function a(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } e.__esModule = !0; var s = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, u = n(0), l = function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e.default = t, e }(u), c = n(6), p = r(c), f = n(8), d = r(f), h = n(1), E = r(h), x = n(2), m = r(x), y = n(3), v = function (t, e) { return e && e.split(" ").forEach(function (e) { return (0, p.default)(t, e) }) }, g = function (t, e) { return e && e.split(" ").forEach(function (e) { return (0, d.default)(t, e) }) }, b = (s({}, m.default.propTypes, { classNames: y.classNamesShape, onEnter: l.func, onEntering: l.func, onEntered: l.func, onExit: l.func, onExiting: l.func, onExited: l.func }), function (t) { function e() { var n, r, a; o(this, e); for (var s = arguments.length, u = Array(s), l = 0; l < s; l++)u[l] = arguments[l]; return n = r = i(this, t.call.apply(t, [this].concat(u))), r.onEnter = function (t, e) { var n = r.getClassNames(e ? "appear" : "enter"), o = n.className; r.removeClasses(t, "exit"), v(t, o), r.props.onEnter && r.props.onEnter(t) }, r.onEntering = function (t, e) { var n = r.getClassNames(e ? "appear" : "enter"), o = n.activeClassName; r.reflowAndAddClass(t, o), r.props.onEntering && r.props.onEntering(t) }, r.onEntered = function (t, e) { r.removeClasses(t, e ? "appear" : "enter"), r.props.onEntered && r.props.onEntered(t) }, r.onExit = function (t) { var e = r.getClassNames("exit"), n = e.className; r.removeClasses(t, "appear"), r.removeClasses(t, "enter"), v(t, n), r.props.onExit && r.props.onExit(t) }, r.onExiting = function (t) { var e = r.getClassNames("exit"), n = e.activeClassName; r.reflowAndAddClass(t, n), r.props.onExiting && r.props.onExiting(t) }, r.onExited = function (t) { r.removeClasses(t, "exit"), r.props.onExited && r.props.onExited(t) }, r.getClassNames = function (t) { var e = r.props.classNames, n = "string" != typeof e ? e[t] : e + "-" + t; return { className: n, activeClassName: "string" != typeof e ? e[t + "Active"] : n + "-active" } }, a = n, i(r, a) } return a(e, t), e.prototype.removeClasses = function (t, e) { var n = this.getClassNames(e), r = n.className, o = n.activeClassName; r && g(t, r), o && g(t, o) }, e.prototype.reflowAndAddClass = function (t, e) { t.scrollTop, v(t, e) }, e.prototype.render = function () { var t = s({}, this.props); return delete t.classNames, E.default.createElement(m.default, s({}, t, { onEnter: this.onEnter, onEntered: this.onEntered, onEntering: this.onEntering, onExit: this.onExit, onExiting: this.onExiting, onExited: this.onExited })) }, e }(E.default.Component)); b.propTypes = {}, e.default = b, t.exports = e.default }, function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { default: t } } function o(t, e) { var n = {}; for (var r in t) e.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]); return n } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function a(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e } function s(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } e.__esModule = !0; var u = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, l = n(0), c = r(l), p = n(1), f = r(p), d = n(13), h = Object.values || function (t) { return Object.keys(t).map(function (e) { return t[e] }) }, E = (c.default.any, c.default.node, c.default.bool, c.default.bool, c.default.bool, c.default.func, { component: "div", childFactory: function (t) { return t } }), x = function (t) { function e(n, r) { i(this, e); var o = a(this, t.call(this, n, r)); return o.handleExited = function (t, e, n) { var r = (0, d.getChildMapping)(o.props.children); t in r || (n && n(e), o.setState(function (e) { var n = u({}, e.children); return delete n[t], { children: n } })) }, o.state = { children: (0, d.getChildMapping)(n.children, function (t) { var e = function (e) { o.handleExited(t.key, e, t.props.onExited) }; return (0, p.cloneElement)(t, { onExited: e, in: !0, appear: o.getProp(t, "appear"), enter: o.getProp(t, "enter"), exit: o.getProp(t, "exit") }) }) }, o } return s(e, t), e.prototype.getChildContext = function () { return { transitionGroup: { isMounting: !this.appeared } } }, e.prototype.getProp = function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.props; return null != n[e] ? n[e] : t.props[e] }, e.prototype.componentDidMount = function () { this.appeared = !0 }, e.prototype.componentWillReceiveProps = function (t) { var e = this, n = this.state.children, r = (0, d.getChildMapping)(t.children), o = (0, d.mergeChildMappings)(n, r); Object.keys(o).forEach(function (i) { var a = o[i]; if ((0, p.isValidElement)(a)) { var s = function (t) { e.handleExited(a.key, t, a.props.onExited) }, u = i in n, l = i in r, c = n[i], f = (0, p.isValidElement)(c) && !c.props.in; !l || u && !f ? l || !u || f ? l && u && (0, p.isValidElement)(c) && (o[i] = (0, p.cloneElement)(a, { onExited: s, in: c.props.in, exit: e.getProp(a, "exit", t), enter: e.getProp(a, "enter", t) })) : o[i] = (0, p.cloneElement)(a, { in: !1 }) : o[i] = (0, p.cloneElement)(a, { onExited: s, in: !0, exit: e.getProp(a, "exit", t), enter: e.getProp(a, "enter", t) }) } }), this.setState({ children: o }) }, e.prototype.render = function () { var t = this.props, e = t.component, n = t.childFactory, r = o(t, ["component", "childFactory"]), i = this.state.children; return delete r.appear, delete r.enter, delete r.exit, f.default.createElement(e, r, h(i).map(n)) }, e }(f.default.Component); x.childContextTypes = { transitionGroup: c.default.object.isRequired }, x.propTypes = {}, x.defaultProps = E, e.default = x, t.exports = e.default }, function (t, e, n) { "use strict"; function r(t, e) { t.classList ? t.classList.add(e) : (0, i.default)(t) || (t.className = t.className + " " + e) } Object.defineProperty(e, "__esModule", { value: !0 }), e.default = r; var o = n(7), i = function (t) { return t && t.__esModule ? t : { default: t } }(o); t.exports = e.default }, function (t, e, n) { "use strict"; function r(t, e) { return t.classList ? !!e && t.classList.contains(e) : -1 !== (" " + t.className + " ").indexOf(" " + e + " ") } Object.defineProperty(e, "__esModule", { value: !0 }), e.default = r, t.exports = e.default }, function (t, e, n) { "use strict"; t.exports = function (t, e) { t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(^|\\s)" + e + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "") } }, function (t, e, n) { "use strict"; function r(t) { return function () { return t } } var o = function () { }; o.thatReturns = r, o.thatReturnsFalse = r(!1), o.thatReturnsTrue = r(!0), o.thatReturnsNull = r(null), o.thatReturnsThis = function () { return this }, o.thatReturnsArgument = function (t) { return t }, t.exports = o }, function (t, e, n) { "use strict"; function r(t, e, n, r, i, a, s, u) { if (o(e), !t) { var l; if (void 0 === e) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var c = [n, r, i, a, s, u], p = 0; l = new Error(e.replace(/%s/g, function () { return c[p++] })), l.name = "Invariant Violation" } throw l.framesToPop = 1, l } } var o = function (t) { }; t.exports = r }, function (t, e, n) { "use strict"; var r = n(9), o = n(10); t.exports = function () { function t() { o(!1) } function e() { return t } t.isRequired = t; var n = { array: t, bool: t, func: t, number: t, object: t, string: t, symbol: t, any: t, arrayOf: e, element: t, instanceOf: e, node: t, objectOf: e, oneOf: e, oneOfType: e, shape: e }; return n.checkPropTypes = r, n.PropTypes = n, n } }, function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { default: t } } var o = n(4), i = r(o), a = n(5), s = r(a), u = n(2), l = r(u); t.exports = { Transition: l.default, TransitionGroup: s.default, CSSTransition: i.default } }, function (t, e, n) { "use strict"; function r(t, e) { var n = function (t) { return e && (0, i.isValidElement)(t) ? e(t) : t }, r = Object.create(null); return t && i.Children.map(t, function (t) { return t }).forEach(function (t) { r[t.key] = n(t) }), r } function o(t, e) { function n(n) { return n in e ? e[n] : t[n] } t = t || {}, e = e || {}; var r = Object.create(null), o = []; for (var i in t) i in e ? o.length && (r[i] = o, o = []) : o.push(i); var a = void 0, s = {}; for (var u in e) { if (r[u]) for (a = 0; a < r[u].length; a++) { var l = r[u][a]; s[r[u][a]] = n(l) } s[u] = n(u) } for (a = 0; a < o.length; a++)s[o[a]] = n(o[a]); return s } e.__esModule = !0, e.getChildMapping = r, e.mergeChildMappings = o; var i = n(1) }, function (t, n) { t.exports = e }]) });
/*!
 * react-simple-colorpicker 1.4.2 - Colorpicker for React
 * Copyright (c) 2017 Nick Williams - https://github.com/WickyNilliams/react-simple-colorpicker
 * Licensed under the MIT license
 */
!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e(require("react"), require("react-dom")) : "function" == typeof define && define.amd ? define(["react", "react-dom"], e) : "object" == typeof exports ? exports.ColorPicker = e(require("react"), require("react-dom")) : t.ColorPicker = e(t.React, t.ReactDOM) }(this, function (t, e) { return function (t) { function e(r) { if (n[r]) return n[r].exports; var o = n[r] = { exports: {}, id: r, loaded: !1 }; return t[r].call(o.exports, o, o.exports, e), o.loaded = !0, o.exports } var n = {}; return e.m = t, e.c = n, e.p = "", e(0) }([function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { "default": t } } var o = n(9), a = r(o); t.exports = a.default }, function (e, n) { e.exports = t }, function (t, e, n) { t.exports = n(19)() }, function (t, e, n) { var r, o; !function () { "use strict"; function n() { for (var t = [], e = 0; e < arguments.length; e++) { var r = arguments[e]; if (r) { var o = typeof r; if ("string" === o || "number" === o) t.push(r); else if (Array.isArray(r)) t.push(n.apply(null, r)); else if ("object" === o) for (var i in r) a.call(r, i) && r[i] && t.push(i) } } return t.join(" ") } var a = {}.hasOwnProperty; void 0 !== t && t.exports ? t.exports = n : (r = [], o = function () { return n }.apply(e, r), !(void 0 !== o && (t.exports = o))) }() }, function (t, e, n) { "use strict"; var r = n(1), o = n(14); if (void 0 === r) throw Error("create-react-class could not find the React object. If you are using script tags, make sure that React is being loaded before create-react-class."); var a = (new r.Component).updater; t.exports = o(r.Component, r.isValidElement, a) }, function (t, e, n) { "use strict"; var r = n(18); t.exports = { shouldComponentUpdate: function (t, e) { return !r(this.props, t) || !r(this.state, e) } } }, function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { "default": t } } function o() { } Object.defineProperty(e, "__esModule", { value: !0 }); var a = n(1), i = (r(a), n(32)), s = r(i), u = n(2), c = r(u), l = n(13), f = r(l), p = function (t) { return t.ownerDocument }, d = { propTypes: { onChange: c.default.func.isRequired, max: c.default.number }, getDefaultProps: function () { return { onChange: o, max: 1 } }, getInitialState: function () { return { active: !1 } }, componentDidMount: function () { this.document = p(s.default.findDOMNode(this)), this.rect = this.getBoundingRect() }, startUpdates: function (t) { var e = this.document; e.addEventListener("mousemove", this.handleUpdate), e.addEventListener("touchmove", this.handleUpdate), e.addEventListener("mouseup", this.stopUpdates), e.addEventListener("touchend", this.stopUpdates), t.preventDefault(); var n = this.getPosition(t), r = n.x, o = n.y; this.rect = this.getBoundingRect(), this.setState({ active: !0 }), this.updatePosition(this.rect, r, o) }, handleUpdate: function (t) { t.preventDefault(); var e = this.getPosition(t), n = e.x, r = e.y; this.updatePosition(this.rect, n, r) }, stopUpdates: function () { var t = this.document; t.removeEventListener("mousemove", this.handleUpdate), t.removeEventListener("touchmove", this.handleUpdate), t.removeEventListener("mouseup", this.stopUpdates), t.removeEventListener("touchend", this.stopUpdates), this.setState({ active: !1 }) }, getPosition: function (t) { return t.touches && (t = t.touches[0]), { x: t.clientX, y: t.clientY } }, getPercentageValue: function (t) { return t / this.props.max * 100 + "%" }, getScaledValue: function (t) { return (0, f.default)(t, 0, 1) * this.props.max }, getBoundingRect: function () { return s.default.findDOMNode(this).getBoundingClientRect() } }; e.default = d }, function (t, e) { function n(t) { return t.match(r) } var r = /-?\d+(\.\d+)?%?/g; t.exports = n }, function (t, e) { function n(t, e, n) { return Math.min(Math.max(t, e), n) } t.exports = n }, function (t, e, n) { "use strict"; function r(t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e.default = t, e } function o(t) { return t && t.__esModule ? t : { "default": t } } Object.defineProperty(e, "__esModule", { value: !0 }); var a = function () { function t(t, e) { var n = [], r = !0, o = !1, a = void 0; try { for (var i, s = t[Symbol.iterator](); !(r = (i = s.next()).done) && (n.push(i.value), !e || n.length !== e); r = !0); } catch (u) { o = !0, a = u } finally { try { !r && s.return && s.return() } finally { if (o) throw a } } return n } return function (e, n) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, n); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(), i = n(1), s = o(i), u = n(4), c = o(u), l = n(2), f = o(l), p = n(5), d = o(p), h = n(3), m = o(h), v = n(10), g = o(v), y = n(11), b = o(y), E = n(12), x = r(E), _ = (0, c.default)({ mixins: [d.default], propTypes: { color: f.default.string.isRequired, onChange: f.default.func.isRequired }, getDefaultProps: function () { return { color: "rgba(0,0,0,1)", opacitySlider: !1 } }, getInitialState: function () { return this.getStateFrom(this.props) }, componentWillReceiveProps: function (t) { var e = this.getStateFrom(t); x.equals(this.state.color, e.color) || this.setState(e) }, getStateFrom: function (t) { return { color: x.parseToHsv(t.color) } }, render: function () { var t = (0, m.default)("colorpicker", { "with-opacity-slider": this.props.opacitySlider }), e = a(this.state.color, 3), n = e[0], r = e[1], o = e[2]; return s.default.createElement("div", { className: t }, s.default.createElement("div", { className: "hue-slider" }, s.default.createElement(b.default, { vertical: !0, value: n, max: 360, onChange: this.handleHueChange })), this.props.opacitySlider && s.default.createElement("div", { className: "opacity-slider" }, s.default.createElement(b.default, { vertical: !1, value: this.getAlpha(), max: 1, background: this.getBackgroundGradient(), onChange: this.handleAlphaChange })), s.default.createElement(g.default, { x: r, y: o, max: 100, className: x.isDark(this.state.color) ? "dark" : "light", backgroundColor: this.getBackgroundHue(), onChange: this.handleSaturationValueChange })) }, getAlpha: function () { return void 0 === this.state.color[3] ? 1 : this.state.color[3] }, getBackgroundGradient: function () { var t = a(this.state.color, 3), e = t[0], n = t[1], r = t[2], o = x.toRgbString([e, n, r, 1]); return "linear-gradient(to right, rgba(0,0,0,0) 0%, " + o + " 100%)" }, getBackgroundHue: function () { return x.toRgbString([this.state.color[0], 100, 100]) }, handleAlphaChange: function (t) { var e = a(this.state.color, 3), n = e[0], r = e[1], o = e[2]; this.update([n, r, o, t]) }, handleHueChange: function (t) { var e = a(this.state.color, 4), n = e[1], r = e[2], o = e[3]; this.update([t, n, r, o]) }, handleSaturationValueChange: function (t, e) { var n = a(this.state.color, 4), r = n[0], o = n[3]; this.update([r, t, e, o]) }, update: function (t) { this.setState({ color: t }), this.props.onChange(x.toRgbString(t)) } }); e.default = _ }, function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { "default": t } } Object.defineProperty(e, "__esModule", { value: !0 }); var o = n(1), a = r(o), i = n(4), s = r(i), u = n(2), c = r(u), l = n(5), f = r(l), p = n(3), d = r(p), h = n(6), m = r(h), v = (0, s.default)({ mixins: [m.default, f.default], propTypes: { x: c.default.number.isRequired, y: c.default.number.isRequired, backgroundColor: c.default.string, className: c.default.string }, getDefaultProps: function () { return { x: 0, y: 0, backgroundColor: "transparent", className: "" } }, updatePosition: function (t, e, n) { var r = (e - t.left) / t.width, o = (t.bottom - n) / t.height; this.props.onChange(this.getScaledValue(r), this.getScaledValue(o)) }, render: function () { var t = (0, d.default)("map", this.props.className, { active: this.state.active }), e = this.props.backgroundColor; return a.default.createElement("div", { className: t, onMouseDown: this.startUpdates, onTouchStart: this.startUpdates }, a.default.createElement("div", { className: "background", style: { backgroundColor: e } }), a.default.createElement("div", { className: "pointer", style: { left: this.getPercentageValue(this.props.x), bottom: this.getPercentageValue(this.props.y) } })) } }); e.default = v }, function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { "default": t } } function o(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Object.defineProperty(e, "__esModule", { value: !0 }); var a = n(1), i = r(a), s = n(4), u = r(s), c = n(2), l = r(c), f = n(5), p = r(f), d = n(3), h = r(d), m = n(6), v = r(m), g = (0, u.default)({ mixins: [v.default, p.default], propTypes: { value: l.default.number.isRequired, vertical: l.default.bool, background: l.default.string }, getDefaultProps: function () { return { value: 0, vertical: !1, background: "" } }, updatePosition: function (t, e, n) { var r = void 0; r = this.props.vertical ? (t.bottom - n) / t.height : (e - t.left) / t.width, this.props.onChange(this.getScaledValue(r)) }, getCss: function () { var t = this.props.vertical ? "bottom" : "left"; return o({}, t, this.getPercentageValue(this.props.value)) }, render: function () { var t = (0, h.default)("slider", this.props.vertical ? "vertical" : "horizontal"), e = this.props.background; return i.default.createElement("div", { className: t, onMouseDown: this.startUpdates, onTouchStart: this.startUpdates }, i.default.createElement("div", { className: "track", style: { background: e } }), i.default.createElement("div", { className: "pointer", style: this.getCss() })) } }); e.default = g }, function (t, e, n) { "use strict"; function r(t) { return t && t.__esModule ? t : { "default": t } } function o(t) { t = (0, c.default)(t); var e = (0, f.default)(t), n = 4 === t.length ? t[3] : 1; return e.push(n), e } function a(t) { var e = (0, d.default)(t); return 4 === t.length && e.push(t[3]), (0, m.default)(e) } function i(t, e) { return a(t) === a(e) } function s(t) { return (0, g.default)((0, d.default)(t)) <= 128 } Object.defineProperty(e, "__esModule", { value: !0 }), e.parseToHsv = o, e.toRgbString = a, e.equals = i, e.isDark = s; var u = n(30), c = r(u), l = n(26), f = r(l), p = n(24), d = r(p), h = n(27), m = r(h), v = n(25), g = r(v) }, function (t, e) { "use strict"; function n(t, e, n) { return Math.min(Math.max(t, e), n) } Object.defineProperty(e, "__esModule", { value: !0 }), e.default = n }, function (t, e, n) { "use strict"; function r(t) { return t } function o(t, e, n) { function o(t, e) { var n = y.hasOwnProperty(e) ? y[e] : null; _.hasOwnProperty(e) && u("OVERRIDE_BASE" === n, "ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.", e), t && u("DEFINE_MANY" === n || "DEFINE_MANY_MERGED" === n, "ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", e) } function a(t, n) { if (n) { u("function" != typeof n, "ReactClass: You're attempting to use a component class or function as a mixin. Instead, just use a regular object."), u(!e(n), "ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object."); var r = t.prototype, a = r.__reactAutoBindPairs; n.hasOwnProperty(c) && b.mixins(t, n.mixins); for (var i in n) if (n.hasOwnProperty(i) && i !== c) { var s = n[i], l = r.hasOwnProperty(i); if (o(l, i), b.hasOwnProperty(i)) b[i](t, s); else { var f = y.hasOwnProperty(i), h = "function" == typeof s, m = h && !f && !l && n.autobind !== !1; if (m) a.push(i, s), r[i] = s; else if (l) { var v = y[i]; u(f && ("DEFINE_MANY_MERGED" === v || "DEFINE_MANY" === v), "ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.", v, i), "DEFINE_MANY_MERGED" === v ? r[i] = p(r[i], s) : "DEFINE_MANY" === v && (r[i] = d(r[i], s)) } else r[i] = s } } } else; } function l(t, e) { if (e) for (var n in e) { var r = e[n]; if (e.hasOwnProperty(n)) { var o = n in b; u(!o, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', n); var a = n in t; u(!a, "ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", n), t[n] = r } } } function f(t, e) { u(t && e && "object" == typeof t && "object" == typeof e, "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects."); for (var n in e) e.hasOwnProperty(n) && (u(void 0 === t[n], "mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.", n), t[n] = e[n]); return t } function p(t, e) { return function () { var n = t.apply(this, arguments), r = e.apply(this, arguments); if (null == n) return r; if (null == r) return n; var o = {}; return f(o, n), f(o, r), o } } function d(t, e) { return function () { t.apply(this, arguments), e.apply(this, arguments) } } function h(t, e) { var n = e.bind(t); return n } function m(t) { for (var e = t.__reactAutoBindPairs, n = 0; n < e.length; n += 2) { var r = e[n], o = e[n + 1]; t[r] = h(t, o) } } function v(t) { var e = r(function (t, r, o) { this.__reactAutoBindPairs.length && m(this), this.props = t, this.context = r, this.refs = s, this.updater = o || n, this.state = null; var a = this.getInitialState ? this.getInitialState() : null; u("object" == typeof a && !Array.isArray(a), "%s.getInitialState(): must return an object or null", e.displayName || "ReactCompositeComponent"), this.state = a }); e.prototype = new N, e.prototype.constructor = e, e.prototype.__reactAutoBindPairs = [], g.forEach(a.bind(null, e)), a(e, E), a(e, t), a(e, x), e.getDefaultProps && (e.defaultProps = e.getDefaultProps()), u(e.prototype.render, "createClass(...): Class specification must implement a `render` method."); for (var o in y) e.prototype[o] || (e.prototype[o] = null); return e } var g = [], y = { mixins: "DEFINE_MANY", statics: "DEFINE_MANY", propTypes: "DEFINE_MANY", contextTypes: "DEFINE_MANY", childContextTypes: "DEFINE_MANY", getDefaultProps: "DEFINE_MANY_MERGED", getInitialState: "DEFINE_MANY_MERGED", getChildContext: "DEFINE_MANY_MERGED", render: "DEFINE_ONCE", componentWillMount: "DEFINE_MANY", componentDidMount: "DEFINE_MANY", componentWillReceiveProps: "DEFINE_MANY", shouldComponentUpdate: "DEFINE_ONCE", componentWillUpdate: "DEFINE_MANY", componentDidUpdate: "DEFINE_MANY", componentWillUnmount: "DEFINE_MANY", updateComponent: "OVERRIDE_BASE" }, b = { displayName: function (t, e) { t.displayName = e }, mixins: function (t, e) { if (e) for (var n = 0; n < e.length; n++)a(t, e[n]) }, childContextTypes: function (t, e) { t.childContextTypes = i({}, t.childContextTypes, e) }, contextTypes: function (t, e) { t.contextTypes = i({}, t.contextTypes, e) }, getDefaultProps: function (t, e) { t.getDefaultProps ? t.getDefaultProps = p(t.getDefaultProps, e) : t.getDefaultProps = e }, propTypes: function (t, e) { t.propTypes = i({}, t.propTypes, e) }, statics: function (t, e) { l(t, e) }, autobind: function () { } }, E = { componentDidMount: function () { this.__isMounted = !0 } }, x = { componentWillUnmount: function () { this.__isMounted = !1 } }, _ = { replaceState: function (t, e) { this.updater.enqueueReplaceState(this, t, e) }, isMounted: function () { return !!this.__isMounted } }, N = function () { }; return i(N.prototype, t.prototype, _), v } var a, i = n(17), s = n(15), u = n(16), c = "mixins"; a = {}, t.exports = o }, function (t, e, n) { "use strict"; var r = {}; t.exports = r }, function (t, e, n) { "use strict"; function r(t, e, n, r, a, i, s, u) { if (o(e), !t) { var c; if (void 0 === e) c = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var l = [n, r, a, i, s, u], f = 0; c = Error(e.replace(/%s/g, function () { return l[f++] })), c.name = "Invariant Violation" } throw c.framesToPop = 1, c } } var o = function (t) { }; t.exports = r }, function (t, e) { "use strict"; function n(t) { if (null === t || void 0 === t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } function r() { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var e = {}, n = 0; n < 10; n++)e["_" + String.fromCharCode(n)] = n; var r = Object.getOwnPropertyNames(e).map(function (t) { return e[t] }); if ("0123456789" !== r.join("")) return !1; var o = {}; return "abcdefghijklmnopqrst".split("").forEach(function (t) { o[t] = t }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, o)).join("") } catch (a) { return !1 } } var o = Object.getOwnPropertySymbols, a = Object.prototype.hasOwnProperty, i = Object.prototype.propertyIsEnumerable; t.exports = r() ? Object.assign : function (t, e) { for (var r, s, u = n(t), c = 1; c < arguments.length; c++) { r = Object(arguments[c]); for (var l in r) a.call(r, l) && (u[l] = r[l]); if (o) { s = o(r); for (var f = 0; f < s.length; f++)i.call(r, s[f]) && (u[s[f]] = r[s[f]]) } } return u } }, function (t, e) { "use strict"; function n(t, e) { return t === e ? 0 !== t || 0 !== e || 1 / t === 1 / e : t !== t && e !== e } function r(t, e) { if (n(t, e)) return !0; if ("object" != typeof t || null === t || "object" != typeof e || null === e) return !1; var r = Object.keys(t), a = Object.keys(e); if (r.length !== a.length) return !1; for (var i = 0; i < r.length; i++)if (!o.call(e, r[i]) || !n(t[r[i]], e[r[i]])) return !1; return !0 } var o = Object.prototype.hasOwnProperty; t.exports = r }, function (t, e, n) { "use strict"; var r = n(21), o = n(22), a = n(20); t.exports = function () { function t(t, e, n, r, i, s) { s !== a && o(!1, "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types") } function e() { return t } t.isRequired = t; var n = { array: t, bool: t, func: t, number: t, object: t, string: t, symbol: t, any: t, arrayOf: e, element: t, instanceOf: e, node: t, objectOf: e, oneOf: e, oneOfType: e, shape: e }; return n.checkPropTypes = r, n.PropTypes = n, n } }, function (t, e) { "use strict"; var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"; t.exports = n }, function (t, e) { "use strict"; function n(t) { return function () { return t } } var r = function () { }; r.thatReturns = n, r.thatReturnsFalse = n(!1), r.thatReturnsTrue = n(!0), r.thatReturnsNull = n(null), r.thatReturnsThis = function () { return this }, r.thatReturnsArgument = function (t) { return t }, t.exports = r }, function (t, e, n) { "use strict"; function r(t, e, n, r, a, i, s, u) { if (o(e), !t) { var c; if (void 0 === e) c = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var l = [n, r, a, i, s, u], f = 0; c = Error(e.replace(/%s/g, function () { return l[f++] })), c.name = "Invariant Violation" } throw c.framesToPop = 1, c } } var o = function (t) { }; t.exports = r }, function (t, e) { function n(t) { var e, n, r, o, a, i = t[0] / 360, s = t[1] / 100, u = t[2] / 100; if (0 == s) return a = 255 * u, [a, a, a]; n = u < .5 ? u * (1 + s) : u + s - u * s, e = 2 * u - n, o = [0, 0, 0]; for (var c = 0; c < 3; c++)r = i + 1 / 3 * -(c - 1), r < 0 && r++, r > 1 && r--, a = 6 * r < 1 ? e + 6 * (n - e) * r : 2 * r < 1 ? n : 3 * r < 2 ? e + (n - e) * (2 / 3 - r) * 6 : e, o[c] = 255 * a; return o } t.exports = n }, function (t, e) { function n(t) { var e = t[0] / 60, n = t[1] / 100, r = t[2] / 100, o = Math.floor(e) % 6, a = e - Math.floor(e), i = 255 * r * (1 - n), s = 255 * r * (1 - n * a), u = 255 * r * (1 - n * (1 - a)), r = 255 * r; switch (o) { case 0: return [r, u, i]; case 1: return [s, r, i]; case 2: return [i, r, u]; case 3: return [i, s, r]; case 4: return [u, i, r]; case 5: return [r, i, s] } } t.exports = n }, function (t, e) { function n(t) { return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 } t.exports = n }, function (t, e) { function n(t) { var e, n, r, o = t[0], a = t[1], i = t[2], s = Math.min(o, a, i), u = Math.max(o, a, i), c = u - s; return n = 0 == u ? 0 : c / u * 1e3 / 10, u == s ? e = 0 : o == u ? e = (a - i) / c : a == u ? e = 2 + (i - o) / c : i == u && (e = 4 + (o - a) / c), e = Math.min(60 * e, 360), e < 0 && (e += 360), r = u / 255 * 1e3 / 10, [e, n, r] } t.exports = n }, function (t, e) { function n(t) { var e = "rgb"; return 4 === t.length && (e += "a"), t[0] = Math.round(t[0]), t[1] = Math.round(t[1]), t[2] = Math.round(t[2]), e + "(" + t.join(",") + ")" } t.exports = n }, function (t, e) { function n(t) { return 4 === t.length && (t = "#" + t.charAt(1) + t.charAt(1) + t.charAt(2) + t.charAt(2) + t.charAt(3) + t.charAt(3)), [parseInt(t.substring(1, 3), 16), parseInt(t.substring(3, 5), 16), parseInt(t.substring(5, 7), 16)] } t.exports = n }, function (t, e, n) { function r(t, e) { switch (t = parseFloat(t), e) { case 0: return i(t, 0, 360); case 1: case 2: return i(t, 0, 100); case 3: return i(t, 0, 1) } } function o(t) { return a(t).map(r) } var a = n(7), i = n(8); t.exports = o }, function (t, e, n) { function r(t) { var e = a(t), n = u(e); return 4 === e.length && n.push(e[3]), n } function o(t) { for (var e in c) if (0 === t.indexOf(e)) return c[e](t) } var a = n(29), i = n(28), s = n(31), u = n(23), c = { "#": i, hsl: r, rgb: s }; o.rgb = s, o.hsl = a, o.hex = i, t.exports = o }, function (t, e, n) { function r(t, e) { return e < 3 ? t.indexOf("%") != -1 ? Math.round(255 * i(parseInt(t, 10), 0, 100) / 100) : i(parseInt(t, 10), 0, 255) : i(parseFloat(t), 0, 1) } function o(t) { return a(t).map(r) } var a = n(7), i = n(8); t.exports = o }, function (t, n) { t.exports = e }]) });
(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } g.Polylabel = f() } })(function () {
    var define, module, exports; return (function () { function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s } return e })()({
        1: [function (require, module, exports) {
            // taken from https://github.com/mapbox/polylabel/blob/master/polylabel.js
            'use strict';

            var Queue = require('tinyqueue');

            module.exports = polylabel;
            module.exports.default = polylabel;

            function polylabel(polygon, precision, debug) {
                precision = precision || 1.0;

                // find the bounding box of the outer ring
                var minX, minY, maxX, maxY;
                for (var i = 0; i < polygon[0].length; i++) {
                    var p = polygon[0][i];
                    if (!i || p[0] < minX) minX = p[0];
                    if (!i || p[1] < minY) minY = p[1];
                    if (!i || p[0] > maxX) maxX = p[0];
                    if (!i || p[1] > maxY) maxY = p[1];
                }

                var width = maxX - minX;
                var height = maxY - minY;
                var cellSize = Math.min(width, height);
                var h = cellSize / 2;

                if (cellSize === 0) {
                    var degeneratePoleOfInaccessibility = [minX, minY];
                    degeneratePoleOfInaccessibility.distance = 0;
                    return degeneratePoleOfInaccessibility;
                }

                // a priority queue of cells in order of their "potential" (max distance to polygon)
                var cellQueue = new Queue(undefined, compareMax);

                // cover polygon with initial cells
                for (var x = minX; x < maxX; x += cellSize) {
                    for (var y = minY; y < maxY; y += cellSize) {
                        cellQueue.push(new Cell(x + h, y + h, h, polygon));
                    }
                }

                // take centroid as the first best guess
                var bestCell = getCentroidCell(polygon);

                // second guess: bounding box centroid
                var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
                if (bboxCell.d > bestCell.d) bestCell = bboxCell;

                var numProbes = cellQueue.length;

                while (cellQueue.length) {
                    // pick the most promising cell from the queue
                    var cell = cellQueue.pop();

                    // update the best cell if we found a better one
                    if (cell.d > bestCell.d) {
                        bestCell = cell;
                        if (debug) console.log('found best %f after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);
                    }

                    // do not drill down further if there's no chance of a better solution
                    if (cell.max - bestCell.d <= precision) continue;

                    // split the cell into four cells
                    h = cell.h / 2;
                    cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));
                    cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));
                    cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));
                    cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));
                    numProbes += 4;
                }

                if (debug) {
                    console.log('num probes: ' + numProbes);
                    console.log('best distance: ' + bestCell.d);
                }

                var poleOfInaccessibility = [bestCell.x, bestCell.y];
                poleOfInaccessibility.distance = bestCell.d;
                return poleOfInaccessibility;
            }

            function compareMax(a, b) {
                return b.max - a.max;
            }

            function Cell(x, y, h, polygon) {
                this.x = x; // cell center x
                this.y = y; // cell center y
                this.h = h; // half the cell size
                this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon
                this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell
            }

            // signed distance from point to polygon outline (negative if point is outside)
            function pointToPolygonDist(x, y, polygon) {
                var inside = false;
                var minDistSq = Infinity;

                for (var k = 0; k < polygon.length; k++) {
                    var ring = polygon[k];

                    for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
                        var a = ring[i];
                        var b = ring[j];

                        if ((a[1] > y !== b[1] > y) &&
                            (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;

                        minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));
                    }
                }

                return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);
            }

            // get polygon centroid
            function getCentroidCell(polygon) {
                var area = 0;
                var x = 0;
                var y = 0;
                var points = polygon[0];

                for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                    var a = points[i];
                    var b = points[j];
                    var f = a[0] * b[1] - b[0] * a[1];
                    x += (a[0] + b[0]) * f;
                    y += (a[1] + b[1]) * f;
                    area += f * 3;
                }
                if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);
                return new Cell(x / area, y / area, 0, polygon);
            }

            // get squared distance from a point to a segment
            function getSegDistSq(px, py, a, b) {

                var x = a[0];
                var y = a[1];
                var dx = b[0] - x;
                var dy = b[1] - y;

                if (dx !== 0 || dy !== 0) {

                    var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

                    if (t > 1) {
                        x = b[0];
                        y = b[1];

                    } else if (t > 0) {
                        x += dx * t;
                        y += dy * t;
                    }
                }

                dx = px - x;
                dy = py - y;

                return dx * dx + dy * dy;
            }

        }, { "tinyqueue": 2 }], 2: [function (require, module, exports) {
            'use strict';

            module.exports = TinyQueue;
            module.exports.default = TinyQueue;

            function TinyQueue(data, compare) {
                if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

                this.data = data || [];
                this.length = this.data.length;
                this.compare = compare || defaultCompare;

                if (this.length > 0) {
                    for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
                }
            }

            function defaultCompare(a, b) {
                return a < b ? -1 : a > b ? 1 : 0;
            }

            TinyQueue.prototype = {

                push: function (item) {
                    this.data.push(item);
                    this.length++;
                    this._up(this.length - 1);
                },

                pop: function () {
                    if (this.length === 0) return undefined;

                    var top = this.data[0];
                    this.length--;

                    if (this.length > 0) {
                        this.data[0] = this.data[this.length];
                        this._down(0);
                    }
                    this.data.pop();

                    return top;
                },

                peek: function () {
                    return this.data[0];
                },

                _up: function (pos) {
                    var data = this.data;
                    var compare = this.compare;
                    var item = data[pos];

                    while (pos > 0) {
                        var parent = (pos - 1) >> 1;
                        var current = data[parent];
                        if (compare(item, current) >= 0) break;
                        data[pos] = current;
                        pos = parent;
                    }

                    data[pos] = item;
                },

                _down: function (pos) {
                    var data = this.data;
                    var compare = this.compare;
                    var halfLength = this.length >> 1;
                    var item = data[pos];

                    while (pos < halfLength) {
                        var left = (pos << 1) + 1;
                        var right = left + 1;
                        var best = data[left];

                        if (right < this.length && compare(data[right], best) < 0) {
                            left = right;
                            best = data[right];
                        }
                        if (compare(best, item) >= 0) break;

                        data[pos] = best;
                        pos = left;
                    }

                    data[pos] = item;
                }
            };

        }, {}]
    }, {}, [1])(1)
});

"use strict";
var mercator = { version: 18 };
let oldElementRemove = SVG.Element.prototype.remove;

function draggingReallyStartedAndNotJustClick(t, e) {
    return Math.abs(t) > 3 || Math.abs(e) > 3
}

function average(t, e) {
    return (t + e) / 2
}
SVG.extend(SVG.Element, {
    applyZoom(t) {
        return t.zoomer.applyToElement(this), this
    },
    applyZoomButKeepSize(t) {
        return this.keepSize = !0, t.zoomer.applyToElement(this), this
    },
    attrIf(t, e) {
        return t && this.attr(e), this
    },
    setExtraZoom(t) {
        return this.extraZoom = t, this
    },
    zoomAndRotateTo(t, e, n, r) {
        return this.rotationAngle = t, e.zoomer.applyToElement(this, n, r), this
    },
    zoomAndRotate(t, e) {
        return this.rotationCenter = null, this.rotationAngle = t, this.applyZoom(e), this
    },
    zoomAndRotateAround(t, e, n) {
        return this.rotationCenter = e, this.rotationAngle = t, this.applyZoom(n), this
    },
    toLayer(t, e, n) {
        return e.layers.add(this, t, n), this
    },
    insertAfter(t) {
        t.node.parentNode.insertBefore(this.node, t.node.nextSibling)
    },
    remove() {
        this.mercatorLayer && this.mercatorLayer.remove(this), oldElementRemove.apply(this), this.raphaelElement.undrag()
    },
    stop() {
        return this.raphaelElement.stop(), this
    },
    onDrag(t, e, n, r, o) {
        return mercator.onDrag(t, this, e, n, r, o), this
    },
    onDragTransform(t, e, n, r, o, i) {
        var s, a;
        let u = () => mercator.set(this, "function" == typeof e ? e() : e);
        return mercator.onDrag(t, this, function (t, e, r) {
            s = t, a = e, u().transform(n(t, e, r))
        }, function () {
            r && r(), u().startTransformation()
        }, function () {
            o && o(s, a), u().endTransformation()
        }, i), this
    }
});
const isPointInsideBBox = function (t, e, n) {
    return e >= t.x && e <= t.x2 && n >= t.y && n <= t.y2
},
    isBBoxIntersect = function (t, e) {
        var n = isPointInsideBBox;
        return n(e, t.x, t.y) || n(e, t.x2, t.y) || n(e, t.x, t.y2) || n(e, t.x2, t.y2) || n(t, e.x, e.y) || n(t, e.x2, e.y) || n(t, e.x, e.y2) || n(t, e.x2, e.y2) || (t.x < e.x2 && t.x > e.x || e.x < t.x2 && e.x > t.x) && (t.y < e.y2 && t.y > e.y || e.y < t.y2 && e.y > t.y)
    };

function pushAll(t, e) {
    return "function" == typeof e.forEach ? e.forEach(function (e) {
        e && pushAll(t, e)
    }) : e && t.push(e), t
}

function isInteger(t) {
    return /^\+?(0|[1-9]\d*)$/.test(t)
}

function isPositiveInteger(t) {
    return isInteger(t) && Number(t) > 0
}

function detectCategoryKeyType(t) {
    return isPositiveInteger(t) ? parseInt(t) : t
}

function isBlank(t) {
    return !t || /^\s*$/.test(t)
}

function whitespaceToNonBreakingSpaces(t) {
    return t.replace(/\s/g, String.fromCharCode(160))
}

function toSecondOrThirdQuadrant(t) {
    return t > 90 && t < 270 ? t + 180 : t
}

function toJson(t) {
    return t.toJson()
}

function cloneJson(t) {
    return t ? JSON.parse(JSON.stringify(t)) : t
}

function delay(t) {
    setTimeout(t, 0)
}

function range(t, e) {
    for (var n = [], r = t; r <= e; r++) n.push(r);
    return n
}

function romanize(t) {
    if (!+t) return NaN;
    for (var e = String(+t).split(""), n = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"], r = "", o = 3; o--;) r = (n[+e.pop() + 10 * o] || "") + r;
    return Array(+e.join("") + 1).join("M") + r
}

function parseOdd(t) {
    return 2 * Math.floor(parseInt(t) / 2) + 1
}

function parseEven(t) {
    return 2 * Math.round(parseInt(t) / 2)
}

function equalCaseInsentive(t, e) {
    return t.toString().toUpperCase() === e.toString().toUpperCase()
}

function getWithDefault(t, e) {
    return null === t || void 0 === t ? e : t
}

function preventDefault(t) {
    return function (e) {
        e.preventDefault(), t()
    }
}

function rand(t, e) {
    return t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t
}

function median(t) {
    t.sort(function (t, e) {
        return t - e
    });
    const e = Math.floor(t.length / 2);
    return t.length % 2 ? t[e] : t[e - 1]
}

function promiseToDeferred(t) {
    var e = $.Deferred();
    return t.then(function () {
        e.resolve()
    }, function () {
        e.reject()
    }), e
}

function seatsUnicode(t) {
    if (void 0 === seatsUnicodeCache[t]) {
        var e = document.createElement("span");
        e.className = "icon-" + t, document.body.appendChild(e);
        var n = window.getComputedStyle(e, ":before").content,
            r = "none" === n ? "" : n.substring(1, n.length - 1);
        e.remove(), seatsUnicodeCache[t] = r
    }
    return seatsUnicodeCache[t]
}

function wrapAround(t, e, n) {
    return t < e ? n - (e - t) % (n - e) : e + (t - e) % (n - e)
}

function wrapRotationAround(t) {
    return Math.round(wrapAround(t, 0, 360))
}

function shallowDifferentObjectValues(t, e) {
    if (null === t || null === e || "object" != typeof t || "object" != typeof e) return t !== e;
    const n = Object.keys(t);
    return n.length !== Object.keys(e).length || n.some(n => t[n] !== e[n])
}

function differentObjectValues(t, e, n = null) {
    if (null === t || null === e || "object" != typeof t || "object" != typeof e) return t !== e;
    const r = Object.keys(t);
    return !n && r.length !== Object.keys(e).length || (n || r).some(n => differentObjectValues(t[n], e[n]))
}

function getObjectDifferences(t, e) {
    if (null === t || null === e || "object" != typeof t || "object" != typeof e) return [];
    const n = Object.keys(t),
        r = Object.keys(e);
    return n.concat(r).map(n => differentObjectValues(t[n], e[n]) ? n : null).uniques().filter(t => null !== t)
}

function numberInRangeToPercent(t, e, n) {
    if (Array.isArray(t) && (t = Math.min(...t)), null == t) return 0;
    const r = (t - e) / (n - e);
    return Math.abs(100 * r)
}

function percentToNumberInRange(t, e, n) {
    let r = t / 100;
    const o = n - e;
    return Math.round(e + o * r)
}